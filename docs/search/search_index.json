{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Faust A Functional Programming Language for Real Time Signal Processing What is Faust? Faust (Functional Audio Stream) is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. Faust targets high-performance signal processing applications and audio plug-ins for a variety of platforms and standards. The core component of Faust is its compiler. It allows to \"translate\" any Faust digital signal processing (DSP) specification to a wide range of non-domain specific languages such as C++, C, JAVA, JavaScript, LLVM bit code, WebAssembly, etc. In this regard, Faust can be seen as an alternative to C++ but is much simpler and intuitive to learn. Thanks to a wrapping system called \"architectures\", codes generated by Faust can be easily compiled into a wide variety of objects ranging from audio plug-ins to standalone applications or smartphone and web apps, etc. (check the Quick Tour of the Faust Targets section for an exhaustive list. Site Content What are you gonna find here? This site documents all the Faust environment : the compiler and how to use it etc... Getting Started There are many ways to get started with Faust, choose the one that suits you the best: If you have an hour or two to spare, check out Quick Start Tutorial (recommended option). If you're in a hurry or if you hate to wait, check out our Online Examples . If you wanna do things the right way, read the Faust Manual .","title":"Home"},{"location":"#welcome-to-faust","text":"A Functional Programming Language for Real Time Signal Processing","title":"Welcome to Faust"},{"location":"#what-is-faust","text":"Faust (Functional Audio Stream) is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. Faust targets high-performance signal processing applications and audio plug-ins for a variety of platforms and standards. The core component of Faust is its compiler. It allows to \"translate\" any Faust digital signal processing (DSP) specification to a wide range of non-domain specific languages such as C++, C, JAVA, JavaScript, LLVM bit code, WebAssembly, etc. In this regard, Faust can be seen as an alternative to C++ but is much simpler and intuitive to learn. Thanks to a wrapping system called \"architectures\", codes generated by Faust can be easily compiled into a wide variety of objects ranging from audio plug-ins to standalone applications or smartphone and web apps, etc. (check the Quick Tour of the Faust Targets section for an exhaustive list.","title":"What is Faust?"},{"location":"#site-content","text":"What are you gonna find here? This site documents all the Faust environment : the compiler and how to use it etc...","title":"Site Content"},{"location":"#getting-started","text":"There are many ways to get started with Faust, choose the one that suits you the best: If you have an hour or two to spare, check out Quick Start Tutorial (recommended option). If you're in a hurry or if you hate to wait, check out our Online Examples . If you wanna do things the right way, read the Faust Manual .","title":"Getting Started"},{"location":"about/","text":"The Faust Project The Faust Project has started in 2004. It is actively developped by the Grame Research Lab Acknowledgments Many persons are contributing to the Faust project, by providing code for the compiler, architecture files, libraries, examples, documentation, scripts, bug reports, ideas, etc. We would like in particular to thank: Fons Adriaensen, Karim Barkati, J\u00e9r\u00f4me Barth\u00e9lemy, Tim Blechmann, Tiziano Bole, Alain Bonardi, Thomas Charbonnel, Raffaele Ciavarella, Julien Colafrancesco, Damien Cramet, Sarah Denoux, \u00c9tienne Gaudrin, Olivier Guillerminet, Pierre Guillot, Albert Gr\u00e4f, Pierre Jouvelot, Stefan Kersten, Victor Lazzarini, Matthieu Leberre, Mathieu Leroi, Fernando Lopez-Lezcano, Kjetil Matheussen, Hermann Meyer, R\u00e9my Muller, Raphael Panis, Eliott Paris, Reza Payami, Laurent Pottier, Sampo Savolainen, Nicolas Scaringella, Anne Sedes, Priyanka Shekar, Stephen Sinclair, Travis Skare, Julius Smith, Mike Solomon, Michael Wilson. as well as our colleagues at GRAME : Dominique Fober Christophe Lebreton St\u00e9phane Letz Romain Michon Yann Orlarey We would like also to thank for their financial support: the French Ministry of Culture the Auvergne-Rh\u00f4ne-Alpes Region the City of Lyon the French National Research Agency (ANR)","title":"About"},{"location":"about/#the-faust-project","text":"The Faust Project has started in 2004. It is actively developped by the Grame Research Lab","title":"The Faust Project"},{"location":"about/#acknowledgments","text":"Many persons are contributing to the Faust project, by providing code for the compiler, architecture files, libraries, examples, documentation, scripts, bug reports, ideas, etc. We would like in particular to thank: Fons Adriaensen, Karim Barkati, J\u00e9r\u00f4me Barth\u00e9lemy, Tim Blechmann, Tiziano Bole, Alain Bonardi, Thomas Charbonnel, Raffaele Ciavarella, Julien Colafrancesco, Damien Cramet, Sarah Denoux, \u00c9tienne Gaudrin, Olivier Guillerminet, Pierre Guillot, Albert Gr\u00e4f, Pierre Jouvelot, Stefan Kersten, Victor Lazzarini, Matthieu Leberre, Mathieu Leroi, Fernando Lopez-Lezcano, Kjetil Matheussen, Hermann Meyer, R\u00e9my Muller, Raphael Panis, Eliott Paris, Reza Payami, Laurent Pottier, Sampo Savolainen, Nicolas Scaringella, Anne Sedes, Priyanka Shekar, Stephen Sinclair, Travis Skare, Julius Smith, Mike Solomon, Michael Wilson. as well as our colleagues at GRAME : Dominique Fober Christophe Lebreton St\u00e9phane Letz Romain Michon Yann Orlarey We would like also to thank for their financial support: the French Ministry of Culture the Auvergne-Rh\u00f4ne-Alpes Region the City of Lyon the French National Research Agency (ANR)","title":"Acknowledgments"},{"location":"examples/SAM/","text":"SAM","title":" SAM "},{"location":"examples/SAM/#sam","text":"","title":"SAM"},{"location":"examples/ambisonics/","text":"ambisonics fourSourcesToOcto declare name fourSourcesToOcto ; declare version 1.0 ; declare author CICM ; declare license BSD ; declare copyright (c)CICM 2013 ; import( stdfaust.lib ); r1 = hslider( Radius1 , 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02)); a1 = hslider( Angle1 , 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02)); r2 = hslider( Radius2 , 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02)); a2 = hslider( Angle2 , 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02)); r3 = hslider( Radius3 , 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02)); a3 = hslider( Angle3 , 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02)); r4 = hslider( Radius4 , 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02)); a4 = hslider( Angle4 , 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02)); process(sig1, sig2, sig3, sig4) = ho.map(3, sig1, r1, a1), ho.map(3, sig2, r2, a2), ho.map(3, sig3, r3, a3), ho.map(3, sig4, r4, a4) : ho.optimInPhase(3) : ho.decoder(3, 8); Try it Yourself >> oneSourceToStereo declare name oneSourceToStereo ; declare version 1.0 ; declare author CICM ; declare license BSD ; declare copyright (c)CICM 2013 ; import( stdfaust.lib ); r1 = hslider( Radius , 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02)); a1 = hslider( Angle , 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02)); process(sig) = ho.map(7, sig, r1, a1) : ho.optimInPhase(7) : ho.decoderStereo(7); Try it Yourself >>","title":" ambisonics "},{"location":"examples/ambisonics/#ambisonics","text":"","title":"ambisonics"},{"location":"examples/ambisonics/#foursourcestoocto","text":"declare name fourSourcesToOcto ; declare version 1.0 ; declare author CICM ; declare license BSD ; declare copyright (c)CICM 2013 ; import( stdfaust.lib ); r1 = hslider( Radius1 , 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02)); a1 = hslider( Angle1 , 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02)); r2 = hslider( Radius2 , 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02)); a2 = hslider( Angle2 , 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02)); r3 = hslider( Radius3 , 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02)); a3 = hslider( Angle3 , 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02)); r4 = hslider( Radius4 , 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02)); a4 = hslider( Angle4 , 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02)); process(sig1, sig2, sig3, sig4) = ho.map(3, sig1, r1, a1), ho.map(3, sig2, r2, a2), ho.map(3, sig3, r3, a3), ho.map(3, sig4, r4, a4) : ho.optimInPhase(3) : ho.decoder(3, 8); Try it Yourself >>","title":"fourSourcesToOcto"},{"location":"examples/ambisonics/#onesourcetostereo","text":"declare name oneSourceToStereo ; declare version 1.0 ; declare author CICM ; declare license BSD ; declare copyright (c)CICM 2013 ; import( stdfaust.lib ); r1 = hslider( Radius , 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02)); a1 = hslider( Angle , 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02)); process(sig) = ho.map(7, sig, r1, a1) : ho.optimInPhase(7) : ho.decoderStereo(7); Try it Yourself >>","title":"oneSourceToStereo"},{"location":"examples/analysis/","text":"analysis dbmeter declare name dbmeter ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------- // A dB Vumeter //------------------------------------------------- import( stdfaust.lib ); vmeter(x) = attach(x, envelop(x) : vbargraph( [unit:dB] , -70, 10)); hmeter(x) = attach(x, envelop(x) : hbargraph( [unit:dB] , -70, 10)); envelop = abs : max(ba.db2linear(-70)) : ba.linear2db : min(10) : max ~ -(80.0/ma.SR); null(x) = attach(0,x); process = hgroup( 8 channels dB meter , par(i,8, vgroup( %i , vmeter : null))); Try it Yourself >> FFT // Radix 2 FFT, decimation in time, real and imag parts interleaved declare name FFT ; // Faust Fourier Transform :-) declare author JOS ; declare license STK-4.3 ; import( stdfaust.lib ); N=32; // FFT size (power of 2) // Number of frequency bins (including dc and SR/2) is N/2+1 No2 = N 1; signal = amp * cosine with { cosine = select2(k==0, select2(k==No2, 2.0*os.oscrc(f(k)), // 2x since negative-frequencies not displayed 1-1':+~*(-1) // Alternating sequence: 1, -1, 1, -1 ), 1.0); // make sure phase is zero (freq jumps around) f(k) = float(k) * ma.SR / float(N); // only test FFT bin frequencies k = hslider( [2] FFT Bin Number ,N/4,0,No2,0.001) : int : _,dpy : attach; dpy = hbargraph( [3] Measured FFT Bin Number ,0,No2); amp = hslider( [4] Amplitude ,0.1,0,1,0.001); }; process = signal : dm.fft_spectral_level_demo(N) : _,_; Try it Yourself >> spectralLevel declare name spectralLevel ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Demonstrates mth_octave_spectral_level in a standalone GUI. ; import( stdfaust.lib ); process = dm.spectral_level_demo; Try it Yourself >> spectralTiltLab // example exercising filters.lib's spectral_tilt_demo declare name spectralTiltLab ; import( stdfaust.lib ); N = 10; // Number of pole-zero pairs to use process = sig(dm.sawtooth_demo) : stg(ba.bypass1(bp,dm.spectral_tilt_demo(N))) : sag(dm.spectral_level_demo) with { bp = stg(checkbox( [0] Bypass Spectral Tilt )); stg(x) = vgroup( [1] Spectral Tilt Filter [tooltip: See Faust's filters.lib for spectral_tilt_demo] ,x); sig(x) = vgroup( [2] Test Signal [tooltip: See Faust's oscillator.lib for sawtooth_demo] ,x); sag(x) = vgroup( [4] Spectrum Analyzer [tooltip: See Faust's filters.lib for spectral_level_demo] ,x); }; Try it Yourself >> vumeter declare name vumeter ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------- // Simple vumeter //------------------------------------------------- import( stdfaust.lib ); vmeter(x) = attach(x, envelop(x) : vbargraph( [2][unit:dB] , -70, +5)); hmeter(x) = attach(x, envelop(x) : hbargraph( [2][unit:dB] , -70, +5)); envelop = abs : max ~ -(1.0/ma.SR) : max(ba.db2linear(-70)) : ba.linear2db; process = hmeter,hmeter; Try it Yourself >>","title":" analysis "},{"location":"examples/analysis/#analysis","text":"","title":"analysis"},{"location":"examples/analysis/#dbmeter","text":"declare name dbmeter ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------- // A dB Vumeter //------------------------------------------------- import( stdfaust.lib ); vmeter(x) = attach(x, envelop(x) : vbargraph( [unit:dB] , -70, 10)); hmeter(x) = attach(x, envelop(x) : hbargraph( [unit:dB] , -70, 10)); envelop = abs : max(ba.db2linear(-70)) : ba.linear2db : min(10) : max ~ -(80.0/ma.SR); null(x) = attach(0,x); process = hgroup( 8 channels dB meter , par(i,8, vgroup( %i , vmeter : null))); Try it Yourself >>","title":"dbmeter"},{"location":"examples/analysis/#fft","text":"// Radix 2 FFT, decimation in time, real and imag parts interleaved declare name FFT ; // Faust Fourier Transform :-) declare author JOS ; declare license STK-4.3 ; import( stdfaust.lib ); N=32; // FFT size (power of 2) // Number of frequency bins (including dc and SR/2) is N/2+1 No2 = N 1; signal = amp * cosine with { cosine = select2(k==0, select2(k==No2, 2.0*os.oscrc(f(k)), // 2x since negative-frequencies not displayed 1-1':+~*(-1) // Alternating sequence: 1, -1, 1, -1 ), 1.0); // make sure phase is zero (freq jumps around) f(k) = float(k) * ma.SR / float(N); // only test FFT bin frequencies k = hslider( [2] FFT Bin Number ,N/4,0,No2,0.001) : int : _,dpy : attach; dpy = hbargraph( [3] Measured FFT Bin Number ,0,No2); amp = hslider( [4] Amplitude ,0.1,0,1,0.001); }; process = signal : dm.fft_spectral_level_demo(N) : _,_; Try it Yourself >>","title":"FFT"},{"location":"examples/analysis/#spectrallevel","text":"declare name spectralLevel ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Demonstrates mth_octave_spectral_level in a standalone GUI. ; import( stdfaust.lib ); process = dm.spectral_level_demo; Try it Yourself >>","title":"spectralLevel"},{"location":"examples/analysis/#spectraltiltlab","text":"// example exercising filters.lib's spectral_tilt_demo declare name spectralTiltLab ; import( stdfaust.lib ); N = 10; // Number of pole-zero pairs to use process = sig(dm.sawtooth_demo) : stg(ba.bypass1(bp,dm.spectral_tilt_demo(N))) : sag(dm.spectral_level_demo) with { bp = stg(checkbox( [0] Bypass Spectral Tilt )); stg(x) = vgroup( [1] Spectral Tilt Filter [tooltip: See Faust's filters.lib for spectral_tilt_demo] ,x); sig(x) = vgroup( [2] Test Signal [tooltip: See Faust's oscillator.lib for sawtooth_demo] ,x); sag(x) = vgroup( [4] Spectrum Analyzer [tooltip: See Faust's filters.lib for spectral_level_demo] ,x); }; Try it Yourself >>","title":"spectralTiltLab"},{"location":"examples/analysis/#vumeter","text":"declare name vumeter ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------- // Simple vumeter //------------------------------------------------- import( stdfaust.lib ); vmeter(x) = attach(x, envelop(x) : vbargraph( [2][unit:dB] , -70, +5)); hmeter(x) = attach(x, envelop(x) : hbargraph( [2][unit:dB] , -70, +5)); envelop = abs : max ~ -(1.0/ma.SR) : max(ba.db2linear(-70)) : ba.linear2db; process = hmeter,hmeter; Try it Yourself >>","title":"vumeter"},{"location":"examples/bela/","text":"bela AdditiveSynth_Analog import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Additive synthesizer, must be used with OSC message to program sound. // It as 8 harmonics. Each have it's own volume envelope. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : vol0 (volum of fundamental) // ANALOG_1 : vol1 // ... // ANALOG_7 : vol7 // // OSC messages (see BELA console for precise adress) // For each harmonics (%rang indicate harmonic number, starting at 0) : // A%rang : Attack // D%rang : Decay // S%rang : Sustain // R%rang : Release // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL midigate = button( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 10, 0.01); // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; partiel(rang) = os.oscrs(gFreq*(rang+1))*volume with { // UI vol = hslider( vol%rang[BELA: ANALOG_%rang] , 1, 0, 1, 0.001); a = 0.01 * hslider( A%rang , 1, 0, 400, 0.001); d = 0.01 * hslider( D%rang , 1, 0, 400, 0.001); s = hslider( S%rang , 1, 0, 1, 0.001); r = 0.01 * hslider( R%rang , 1, 0, 800, 0.001); volume = ((en.adsr(a,d,s,r,midigate))*vol) : max (0) : min (1); }; process = par(i, 8, partiel(i)) : / (8); Try it Yourself >> AdditiveSynth import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Additive synthesizer, must be used with OSC message to program sound. // It as 8 harmonics. Each have it's own volume envelope. // /////////////////////////////////////////////////////////////////////////////////////////////////// // // OSC messages (see BELA console for precise adress) // For each harmonics (%rang indicate harmonic number, starting at 0) : // vol%rang : General Volume (vol0 control the volume of the fundamental) // A%rang : Attack // D%rang : Decay // S%rang : Sustain // R%rang : Release // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL midigate = button( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 10, 0.01); // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; partiel(rang) = os.oscrs(gFreq*(rang+1))*volume with { // UI vol = hslider( vol%rang , 1, 0, 1, 0.001); a = 0.01 * hslider( A%rang , 1, 0, 400, 0.001); d = 0.01 * hslider( D%rang , 1, 0, 400, 0.001); s = hslider( S%rang , 1, 0, 1, 0.001); r = 0.01 * hslider( R%rang , 1, 0, 800, 0.001); volume = ((en.adsr(a,d,s,r,midigate))*vol) : max (0) : min (1); }; process = par(i, 8, partiel(i)) : / (8); Try it Yourself >> crossDelay2 import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Stereo Delay with feedback and crossfeedback (L to R and R to L feedback). // And pitch shifting on feedback. // A pre-delay without feedback is added for a wider stereo effect. // // Designed to use the Analog Input for parameters controls. // /////////////////////////////////////////////////////////////////////////////////////////////////// // // ANALOG IN: // ANALOG 0 : Pre-Delay L // ANALOG 1 : Pre-Delay R // ANALOG 2 : Delay L // ANALOG 3 : Delay R // ANALOG 4 : Cross feedback // ANALOG 5 : Feedback // ANALOG 6 : Pitchshifter L // ANALOG 7 : Pitchshifter R // // Available by OSC : (see BELA console for precise adress) // Feedback filter: // crossLF : Crossfeedback Lowpass // crossHF : Crossfeedback Highpass // feedbLF : Feedback Lowpass // feedbHF : Feedback Highpass // /////////////////////////////////////////////////////////////////////////////////////////////////// preDelL = ba.sec2samp(hslider( preDelL[BELA: ANALOG_0] , 1,0,2,0.001)):si.smoo; preDelR = ba.sec2samp(hslider( preDelR[BELA: ANALOG_1] , 1,0,2,0.001)):si.smoo; delL = ba.sec2samp(hslider( delL[BELA: ANALOG_2] , 1,0,2,0.001)):si.smoo; delR = ba.sec2samp(hslider( delR[BELA: ANALOG_3] , 1,0,2,0.001)):si.smoo; crossLF = hslider( crossLF , 12000, 20, 20000, 0.001); crossHF = hslider( crossHF , 60, 20, 20000, 0.001); feedbLF = hslider( feedbLF , 12000, 20, 20000, 0.001); feedbHF = hslider( feedbHF , 60, 20, 20000, 0.001); CrossFeedb = hslider( CrossFeedb[BELA: ANALOG_4] , 0.0, 0., 1, 0.001):si.smoo; feedback = hslider( feedback[BELA: ANALOG_5] , 0.0, 0., 1, 0.001):si.smoo; pitchL = hslider( shiftL[BELA: ANALOG_6] , 0,-12,12,0.001):si.smoo; pitchR = hslider( shiftR[BELA: ANALOG_7] , 0,-12,12,0.001):si.smoo; routeur(a,b,c,d) = ((a*CrossFeedb):fi.lowpass(2,crossLF):fi.highpass(2,crossHF))+((b*feedback):fi.lowpass(2,feedbLF):fi.highpass(2,feedbHF))+c, ((b*CrossFeedb):fi.lowpass(2,crossLF):fi.highpass(2,crossHF))+((a*feedback):fi.lowpass(2,feedbLF):fi.highpass(2,feedbHF))+d; process = (de.sdelay(65536, 512,preDelL),de.sdelay(65536, 512,preDelR)):(routeur : de.sdelay(65536, 512,delL) , de.sdelay(65536, 512,delR))~(ef.transpose(512, 256, pitchL) , ef.transpose(512, 256, pitchR)); Try it Yourself >> FMSynth2_Analog import( all.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple FM synthesizer. /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : Modulator frequency ratio // ANALOG_1 : Attack // ANALOG_2 : Decay/Release // ANALOG_3 : Sustain // // MIDI: // CC 1 : FM feedback on modulant oscillator. // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL, Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 1, 0, 1, 0.01); // modwheel: feedb = (gFreq-1) * (hslider( feedb[midi:ctrl 1] , 0, 0, 1, 0.001) : si.smoo); modFreqRatio = hslider( ratio[BELA: ANALOG_0] ,2,0,20,0.01) : si.smoo; // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; //=================================== Parameters Mapping ================================= //======================================================================================== // Same for volum modulation: volA = hslider( A[BELA: ANALOG_1] ,0.01,0.01,4,0.01); volDR = hslider( DR[BELA: ANALOG_2] ,0.6,0.01,8,0.01); volS = hslider( S[BELA: ANALOG_3] ,0.2,0,1,0.01); envelop = en.adsre(volA,volDR,volS,volDR,midigate); // modulator frequency modFreq = gFreq * modFreqRatio; // modulation index FMdepth = envelop * 1000 * midigain; // Out Amplitude vol = envelop; //============================================ DSP ======================================= //======================================================================================== FMfeedback(frq) = (+(_,frq):os.osci) ~ (* (feedb)); FMall(f) = os.osci(f+ (FMdepth*FMfeedback(f*modFreqRatio))); process = FMall(gFreq) * vol; Try it Yourself >> FMSynth2 import( all.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple FM synthesizer. // 2 oscillators and FM feedback on modulant oscillator // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // // CC 1 : FM feedback on modulant oscillator. // CC 14 : Modulator frequency ratio. // // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL, Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 1, 0, 1, 0.01); // modwheel: feedb = (gFreq-1) * (hslider( feedb[midi:ctrl 1] , 0, 0, 1, 0.001) : si.smoo); modFreqRatio = hslider( ratio[midi:ctrl 14] ,2,0,20,0.01) : si.smoo; // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; //=================================== Parameters Mapping ================================= //======================================================================================== // Same for volum modulation: volA = hslider( A[midi:ctrl 73] ,0.01,0.01,4,0.01); volD = hslider( D[midi:ctrl 76] ,0.6,0.01,8,0.01); volS = hslider( S[midi:ctrl 77] ,0.2,0,1,0.01); volR = hslider( R[midi:ctrl 72] ,0.8,0.01,8,0.01); envelop = en.adsre(volA,volD,volS,volR,midigate); // modulator frequency modFreq = gFreq*modFreqRatio; // modulation index FMdepth = envelop * 1000 * midigain; // Out Amplitude vol = envelop; //============================================ DSP ======================================= //======================================================================================== FMfeedback(frq) = (+(_,frq):os.osci ) ~ (* (feedb)); FMall(f) = os.osci(f+(FMdepth*FMfeedback(f*modFreqRatio))); process = FMall(gFreq) * vol; Try it Yourself >> FMSynth2_FX_Analog import( all.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple FM synthesizer. // 2 oscillators and FM feedback on modulant oscillator // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : Modulator frequency ratio // ANALOG_1 : Attack // ANALOG_2 : Decay/Release // ANALOG_3 : Sustain // // MIDI: // CC 1 : FM feedback on modulant oscillator. // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL, Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 1, 0, 1, 0.01); // modwheel: feedb = (gFreq-1) * (hslider( feedb[midi:ctrl 1] , 0, 0, 1, 0.001) : si.smoo); modFreqRatio = hslider( ratio[BELA: ANALOG_0] ,2,0,20,0.01) : si.smoo; // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; //=================================== Parameters Mapping ================================= //======================================================================================== // Same for volum modulation: volA = hslider( A[BELA: ANALOG_1] ,0.01,0.01,4,0.01); volDR = hslider( DR[BELA: ANALOG_2] ,0.6,0.01,8,0.01); volS = hslider( S[BELA: ANALOG_3] ,0.2,0,1,0.01); envelop = en.adsre(volA,volDR,volS,volDR,midigate); // modulator frequency modFreq = gFreq * modFreqRatio; // modulation index FMdepth = envelop * 1000 * midigain; // Out Amplitude vol = envelop; //============================================ DSP ======================================= //======================================================================================== FMfeedback(frq) = (+(_,frq):os.osci) ~ (* (feedb)); FMall(f) = os.osci(f+ (FMdepth*FMfeedback(f*modFreqRatio))); //#################################################################################################// //##################################### EFFECT SECTION ############################################// //#################################################################################################// // // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // // This version use ANALOG IN to controle some of the parameters. // Other parameters continue to be available by MIDI or OSC. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_4 : Distortion Drive // ANALOG_5 : Flanger Dry/Wet // ANALOG_6 : Reverberation Dry/Wet // ANALOG_7 : Reverberation Room size // // MIDI: // CC 7 : Volume // CC 10 : Pan // // CC 13 : Flanger Delay // CC 13 : Flanger Delay // CC 94 : Flanger Feedback // // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: volFX = hslider( volume[midi:ctrl 7] ,1,0,1,0.001); // Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider( drive[BELA: ANALOG_4] ,0.3,0,1,0.001); // Flanger curdel = hslider( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider( dryWetFlang[BELA: ANALOG_5] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[BELA: ANALOG_7] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[BELA: ANALOG_6] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; process = FMall(gFreq) * vol; Try it Yourself >> FMSynth2_FX import( all.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple FM synthesizer. // 2 oscillators and FM feedback on modulant oscillator // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // // CC 1 : FM feedback on modulant oscillator. // CC 14 : Modulator frequency ratio. // // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL, Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 1, 0, 1, 0.01); // modwheel: feedb = (gFreq-1) * (hslider( feedb[midi:ctrl 1] , 0, 0, 1, 0.001) : si.smoo); modFreqRatio = hslider( ratio[midi:ctrl 14] ,2,0,20,0.01) : si.smoo; // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; //=================================== Parameters Mapping ================================= //======================================================================================== // Same for volum modulation: volA = hslider( A[midi:ctrl 73] ,0.01,0.01,4,0.01); volD = hslider( D[midi:ctrl 76] ,0.6,0.01,8,0.01); volS = hslider( S[midi:ctrl 77] ,0.2,0,1,0.01); volR = hslider( R[midi:ctrl 72] ,0.8,0.01,8,0.01); envelop = en.adsre(volA,volD,volS,volR,midigate); // modulator frequency modFreq = gFreq*modFreqRatio; // modulation index FMdepth = envelop * 1000 * midigain; // Out Amplitude vol = envelop; //============================================ DSP ======================================= //======================================================================================== FMfeedback(frq) = ( +(_,frq):os.osci ) ~ (* (feedb)); FMall(f) = os.osci(f+ (FMdepth*FMfeedback(f*modFreqRatio))); //#################################################################################################// //##################################### EFFECT SECTION ############################################// //#################################################################################################// // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // (All are available by OSC) // // CC 7 : Volume // CC 10 : Pan // // CC 92 : Distortion Drive // // CC 13 : Flanger Delay // CC 93 : Flanger Dry/Wet // CC 94 : Flanger Feedback // // CC 12 : Reverberation Room size // CC 91 : Reverberation Dry/Wet // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: volFX = hslider( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider( drive[midi:ctrl 92] ,0.3,0,1,0.001); // Flanger curdel = hslider( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider( dryWetFlang[midi:ctrl 93] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[midi:ctrl 12] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[midi:ctrl 91] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; process = FMall(gFreq) * vol; Try it Yourself >> FXChaine2 import( stdfaust.lib ); ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // // A complete Stereo FX chain with: // CHORUS // PHASER // DELAY // REVERB // // Designed to use the Analog Input for parameters controls. // // CONTROLES //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // // ANALOG IN: // ANALOG 0 : Chorus Depth // ANALOG 1 : Chorus Delay // ANALOG 2 : Phaser Dry/Wet // ANALOG 3 : Phaser Frequency ratio // ANALOG 4 : Delay Dry/Wet // ANALOG 5 : Delay Time // ANALOG 6 : Reverberation Dry/Wet // ANALOG 7 : Reverberation Room size // // Available by OSC : (see BELA console for precise adress) // Rate : Chorus LFO modulation rate (Hz) // Deviation : Chorus delay time deviation. // // InvertSum : Phaser inversion of phaser in sum. (On/Off) // VibratoMode : Phaser vibrato Mode. (On/Off) // Speed : Phaser LFO frequency // NotchDepth : Phaser LFO depth // Feedback : Phaser Feedback // NotchWidth : Phaser Notch Width // MinNotch1 : Phaser Minimal frequency // MaxNotch1 : Phaser Maximal Frequency // // Damp : Reverberation Damp // Stereo : Reverberation Stereo Width // ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// process = chorus_stereo(dmax,curdel,rate,sigma,do2,voices) : phaserSt : xdelay : reverb; // CHORUS (from SAM demo lib) ////////////////////////////////////////////////////////////////////////////////////////////////////////// voices = 8; // MUST BE EVEN pi = 4.0*atan(1.0); periodic = 1; dmax = 8192; curdel = dmax * vslider( Delay[BELA: ANALOG_1] , 0.5, 0, 1, 1) : si.smooth(0.999); rateMax = 7.0; // Hz rateMin = 0.01; rateT60 = 0.15661; rate = vslider( Rate , 0.5, rateMin, rateMax, 0.0001): si.smooth(ba.tau2pole(rateT60/6.91)); depth = vslider( Depth [BELA: ANALOG_0] , 0.5, 0, 1, 0.001) : si.smooth(ba.tau2pole(depthT60/6.91)); // (dept = dry/wet) depthT60 = 0.15661; delayPerVoice = 0.5*curdel/voices; sigma = delayPerVoice * vslider( Deviation ,0.5,0,1,0.001) : si.smooth(0.999); do2 = depth; // use when depth=1 means multivibrato effect (no original = all are modulated) chorus_stereo(dmax,curdel,rate,sigma,do2,voices) = _,_ : *(1-do2),*(1-do2),(*(do2),*(do2) : par(i,voices,voice(i)): _,_) : ro.interleave(2,2) : +,+; voice(i) = de.fdelay(dmax,min(dmax,del(i)))/(i+1) with { angle(i) = 2*pi*(i/2)/voices + (i%2)*pi/2; voice(i) = de.fdelay(dmax,min(dmax,del(i))) * cos(angle(i)); del(i) = curdel*(i+1)/voices + dev(i); rates(i) = rate/float(i+1); dev(i) = sigma * os.oscp(rates(i),i*2*pi/voices); }; // PHASER (from demo lib.) ///////////////////////////////////////////////////////////////////////////////////////////////////////////// phaserSt = _,_ : _, _, phaser2_stereo : dry_wetST(dwPhaz) with { invert = checkbox( InvertSum ); vibr = checkbox( VibratoMode ); // In this mode you can hear any Doppler phaser2_stereo = pf.phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,mdepth,fb,invert); Notches = 4; // Compile-time parameter: 2 is typical for analog phaser stomp-boxes speed = hslider( Speed , 0.5, 0, 10, 0.001); depth = hslider( NotchDepth , 1, 0, 1, 0.001); fb = hslider( Feedback , 0.7, -0.999, 0.999, 0.001); width = hslider( NotchWidth ,1000, 10, 5000, 1); frqmin = hslider( MinNotch1 ,100, 20, 5000, 1); frqmax = hslider( MaxNotch1 ,800, 20, 10000, 1) : max(frqmin); fratio = hslider( NotchFreqRatio[BELA: ANALOG_3] ,1.5, 1.1, 4, 0.001); dwPhaz = vslider( dryWetPhaser[BELA: ANALOG_2] , 0.5, 0, 1, 0.001); mdepth = select2(vibr,depth,2); // Improve ease of use }; // DELAY (with feedback and crossfeeback) ////////////////////////////////////////////////////////////////////////////////////////////// delay = ba.sec2samp(hslider( delay[BELA: ANALOG_5] , 1,0,2,0.001)); preDelL = delay/2; delL = delay; delR = delay; crossLF = 1200; CrossFeedb = 0.6; dwDel = vslider( dryWetDelay[BELA: ANALOG_4] , 0.5, 0, 1, 0.001); routeur(a,b,c,d) = ((a*CrossFeedb):fi.lowpass(2,crossLF))+c, ((b*CrossFeedb):fi.lowpass(2,crossLF))+d; xdelay = _,_ : _,_,((de.sdelay(65536, 512,preDelL),_): (routeur : de.sdelay(65536, 512,delL) ,de.sdelay(65536, 512,delR) ) ~ (_,_)) : dry_wetST(dwDel); // REVERB (from freeverb_demo) ///////////////////////////////////////////////////////////////////////////////////////////////////////// reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[BELA: ANALOG_7] , 0.5, 0, 1, 0.001)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo ,0.5,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[BELA: ANALOG_6] , 0.2, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wetST(dw,x1,x2,y1,y2) = (wet*y1 + dry*x1),(wet*y2 + dry*x2) with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; Try it Yourself >> GrainGenerator /////////////////////////////////////////////////////////////////////////////////////////////////// // // Grain Generator. // Another granular synthesis example. // This one is not finished, but ready for more features and improvements... // /////////////////////////////////////////////////////////////////////////////////////////////////// // // ANALOG IN: // ANALOG 0 : Population: 0=almost nothing. 1=Full grain // ANALOG 1 : Depth of each grin, in ms. // ANALOG 2 : Position in the table = delay // ANALOG 3 : Speed = pitch change of the grains // ANALOG 4 : Feedback // /////////////////////////////////////////////////////////////////////////////////////////////////// import( all.lib ); // FOR 4 grains - MONO // UI ////////////////////////////////////////// popul = 1 - hslider( population[BELA: ANALOG_0] , 1, 0, 1, 0.001); // Coef 1= maximum; 0 = almost nothing (0.95) taille = hslider( taille[BELA: ANALOG_1] , 100, 4, 200, 0.001 ); // Size in millisecondes decal = 1 - hslider( decal[BELA: ANALOG_2] ,0,0,1,0.001); // read position compared to table srite position speed = hslider( speed[BELA: ANALOG_3] , 1, 0.125, 4, 0.001); feedback = hslider( feedback[BELA: ANALOG_4] ,0,0,2,0.001); freq = 1000/taille; tmpTaille = taille*ma.SR/ 1000; clocSize = int(tmpTaille + (tmpTaille*popul*10)); // duration between 2 clicks // CLK GENERAL ///////////////////////////////// // 4 clicks vers 4 generateurs de grains. // (idem clk freq/4 et un compteur...) detect1(x) = select2 (x 10, 0, 1); detect2(x) = select2 (x clocSize*1/3, 0, 1) : select2 (x (clocSize*1/3)+10, 0, _); detect3(x) = select2 (x clocSize*2/3, 0, 1) : select2 (x (clocSize*2/3)+10, 0, _); detect4(x) = select2 (x clocSize-10, 0, 1); cloc = (%(_,clocSize))~(+(1)) : (detect1: trig),(detect2: trig),(detect3: trig),(detect4: trig); // SIGNAUX Ctrls Player //////////////////////// trig = _ :_,mem: ; envelop = *(2*PI):+(PI):cos:*(0.5):+(0.5); rampe(f, t) = delta : (+ : select2(t,_,delta 0) : max(0)) ~ _ : raz with { raz(x) = select2 (x 1, x, 0); delta = sh(f,t)/ma.SR; sh(x,t) = ba.sAndH(t,x); }; rampe2(speed, t) = delta : (+ : select2(t,_,delta 0) : max(0)) ~ _ with { delta = sh(speed,t); sh(x,t) = ba.sAndH(t,x); }; // RWTable ////////////////////////////////////// unGrain(input, clk) = (linrwtable( wf , rindex) : *(0.2 * EnvGrain)) with { SR = 44100; buffer_sec = 1; size = int(SR * buffer_sec); init = 0.; EnvGrain = clk : (rampe(freq) : envelop); windex = (%(_,size) ) ~ ( +(1) ); posTabl = int(ba.sAndH(clk, windex)); rindex = %(int(rampe2(speed, clk)) + posTabl + int(size * decal), size); wf = size, init, int(windex), input; }; // LINEAR_INTERPOLATION_RWTABLE ////////////////////////////////// // read rwtable with linear interpolation // wf : waveform to read ( wf is defined by (size_buffer,init, windex, input )) // x : position to read (0 = x size(wf)) and float // nota: rwtable(size, init, windex, input, rindex) linrwtable(wf,x) = linterpolation(y0,y1,d) with { x0 = int(x); // x1 = int(x+1); // d = x-x0; y0 = rwtable(wf,x0); // y1 = rwtable(wf,x1); // linterpolation(v0,v1,c) = v0*(1-c)+v1*c; }; // FINALISATION ///////////////////////////////////////////////////////////////////////////////////// routeur (a, b, c, d, e) = a, b, a, c, a, d, a, e; processus = _ , cloc : routeur : (unGrain, unGrain, unGrain, unGrain) : fi.dcblockerat(20); process = _,_: ((+(_,_) :processus) ~(*(feedback))),((+(_,_) :processus) ~(*(feedback))); Try it Yourself >> granulator // FROM FAUST DEMO // Designed to use the Analog Input for parameters contr\u00f4les. // /////////////////////////////////////////////////////////////////////////////////////////////////// // // ANALOG IN: // ANALOG 0 : Grain Size // ANALOG 1 : Speed // ANALOG 2 : Probability // (others analog inputs are not used) // /////////////////////////////////////////////////////////////////////////////////////////////////// process = vgroup( Granulator , environment { declare name Granulator ; declare author Adapted from sfIter by Christophe Lebreton ; /* =========== DESCRIPTION ============= - The granulator takes very small parts of a sound, called GRAINS, and plays them at a varying speed - Front = Medium size grains - Back = short grains - Left Slow rhythm - Right = Fast rhythm - Bottom = Regular occurrences - Head = Irregular occurrences */ import( stdfaust.lib ); process = hgroup( Granulator , *(excitation : ampf)); excitation = noiseburst(gate,P) * (gain); ampf = an.amp_follower_ud(duree_env,duree_env); //----------------------- NOISEBURST ------------------------- noiseburst(gate,P) = no.noise : *(gate : trigger(P)) with { upfront(x) = (x-x') 0; decay(n,x) = x - (x 0)/n; release(n) = + ~ decay(n); trigger(n) = upfront : release(n) : (0.0); }; //------------------------------------------------------------- P = freq; // fundamental period in samples freq = hslider( [1]GrainSize[BELA: ANALOG_0] , 200,5,2205,1); // la frequence donne la largeur de bande extraite du bruit blanc Pmax = 4096; // maximum P (for de.delay-line allocation) // PHASOR_BIN ////////////////////////////// phasor_bin (init) = (+(float(speed)/float(ma.SR)) : fmod(_,1.0)) ~ *(init); gate = phasor_bin(1) :-(0.001):pulsar; gain = 1; // PULSAR ////////////////////////////// //Le pulsar permet de creer une 'pulsation' plus ou moins aleatoire (proba). pulsar = _ :((_ (ratio_env)):@(100))*(proba (_,abs(no.noise):ba.latch)); speed = hslider ( [2]Speed[BELA: ANALOG_1] , 10,1,20,0.0001):fi.lowpass(1,1); ratio_env = 0.5; fade = (0.5); // min 0 pour eviter division par 0 proba = hslider ( [3]Probability[BELA: ANALOG_2] , 70,50,100,1) * (0.01):fi.lowpass(1,1); duree_env = 1/(speed: / (ratio_env*(0.25)*fade)); }.process); Try it Yourself >> repeater // REPEATER: // Freeze and repeat a small part of input signal 'n' time' // /////////////////////////////////////////////////////////////////////////////////////////////////// // // ANALOG IN: // ANALOG 0 : Duration (ms) between 2 repeat series (500 to 2000 ms) // ANALOG 1 : Duration of one repeat (2 to 200 ms) // ANALOG 2 : Number of repeat // /////////////////////////////////////////////////////////////////////////////////////////////////// import( all.lib ); process = _, _ , (pathClock : compteurUpReset2(nbRepet): rampePlayer, _) : routageIO : rec_play_table , rec_play_table; /////////////////////////////////////////////////////////////////////////////////////////////////// // General loop duration MasterTaille =hslider( MasterTaille[BELA: ANALOG_0] , 500, 200, 2000,0.01); MasterClocSize = int(MasterTaille*ma.SR/ 1000); // Depth of repeat fragments taille =hslider( taille[BELA: ANALOG_1] , 50, 2, 200,0.01); clocSize = int(taille*ma.SR/ 1000); // Number of repeat fragments nbRepet = int (hslider( nbRepet[BELA: ANALOG_2] ,4,1,16,1) ); trig = _ :_,mem: ; routageIO (a, b, c, d) = a, c, d, b, c, d; rec_play_table(input, inReadIndex, reset) = ( rwtable( wf , rindex):fi.dcblockerat(20) ) with { SR = 44100; buffer_sec = 2; size = int(SR * buffer_sec); init = 0.; windex = (%(_,size))~(+(1):*(1-reset)); rindex = (%( int(inReadIndex),size)); wf = size, init, int(windex), input; }; MasterClock = (%(_,MasterClocSize))~(+(1)) : detect with { detect(x) = select2 (x 100, 0, 1); }; SlaveClock(reset) = (%(_,clocSize))~(+(1):*(1-reset)); detect1(x) = select2 (x clocSize/2, 0, 1); pathClock = MasterClock : trig, _ : SlaveClock, _ : detect1, _ ; compteurUpReset2(nb, in, reset) = ((in:trig), reset : (routage : memo2)~_), reset with { memo2(a, b) = (ba.if(b 0.5, 0, _) )~(+(a)); compare(value) = ba.if(value nb, 1, 0); // :trig; routage(d,e,f) = e , (f, compare(d) : RSLatch : +(f)); }; RSLatch(R, S) = latch(S,R) with { trig = _ :_,mem: ; latch(S,R) = _~( ba.if(R 0.5, 0, _) : ba.if(S 0.5,1,_) ); }; rampePlayer(reset) = rampe with { rst = reset : trig; rampe = _~(+(1):*(1-rst)); toZero = _ : ba.if(reset 0.5,0,_); }; Try it Yourself >> simpleFX_Analog import( stdfaust.lib ); // /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // // This version use ANALOG IN to controle some of the parameters. // Other parameters continue to be available by MIDI or OSC. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_4 : Distortion Drive // ANALOG_5 : Flanger Dry/Wet // ANALOG_6 : Reverberation Dry/Wet // ANALOG_7 : Reverberation Room size // // MIDI: // CC 7 : Volume // CC 10 : Pan // // CC 13 : Flanger Delay // CC 13 : Flanger Delay // CC 94 : Flanger Feedback // // CC 95 : Reverberation Damp // CC 90: Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: vol = hslider( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider ( drive[BELA: ANALOG_4] ,0.3,0,1,0.001); // Flanger curdel = hslider( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider( dryWetFlang[BELA: ANALOG_5] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[BELA: ANALOG_7] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[BELA: ANALOG_6] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effets = _ *(vol) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; process = effets; Try it Yourself >> simpleFX import( stdfaust.lib ); // /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // (All are available by OSC) // // CC 7 : Volume // CC 10 : Pan // // CC 92 : Distortion Drive // // CC 13 : Flanger Delay // CC 93 : Flanger Dry/Wet // CC 94 : Flanger Feedback // // CC 12 : Reverberation Room size // CC 91 : Reverberation Dry/Wet // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: vol = hslider ( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider ( drive[midi:ctrl 92] ,0.3,0,1,0.001); // Flanger curdel = hslider ( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider ( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider ( dryWetFlang[midi:ctrl 93] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Panoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[midi:ctrl 12] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[midi:ctrl 91] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effets = _ *(vol) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; process = effets; Try it Yourself >> simpleSynth_Analog import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // A very simple subtractive synthesizer with 1 VCO 1 VCF. // The VCO Waveform is variable between Saw and Square // The frequency is modulated by an LFO // The envelope control volum and filter frequency // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : waveform (Saw to square) // ANALOG_1 : Filter Cutoff frequency // ANALOG_2 : Filter resonance (Q) // ANALOG_3 : Filter Envelope Modulation // // MIDI: // CC 79 : Filter keyboard tracking (0 to X2, default 1) // // Envelope // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // // CC 78 : LFO frequency (0.001Hz to 10Hz) // CC 1 : LFO Amplitude (Modulation) // /////////////////////////////////////////////////////////////////////////////////////////////////// // // HUI ////////////////////////////////////////////////// // Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 0.5, 0.01);// MIDI KEYBOARD // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); // VCO wfFade = hslider( waveform[BELA: ANALOG_0] ,0.5,0,1,0.001):si.smoo; // VCF res = hslider( resonnance[BELA: ANALOG_2] ,0.5,0,1,0.001):si.smoo; fr = hslider( fc[BELA: ANALOG_1] , 10, 15, 12000, 0.001):si.smoo; track = hslider( tracking[midi:ctrl 79] , 1, 0, 2, 0.001); envMod = hslider( envMod[BELA: ANALOG_3] ,50,0,100,0.01):si.smoo; // ENV att = 0.01 * (hslider ( attack[midi:ctrl 73] ,0.1,0.1,400,0.001)); dec = 0.01 * (hslider ( decay[midi:ctrl 76] ,60,0.1,400,0.001)); sust = hslider ( sustain[midi:ctrl 77] ,0.2,0,1,0.001); rel = 0.01 * (hslider ( release[midi:ctrl 72] ,100,0.1,400,0.001)); // LFO lfoFreq = hslider ( lfoFreq[midi:ctrl 78] ,6,0.001,10,0.001):si.smoo; modwheel = hslider ( modwheel[midi:ctrl 1] ,0,0,0.5,0.001):si.smoo; // PROCESS ///////////////////////////////////////////// allfreq = (midifreq * pitchwheel) + LFO; // VCF cutoff = ((allfreq * track) + fr + (envMod * midigain * env)) : min(ma.SR/8); // VCO oscillo(f) = (os.sawtooth(f)*(1-wfFade))+(os.square(f)*wfFade); // VCA volume = midigain * env; // Enveloppe env = en.adsre(att,dec,sust,rel,midigate); // LFO LFO = os.lf_triangle(lfoFreq)*modwheel*10; // SYNTH //////////////////////////////////////////////// synth = (oscillo(allfreq) :ve.moog_vcf(res,cutoff)) * volume; // PROCESS ///////////////////////////////////////////// process = synth; Try it Yourself >> simpleSynth import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // A very simple subtractive synthesizer with 1 VCO 1 VCF. // The VCO Waveform is variable between Saw and Square // The frequency is modulated by an LFO // The envelope control volum and filter frequency // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // // CC 70 : waveform (Saw to square) // CC 71 : Filter resonance (Q) // CC 74 : Filter Cutoff frequency // CC 79 : Filter keyboard tracking (0 to X2, default 1) // CC 75 : Filter Envelope Modulation // // Envelope // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // // CC 78 : LFO frequency (0.001Hz to 10Hz) // CC 1 : LFO Amplitude (Modulation) // /////////////////////////////////////////////////////////////////////////////////////////////////// // // HUI ////////////////////////////////////////////////// // Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 0.5, 0.01);// MIDI KEYBOARD // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); // VCO wfFade= hslider( waveform[midi:ctrl 70] ,0.5,0,1,0.001):si.smoo; // VCF res = hslider( resonnance[midi:ctrl 71] ,0.5,0,1,0.001):si.smoo; fr = hslider( fc[midi:ctrl 74] , 10, 15, 12000, 0.001):si.smoo; track = hslider( tracking[midi:ctrl 79] , 1, 0, 2, 0.001); envMod = hslider( envMod[midi:ctrl 75] ,50,0,100,0.01):si.smoo; // ENV att = 0.01 * (hslider ( attack[midi:ctrl 73] ,0.1,0.1,400,0.001)); dec = 0.01 * (hslider ( decay[midi:ctrl 76] ,60,0.1,400,0.001)); sust = hslider ( sustain[midi:ctrl 77] ,0.1,0,1,0.001); rel = 0.01 * (hslider ( release[midi:ctrl 72] ,100,0.1,400,0.001)); // LFO lfoFreq = hslider( lfoFreq[midi:ctrl 78] ,6,0.001,10,0.001):si.smoo; modwheel = hslider( modwheel[midi:ctrl 1] ,0,0,0.5,0.001):si.smoo; // PROCESS ///////////////////////////////////////////// allfreq = (midifreq * pitchwheel) + LFO; // VCF cutoff = ((allfreq * track) + fr + (envMod * midigain * env)) : min(ma.SR/8); // VCO oscillo(f) = (os.sawtooth(f)*(1-wfFade))+(os.square(f)*wfFade); // VCA volume = midigain * env; // Enveloppe env = en.adsre(att,dec,sust,rel,midigate); // LFO LFO = os.lf_triangle(lfoFreq)*modwheel*10; // SYNTH //////////////////////////////////////////////// synth = (oscillo(allfreq) :ve.moog_vcf(res,cutoff)) * volume; // PROCESS ///////////////////////////////////////////// process = synth; Try it Yourself >> simpleSynth_FX_Analog import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // A very simple subtractive synthesizer with 1 VCO 1 VCF. // The VCO Waveform is variable between Saw and Square // The frequency is modulated by an LFO // The envelope control volum and filter frequency // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : waveform (Saw to square) // ANALOG_1 : Filter Cutoff frequency // ANALOG_2 : Filter resonance (Q) // ANALOG_3 : Filter Envelope Modulation // // MIDI: // CC 79 : Filter keyboard tracking (0 to X2, default 1) // // Envelope // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // // CC 78 : LFO frequency (0.001Hz to 10Hz) // CC 1 : LFO Amplitude (Modulation) // /////////////////////////////////////////////////////////////////////////////////////////////////// // // HUI ////////////////////////////////////////////////// // Keyboard midigate = button( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 0.5, 0.01);// MIDI KEYBOARD // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); // VCO wfFade = hslider( waveform[BELA: ANALOG_0] ,0.5,0,1,0.001):si.smoo; // VCF res = hslider( resonnance[BELA: ANALOG_2] ,0.5,0,1,0.001):si.smoo; fr = hslider( fc[BELA: ANALOG_1] , 10, 15, 12000, 0.001):si.smoo; track = hslider( tracking[midi:ctrl 79] , 1, 0, 2, 0.001); envMod = hslider( envMod[BELA: ANALOG_3] ,50,0,100,0.01):si.smoo; // ENV att = 0.01 * (hslider ( attack[midi:ctrl 73] ,0.1,0.1,400,0.001)); dec = 0.01 * (hslider ( decay[midi:ctrl 76] ,60,0.1,400,0.001)); sust = hslider ( sustain[midi:ctrl 77] ,0.2,0,1,0.001); rel = 0.01 * (hslider ( release[midi:ctrl 72] ,100,0.1,400,0.001)); // LFO lfoFreq = hslider( lfoFreq[midi:ctrl 78] ,6,0.001,10,0.001):si.smoo; modwheel = hslider( modwheel[midi:ctrl 1] ,0,0,0.5,0.001):si.smoo; // PROCESS ///////////////////////////////////////////// allfreq = (midifreq * pitchwheel) + LFO; // VCF cutoff = ((allfreq * track) + fr + (envMod * midigain * env)) : min(ma.SR/8); // VCO oscillo(f) = (os.sawtooth(f)*(1-wfFade))+(os.square(f)*wfFade); // VCA volume = midigain * env; // Enveloppe env = en.adsre(att,dec,sust,rel,midigate); // LFO LFO = os.lf_triangle(lfoFreq)*modwheel*10; // SYNTH //////////////////////////////////////////////// synth = (oscillo(allfreq) :ve.moog_vcf(res,cutoff)) * volume; //#################################################################################################// //##################################### EFFECT SECTION ############################################// //#################################################################################################// // // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // // This version use ANALOG IN to controle some of the parameters. // Other parameters continue to be available by MIDI or OSC. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_4 : Distortion Drive // ANALOG_5 : Flanger Dry/Wet // ANALOG_6 : Reverberation Dry/Wet // ANALOG_7 : Reverberation Room size // // MIDI: // CC 7 : Volume // CC 10 : Pan // // CC 13 : Flanger Delay // CC 13 : Flanger Delay // CC 94 : Flanger Feedback // // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: volFX = hslider ( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider ( drive[BELA: ANALOG_4] ,0.3,0,1,0.001); // Flanger curdel = hslider ( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider ( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider ( dryWetFlang[BELA: ANALOG_5] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[BELA: ANALOG_7] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[BELA: ANALOG_6] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; // PROCESS ///////////////////////////////////////////// process = synth; Try it Yourself >> simpleSynth_FX import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // A very simple subtractive synthesizer with 1 VCO 1 VCF. // The VCO Waveform is variable between Saw and Square // The frequency is modulated by an LFO // The envelope control volum and filter frequency // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // // CC 70 : waveform (Saw to square) // CC 71 : Filter resonance (Q) // CC 74 : Filter Cutoff frequency // CC 79 : Filter keyboard tracking (0 to X2, default 1) // CC 75 : Filter Envelope Modulation // // Envelope // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // // CC 78 : LFO frequency (0.001Hz to 10Hz) // CC 1 : LFO Amplitude (Modulation) // /////////////////////////////////////////////////////////////////////////////////////////////////// // // HUI ////////////////////////////////////////////////// // Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 0.5, 0.01);// MIDI KEYBOARD // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); // VCO wfFade = hslider( waveform[midi:ctrl 70] ,0.5,0,1,0.001):si.smoo; // VCF res = hslider( resonnance[midi:ctrl 71] ,0.5,0,1,0.001):si.smoo; fr = hslider( fc[midi:ctrl 74] , 10, 15, 12000, 0.001):si.smoo; track = hslider( tracking[midi:ctrl 79] , 1, 0, 2, 0.001); envMod = hslider( envMod[midi:ctrl 75] ,50,0,100,0.01):si.smoo; // ENV att = 0.01 * (hslider ( attack[midi:ctrl 73] ,0.1,0.1,400,0.001)); dec = 0.01 * (hslider ( decay[midi:ctrl 76] ,60,0.1,400,0.001)); sust = hslider ( sustain[midi:ctrl 77] ,0.1,0,1,0.001); rel = 0.01 * (hslider ( release[midi:ctrl 72] ,100,0.1,400,0.001)); // LFO lfoFreq = hslider ( lfoFreq[midi:ctrl 78] ,6,0.001,10,0.001):si.smoo; modwheel= hslider ( modwheel[midi:ctrl 1] ,0,0,0.5,0.001):si.smoo; // PROCESS ///////////////////////////////////////////// allfreq = (midifreq * pitchwheel) + LFO; // VCF cutoff= ((allfreq * track) + fr + (envMod * midigain * env)) : min(ma.SR/8); // VCO oscillo(f) = (os.sawtooth(f)*(1-wfFade))+(os.square(f)*wfFade); // VCA volume = midigain * env; // Enveloppe env = en.adsre(att,dec,sust,rel,midigate); // LFO LFO = os.lf_triangle(lfoFreq)*modwheel*10; // SYNTH //////////////////////////////////////////////// synth = (oscillo(allfreq) :ve.moog_vcf(res,cutoff)) * volume; //#################################################################################################// //##################################### EFFECT SECTION ############################################// //#################################################################################################// // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // (All are available by OSC) // // CC 7 : Volume // CC 10 : Pan // // CC 92 : Distortion Drive // // CC 13 : Flanger Delay // CC 93 : Flanger Dry/Wet // CC 94 : Flanger Feedback // // CC 12 : Reverberation Room size // CC 91 : Reverberation Dry/Wet // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: volFX = hslider ( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider ( drive[midi:ctrl 92] ,0.3,0,1,0.001); // Flanger curdel = hslider ( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider ( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider ( dryWetFlang[midi:ctrl 93] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[midi:ctrl 12] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[midi:ctrl 91] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; // PROCESS ///////////////////////////////////////////// process = synth; Try it Yourself >> WaveSynth_Analog import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple demo of wavetable synthesis. A LFO modulate the interpolation between 4 tables. // It's possible to add more tables step. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : Wave travelling // ANALOG_1 : LFO Frequency // ANALOG_2 : LFO Depth (wave travel modulation) // ANALOG_3 : Release // // MIDI: // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 1, 0.01); waveTravel = hslider( waveTravel[BELA: ANALOG_0] ,0,0,1,0.01); // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; // LFO lfoDepth = hslider( lfoDepth[BELA: ANALOG_2] ,0,0.,1,0.001):si.smoo; lfoFreq = hslider( lfoFreq[BELA: ANALOG_1] ,0.1,0.01,10,0.001):si.smoo; moov = ((os.lf_trianglepos(lfoFreq) * lfoDepth) + waveTravel) : min(1) : max(0); volA = hslider( A[midi:ctrl 73] ,0.01,0.01,4,0.01); volD = hslider( D[midi:ctrl 76] ,0.6,0.01,8,0.01); volS = hslider( S[midi:ctrl 77] ,0.2,0,1,0.01); volR = hslider( R[BELA: ANALOG_3] ,0.8,0.01,8,0.01); envelop = en.adsre(volA,volD,volS,volR,midigate); // Out Amplitude vol = envelop * midigain; WF(tablesize, rang) = abs((fmod ((1+(float(ba.time)*rang)/float(tablesize)), 4.0 ))-2) -1.; // 4 WF maxi with this version: scanner(nb, position) = -(_,soustraction) : *(_,coef) : cos : max(0) with { coef = 3.14159 * ((nb-1)*0.5); soustraction = select2( position 0, 0, (position/(nb-1)) ); }; wfosc(freq) = (rdtable(tablesize, wt1, faze)*(moov : scanner(4,0)))+(rdtable(tablesize, wt2, faze)*(moov : scanner(4,1))) + (rdtable(tablesize, wt3, faze)*(moov : scanner(4,2)))+(rdtable(tablesize, wt4, faze)*(moov : scanner(4,3))) with { tablesize = 1024; wt1 = WF(tablesize, 16); wt2 = WF(tablesize, 8); wt3 = WF(tablesize, 6); wt4 = WF(tablesize, 4); faze = int(os.phasor(tablesize,freq)); }; process = wfosc(gFreq) * vol; Try it Yourself >> WaveSynth import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple demo of wavetable synthesis. A LFO modulate the interpolation between 4 tables. // It's possible to add more tables step. // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // // CC 1 : LFO Depth (wave travel modulation) // CC 14 : LFO Frequency // CC 70 : Wave travelling // // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 1, 0.01); waveTravel = hslider( waveTravel [midi:ctrl ] ,0,0,1,0.01); // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; // LFO lfoDepth = hslider ( lfoDepth[midi:ctrl 1] ,0,0.,1,0.001):si.smoo; lfoFreq = hslider ( lfoFreq[midi:ctrl 14] ,0.1,0.01,10,0.001):si.smoo; moov = ((os.lf_trianglepos(lfoFreq) * lfoDepth) + waveTravel) : min(1) : max(0); volA = hslider( A[midi:ctrl 73] ,0.01,0.01,4,0.01); volD = hslider( D[midi:ctrl 76] ,0.6,0.01,8,0.01); volS = hslider( S[midi:ctrl 77] ,0.2,0,1,0.01); volR = hslider( R[midi:ctrl 72] ,0.8,0.01,8,0.01); envelop = en.adsre(volA,volD,volS,volR,midigate); // Out Amplitude vol = envelop * midigain ; WF(tablesize, rang) = abs((fmod ((1+(float(ba.time)*rang)/float(tablesize)), 4.0 ))-2) -1.; // 4 WF maxi with this version: scanner(nb, position) = -(_,soustraction) : *(_,coef) : cos : max(0) with{ coef = 3.14159 * ((nb-1)*0.5); soustraction = select2( position 0, 0, (position/(nb-1)) ); }; wfosc(freq) = (rdtable(tablesize, wt1, faze)*(moov : scanner(4,0)))+(rdtable(tablesize, wt2, faze)*(moov : scanner(4,1))) + (rdtable(tablesize, wt3, faze)*(moov : scanner(4,2)))+(rdtable(tablesize, wt4, faze)*(moov : scanner(4,3))) with { tablesize = 1024; wt1 = WF(tablesize, 16); wt2 = WF(tablesize, 8); wt3 = WF(tablesize, 6); wt4 = WF(tablesize, 4); faze = int(os.phasor(tablesize,freq)); }; process = wfosc(gFreq) * vol; Try it Yourself >> WaveSynth_FX_Analog import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple demo of wavetable synthesis. A LFO modulate the interpolation between 4 tables. // It's possible to add more tables step. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : Wave travelling // ANALOG_1 : LFO Frequency // ANALOG_2 : LFO Depth (wave travel modulation) // ANALOG_3 : Release // // MIDI: // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 1, 0.01); waveTravel = hslider( waveTravel[BELA: ANALOG_0] ,0,0,1,0.01); // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; // LFO lfoDepth = hslider( lfoDepth[BELA: ANALOG_2] ,0,0.,1,0.001):si.smoo; lfoFreq = hslider( lfoFreq[BELA: ANALOG_1] ,0.1,0.01,10,0.001):si.smoo; moov = ((os.lf_trianglepos(lfoFreq) * lfoDepth) + waveTravel) : min(1) : max(0); volA = hslider( A[midi:ctrl 73] ,0.01,0.01,4,0.01); volD = hslider( D[midi:ctrl 76] ,0.6,0.01,8,0.01); volS = hslider( S[midi:ctrl 77] ,0.2,0,1,0.01); volR = hslider( R[BELA: ANALOG_3] ,0.8,0.01,8,0.01); envelop = en.adsre(volA,volD,volS,volR,midigate); // Out Amplitude vol = envelop * midigain ; WF(tablesize, rang) = abs((fmod ((1+(float(ba.time)*rang)/float(tablesize)), 4.0 ))-2) -1.; // 4 WF maxi with this version: scanner(nb, position) = -(_,soustraction) : *(_,coef) : cos : max(0) with { coef = 3.14159 * ((nb-1)*0.5); soustraction = select2( position 0, 0, (position/(nb-1)) ); }; wfosc(freq) = (rdtable(tablesize, wt1, faze)*(moov : scanner(4,0)))+(rdtable(tablesize, wt2, faze)*(moov : scanner(4,1))) + (rdtable(tablesize, wt3, faze)*(moov : scanner(4,2)))+(rdtable(tablesize, wt4, faze)*(moov : scanner(4,3))) with { tablesize = 1024; wt1 = WF(tablesize, 16); wt2 = WF(tablesize, 8); wt3 = WF(tablesize, 6); wt4 = WF(tablesize, 4); faze = int(os.phasor(tablesize,freq)); }; //#################################################################################################// //##################################### EFFECT SECTION ############################################// //#################################################################################################// // // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // // This version use ANALOG IN to controle some of the parameters. // Other parameters continue to be available by MIDI or OSC. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_4 : Distortion Drive // ANALOG_5 : Flanger Dry/Wet // ANALOG_6 : Reverberation Dry/Wet // ANALOG_7 : Reverberation Room size // // MIDI: // CC 7 : Volume // CC 10 : Pan // // CC 13 : Flanger Delay // CC 13 : Flanger Delay // CC 94 : Flanger Feedback // // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: volFX = hslider( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider ( drive[BELA: ANALOG_4] ,0.3,0,1,0.001); // Flanger curdel = hslider( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider( dryWetFlang[BELA: ANALOG_5] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[BELA: ANALOG_7] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[BELA: ANALOG_6] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; process = wfosc(gFreq) * vol; Try it Yourself >> WaveSynth_FX import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple demo of wavetable synthesis. A LFO modulate the interpolation between 4 tables. // It's possible to add more tables step. // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // // CC 1 : LFO Depth (wave travel modulation) // CC 14 : LFO Frequency // CC 70 : Wave travelling // // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 1, 0.01); waveTravel = hslider( waveTravel [midi:ctrl ] ,0,0,1,0.01); // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; // LFO lfoDepth = hslider( lfoDepth[midi:ctrl 1] ,0,0.,1,0.001):si.smoo; lfoFreq = hslider( lfoFreq[midi:ctrl 14] ,0.1,0.01,10,0.001):si.smoo; moov = ((os.lf_trianglepos(lfoFreq) * lfoDepth) + waveTravel) : min(1) : max(0); volA = hslider( A[midi:ctrl 73] ,0.01,0.01,4,0.01); volD = hslider( D[midi:ctrl 76] ,0.6,0.01,8,0.01); volS = hslider( S[midi:ctrl 77] ,0.2,0,1,0.01); volR = hslider( R[midi:ctrl 72] ,0.8,0.01,8,0.01); envelop = en.adsre(volA,volD,volS,volR,midigate); // Out Amplitude vol = envelop * midigain ; WF(tablesize, rang) = abs((fmod ((1+(float(ba.time)*rang)/float(tablesize)), 4.0 ))-2) -1.; // 4 WF maxi with this version: scanner(nb, position) = -(_,soustraction) : *(_,coef) : cos : max(0) with { coef = 3.14159 * ((nb-1)*0.5); soustraction = select2( position 0, 0, (position/(nb-1)) ); }; wfosc(freq) = (rdtable(tablesize, wt1, faze)*(moov : scanner(4,0)))+(rdtable(tablesize, wt2, faze)*(moov : scanner(4,1))) + (rdtable(tablesize, wt3, faze)*(moov : scanner(4,2)))+(rdtable(tablesize, wt4, faze)*(moov : scanner(4,3))) with { tablesize = 1024; wt1 = WF(tablesize, 16); wt2 = WF(tablesize, 8); wt3 = WF(tablesize, 6); wt4 = WF(tablesize, 4); faze = int(os.phasor(tablesize,freq)); }; //#################################################################################################// //##################################### EFFECT SECTION ############################################// //#################################################################################################// // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // (All are available by OSC) // // CC 7 : Volume // CC 10 : Pan // // CC 92 : Distortion Drive // // CC 13 : Flanger Delay // CC 93 : Flanger Dry/Wet // CC 94 : Flanger Feedback // // CC 12 : Reverberation Room size // CC 91 : Reverberation Dry/Wet // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: volFX = hslider( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider ( drive[midi:ctrl 92] ,0.3,0,1,0.001); // Flanger curdel = hslider( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider( dryWetFlang[midi:ctrl 93] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[midi:ctrl 12] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[midi:ctrl 91] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; process = wfosc(gFreq) * vol; Try it Yourself >>","title":" bela "},{"location":"examples/bela/#bela","text":"","title":"bela"},{"location":"examples/bela/#additivesynth_analog","text":"import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Additive synthesizer, must be used with OSC message to program sound. // It as 8 harmonics. Each have it's own volume envelope. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : vol0 (volum of fundamental) // ANALOG_1 : vol1 // ... // ANALOG_7 : vol7 // // OSC messages (see BELA console for precise adress) // For each harmonics (%rang indicate harmonic number, starting at 0) : // A%rang : Attack // D%rang : Decay // S%rang : Sustain // R%rang : Release // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL midigate = button( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 10, 0.01); // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; partiel(rang) = os.oscrs(gFreq*(rang+1))*volume with { // UI vol = hslider( vol%rang[BELA: ANALOG_%rang] , 1, 0, 1, 0.001); a = 0.01 * hslider( A%rang , 1, 0, 400, 0.001); d = 0.01 * hslider( D%rang , 1, 0, 400, 0.001); s = hslider( S%rang , 1, 0, 1, 0.001); r = 0.01 * hslider( R%rang , 1, 0, 800, 0.001); volume = ((en.adsr(a,d,s,r,midigate))*vol) : max (0) : min (1); }; process = par(i, 8, partiel(i)) : / (8); Try it Yourself >>","title":"AdditiveSynth_Analog"},{"location":"examples/bela/#additivesynth","text":"import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Additive synthesizer, must be used with OSC message to program sound. // It as 8 harmonics. Each have it's own volume envelope. // /////////////////////////////////////////////////////////////////////////////////////////////////// // // OSC messages (see BELA console for precise adress) // For each harmonics (%rang indicate harmonic number, starting at 0) : // vol%rang : General Volume (vol0 control the volume of the fundamental) // A%rang : Attack // D%rang : Decay // S%rang : Sustain // R%rang : Release // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL midigate = button( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 10, 0.01); // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; partiel(rang) = os.oscrs(gFreq*(rang+1))*volume with { // UI vol = hslider( vol%rang , 1, 0, 1, 0.001); a = 0.01 * hslider( A%rang , 1, 0, 400, 0.001); d = 0.01 * hslider( D%rang , 1, 0, 400, 0.001); s = hslider( S%rang , 1, 0, 1, 0.001); r = 0.01 * hslider( R%rang , 1, 0, 800, 0.001); volume = ((en.adsr(a,d,s,r,midigate))*vol) : max (0) : min (1); }; process = par(i, 8, partiel(i)) : / (8); Try it Yourself >>","title":"AdditiveSynth"},{"location":"examples/bela/#crossdelay2","text":"import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Stereo Delay with feedback and crossfeedback (L to R and R to L feedback). // And pitch shifting on feedback. // A pre-delay without feedback is added for a wider stereo effect. // // Designed to use the Analog Input for parameters controls. // /////////////////////////////////////////////////////////////////////////////////////////////////// // // ANALOG IN: // ANALOG 0 : Pre-Delay L // ANALOG 1 : Pre-Delay R // ANALOG 2 : Delay L // ANALOG 3 : Delay R // ANALOG 4 : Cross feedback // ANALOG 5 : Feedback // ANALOG 6 : Pitchshifter L // ANALOG 7 : Pitchshifter R // // Available by OSC : (see BELA console for precise adress) // Feedback filter: // crossLF : Crossfeedback Lowpass // crossHF : Crossfeedback Highpass // feedbLF : Feedback Lowpass // feedbHF : Feedback Highpass // /////////////////////////////////////////////////////////////////////////////////////////////////// preDelL = ba.sec2samp(hslider( preDelL[BELA: ANALOG_0] , 1,0,2,0.001)):si.smoo; preDelR = ba.sec2samp(hslider( preDelR[BELA: ANALOG_1] , 1,0,2,0.001)):si.smoo; delL = ba.sec2samp(hslider( delL[BELA: ANALOG_2] , 1,0,2,0.001)):si.smoo; delR = ba.sec2samp(hslider( delR[BELA: ANALOG_3] , 1,0,2,0.001)):si.smoo; crossLF = hslider( crossLF , 12000, 20, 20000, 0.001); crossHF = hslider( crossHF , 60, 20, 20000, 0.001); feedbLF = hslider( feedbLF , 12000, 20, 20000, 0.001); feedbHF = hslider( feedbHF , 60, 20, 20000, 0.001); CrossFeedb = hslider( CrossFeedb[BELA: ANALOG_4] , 0.0, 0., 1, 0.001):si.smoo; feedback = hslider( feedback[BELA: ANALOG_5] , 0.0, 0., 1, 0.001):si.smoo; pitchL = hslider( shiftL[BELA: ANALOG_6] , 0,-12,12,0.001):si.smoo; pitchR = hslider( shiftR[BELA: ANALOG_7] , 0,-12,12,0.001):si.smoo; routeur(a,b,c,d) = ((a*CrossFeedb):fi.lowpass(2,crossLF):fi.highpass(2,crossHF))+((b*feedback):fi.lowpass(2,feedbLF):fi.highpass(2,feedbHF))+c, ((b*CrossFeedb):fi.lowpass(2,crossLF):fi.highpass(2,crossHF))+((a*feedback):fi.lowpass(2,feedbLF):fi.highpass(2,feedbHF))+d; process = (de.sdelay(65536, 512,preDelL),de.sdelay(65536, 512,preDelR)):(routeur : de.sdelay(65536, 512,delL) , de.sdelay(65536, 512,delR))~(ef.transpose(512, 256, pitchL) , ef.transpose(512, 256, pitchR)); Try it Yourself >>","title":"crossDelay2"},{"location":"examples/bela/#fmsynth2_analog","text":"import( all.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple FM synthesizer. /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : Modulator frequency ratio // ANALOG_1 : Attack // ANALOG_2 : Decay/Release // ANALOG_3 : Sustain // // MIDI: // CC 1 : FM feedback on modulant oscillator. // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL, Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 1, 0, 1, 0.01); // modwheel: feedb = (gFreq-1) * (hslider( feedb[midi:ctrl 1] , 0, 0, 1, 0.001) : si.smoo); modFreqRatio = hslider( ratio[BELA: ANALOG_0] ,2,0,20,0.01) : si.smoo; // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; //=================================== Parameters Mapping ================================= //======================================================================================== // Same for volum modulation: volA = hslider( A[BELA: ANALOG_1] ,0.01,0.01,4,0.01); volDR = hslider( DR[BELA: ANALOG_2] ,0.6,0.01,8,0.01); volS = hslider( S[BELA: ANALOG_3] ,0.2,0,1,0.01); envelop = en.adsre(volA,volDR,volS,volDR,midigate); // modulator frequency modFreq = gFreq * modFreqRatio; // modulation index FMdepth = envelop * 1000 * midigain; // Out Amplitude vol = envelop; //============================================ DSP ======================================= //======================================================================================== FMfeedback(frq) = (+(_,frq):os.osci) ~ (* (feedb)); FMall(f) = os.osci(f+ (FMdepth*FMfeedback(f*modFreqRatio))); process = FMall(gFreq) * vol; Try it Yourself >>","title":"FMSynth2_Analog"},{"location":"examples/bela/#fmsynth2","text":"import( all.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple FM synthesizer. // 2 oscillators and FM feedback on modulant oscillator // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // // CC 1 : FM feedback on modulant oscillator. // CC 14 : Modulator frequency ratio. // // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL, Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 1, 0, 1, 0.01); // modwheel: feedb = (gFreq-1) * (hslider( feedb[midi:ctrl 1] , 0, 0, 1, 0.001) : si.smoo); modFreqRatio = hslider( ratio[midi:ctrl 14] ,2,0,20,0.01) : si.smoo; // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; //=================================== Parameters Mapping ================================= //======================================================================================== // Same for volum modulation: volA = hslider( A[midi:ctrl 73] ,0.01,0.01,4,0.01); volD = hslider( D[midi:ctrl 76] ,0.6,0.01,8,0.01); volS = hslider( S[midi:ctrl 77] ,0.2,0,1,0.01); volR = hslider( R[midi:ctrl 72] ,0.8,0.01,8,0.01); envelop = en.adsre(volA,volD,volS,volR,midigate); // modulator frequency modFreq = gFreq*modFreqRatio; // modulation index FMdepth = envelop * 1000 * midigain; // Out Amplitude vol = envelop; //============================================ DSP ======================================= //======================================================================================== FMfeedback(frq) = (+(_,frq):os.osci ) ~ (* (feedb)); FMall(f) = os.osci(f+(FMdepth*FMfeedback(f*modFreqRatio))); process = FMall(gFreq) * vol; Try it Yourself >>","title":"FMSynth2"},{"location":"examples/bela/#fmsynth2_fx_analog","text":"import( all.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple FM synthesizer. // 2 oscillators and FM feedback on modulant oscillator // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : Modulator frequency ratio // ANALOG_1 : Attack // ANALOG_2 : Decay/Release // ANALOG_3 : Sustain // // MIDI: // CC 1 : FM feedback on modulant oscillator. // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL, Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 1, 0, 1, 0.01); // modwheel: feedb = (gFreq-1) * (hslider( feedb[midi:ctrl 1] , 0, 0, 1, 0.001) : si.smoo); modFreqRatio = hslider( ratio[BELA: ANALOG_0] ,2,0,20,0.01) : si.smoo; // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; //=================================== Parameters Mapping ================================= //======================================================================================== // Same for volum modulation: volA = hslider( A[BELA: ANALOG_1] ,0.01,0.01,4,0.01); volDR = hslider( DR[BELA: ANALOG_2] ,0.6,0.01,8,0.01); volS = hslider( S[BELA: ANALOG_3] ,0.2,0,1,0.01); envelop = en.adsre(volA,volDR,volS,volDR,midigate); // modulator frequency modFreq = gFreq * modFreqRatio; // modulation index FMdepth = envelop * 1000 * midigain; // Out Amplitude vol = envelop; //============================================ DSP ======================================= //======================================================================================== FMfeedback(frq) = (+(_,frq):os.osci) ~ (* (feedb)); FMall(f) = os.osci(f+ (FMdepth*FMfeedback(f*modFreqRatio))); //#################################################################################################// //##################################### EFFECT SECTION ############################################// //#################################################################################################// // // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // // This version use ANALOG IN to controle some of the parameters. // Other parameters continue to be available by MIDI or OSC. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_4 : Distortion Drive // ANALOG_5 : Flanger Dry/Wet // ANALOG_6 : Reverberation Dry/Wet // ANALOG_7 : Reverberation Room size // // MIDI: // CC 7 : Volume // CC 10 : Pan // // CC 13 : Flanger Delay // CC 13 : Flanger Delay // CC 94 : Flanger Feedback // // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: volFX = hslider( volume[midi:ctrl 7] ,1,0,1,0.001); // Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider( drive[BELA: ANALOG_4] ,0.3,0,1,0.001); // Flanger curdel = hslider( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider( dryWetFlang[BELA: ANALOG_5] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[BELA: ANALOG_7] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[BELA: ANALOG_6] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; process = FMall(gFreq) * vol; Try it Yourself >>","title":"FMSynth2_FX_Analog"},{"location":"examples/bela/#fmsynth2_fx","text":"import( all.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple FM synthesizer. // 2 oscillators and FM feedback on modulant oscillator // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // // CC 1 : FM feedback on modulant oscillator. // CC 14 : Modulator frequency ratio. // // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL, Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 1, 0, 1, 0.01); // modwheel: feedb = (gFreq-1) * (hslider( feedb[midi:ctrl 1] , 0, 0, 1, 0.001) : si.smoo); modFreqRatio = hslider( ratio[midi:ctrl 14] ,2,0,20,0.01) : si.smoo; // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; //=================================== Parameters Mapping ================================= //======================================================================================== // Same for volum modulation: volA = hslider( A[midi:ctrl 73] ,0.01,0.01,4,0.01); volD = hslider( D[midi:ctrl 76] ,0.6,0.01,8,0.01); volS = hslider( S[midi:ctrl 77] ,0.2,0,1,0.01); volR = hslider( R[midi:ctrl 72] ,0.8,0.01,8,0.01); envelop = en.adsre(volA,volD,volS,volR,midigate); // modulator frequency modFreq = gFreq*modFreqRatio; // modulation index FMdepth = envelop * 1000 * midigain; // Out Amplitude vol = envelop; //============================================ DSP ======================================= //======================================================================================== FMfeedback(frq) = ( +(_,frq):os.osci ) ~ (* (feedb)); FMall(f) = os.osci(f+ (FMdepth*FMfeedback(f*modFreqRatio))); //#################################################################################################// //##################################### EFFECT SECTION ############################################// //#################################################################################################// // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // (All are available by OSC) // // CC 7 : Volume // CC 10 : Pan // // CC 92 : Distortion Drive // // CC 13 : Flanger Delay // CC 93 : Flanger Dry/Wet // CC 94 : Flanger Feedback // // CC 12 : Reverberation Room size // CC 91 : Reverberation Dry/Wet // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: volFX = hslider( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider( drive[midi:ctrl 92] ,0.3,0,1,0.001); // Flanger curdel = hslider( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider( dryWetFlang[midi:ctrl 93] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[midi:ctrl 12] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[midi:ctrl 91] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; process = FMall(gFreq) * vol; Try it Yourself >>","title":"FMSynth2_FX"},{"location":"examples/bela/#fxchaine2","text":"import( stdfaust.lib ); ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // // A complete Stereo FX chain with: // CHORUS // PHASER // DELAY // REVERB // // Designed to use the Analog Input for parameters controls. // // CONTROLES //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// // // ANALOG IN: // ANALOG 0 : Chorus Depth // ANALOG 1 : Chorus Delay // ANALOG 2 : Phaser Dry/Wet // ANALOG 3 : Phaser Frequency ratio // ANALOG 4 : Delay Dry/Wet // ANALOG 5 : Delay Time // ANALOG 6 : Reverberation Dry/Wet // ANALOG 7 : Reverberation Room size // // Available by OSC : (see BELA console for precise adress) // Rate : Chorus LFO modulation rate (Hz) // Deviation : Chorus delay time deviation. // // InvertSum : Phaser inversion of phaser in sum. (On/Off) // VibratoMode : Phaser vibrato Mode. (On/Off) // Speed : Phaser LFO frequency // NotchDepth : Phaser LFO depth // Feedback : Phaser Feedback // NotchWidth : Phaser Notch Width // MinNotch1 : Phaser Minimal frequency // MaxNotch1 : Phaser Maximal Frequency // // Damp : Reverberation Damp // Stereo : Reverberation Stereo Width // ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// process = chorus_stereo(dmax,curdel,rate,sigma,do2,voices) : phaserSt : xdelay : reverb; // CHORUS (from SAM demo lib) ////////////////////////////////////////////////////////////////////////////////////////////////////////// voices = 8; // MUST BE EVEN pi = 4.0*atan(1.0); periodic = 1; dmax = 8192; curdel = dmax * vslider( Delay[BELA: ANALOG_1] , 0.5, 0, 1, 1) : si.smooth(0.999); rateMax = 7.0; // Hz rateMin = 0.01; rateT60 = 0.15661; rate = vslider( Rate , 0.5, rateMin, rateMax, 0.0001): si.smooth(ba.tau2pole(rateT60/6.91)); depth = vslider( Depth [BELA: ANALOG_0] , 0.5, 0, 1, 0.001) : si.smooth(ba.tau2pole(depthT60/6.91)); // (dept = dry/wet) depthT60 = 0.15661; delayPerVoice = 0.5*curdel/voices; sigma = delayPerVoice * vslider( Deviation ,0.5,0,1,0.001) : si.smooth(0.999); do2 = depth; // use when depth=1 means multivibrato effect (no original = all are modulated) chorus_stereo(dmax,curdel,rate,sigma,do2,voices) = _,_ : *(1-do2),*(1-do2),(*(do2),*(do2) : par(i,voices,voice(i)): _,_) : ro.interleave(2,2) : +,+; voice(i) = de.fdelay(dmax,min(dmax,del(i)))/(i+1) with { angle(i) = 2*pi*(i/2)/voices + (i%2)*pi/2; voice(i) = de.fdelay(dmax,min(dmax,del(i))) * cos(angle(i)); del(i) = curdel*(i+1)/voices + dev(i); rates(i) = rate/float(i+1); dev(i) = sigma * os.oscp(rates(i),i*2*pi/voices); }; // PHASER (from demo lib.) ///////////////////////////////////////////////////////////////////////////////////////////////////////////// phaserSt = _,_ : _, _, phaser2_stereo : dry_wetST(dwPhaz) with { invert = checkbox( InvertSum ); vibr = checkbox( VibratoMode ); // In this mode you can hear any Doppler phaser2_stereo = pf.phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,mdepth,fb,invert); Notches = 4; // Compile-time parameter: 2 is typical for analog phaser stomp-boxes speed = hslider( Speed , 0.5, 0, 10, 0.001); depth = hslider( NotchDepth , 1, 0, 1, 0.001); fb = hslider( Feedback , 0.7, -0.999, 0.999, 0.001); width = hslider( NotchWidth ,1000, 10, 5000, 1); frqmin = hslider( MinNotch1 ,100, 20, 5000, 1); frqmax = hslider( MaxNotch1 ,800, 20, 10000, 1) : max(frqmin); fratio = hslider( NotchFreqRatio[BELA: ANALOG_3] ,1.5, 1.1, 4, 0.001); dwPhaz = vslider( dryWetPhaser[BELA: ANALOG_2] , 0.5, 0, 1, 0.001); mdepth = select2(vibr,depth,2); // Improve ease of use }; // DELAY (with feedback and crossfeeback) ////////////////////////////////////////////////////////////////////////////////////////////// delay = ba.sec2samp(hslider( delay[BELA: ANALOG_5] , 1,0,2,0.001)); preDelL = delay/2; delL = delay; delR = delay; crossLF = 1200; CrossFeedb = 0.6; dwDel = vslider( dryWetDelay[BELA: ANALOG_4] , 0.5, 0, 1, 0.001); routeur(a,b,c,d) = ((a*CrossFeedb):fi.lowpass(2,crossLF))+c, ((b*CrossFeedb):fi.lowpass(2,crossLF))+d; xdelay = _,_ : _,_,((de.sdelay(65536, 512,preDelL),_): (routeur : de.sdelay(65536, 512,delL) ,de.sdelay(65536, 512,delR) ) ~ (_,_)) : dry_wetST(dwDel); // REVERB (from freeverb_demo) ///////////////////////////////////////////////////////////////////////////////////////////////////////// reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[BELA: ANALOG_7] , 0.5, 0, 1, 0.001)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo ,0.5,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[BELA: ANALOG_6] , 0.2, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wetST(dw,x1,x2,y1,y2) = (wet*y1 + dry*x1),(wet*y2 + dry*x2) with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; Try it Yourself >>","title":"FXChaine2"},{"location":"examples/bela/#graingenerator","text":"/////////////////////////////////////////////////////////////////////////////////////////////////// // // Grain Generator. // Another granular synthesis example. // This one is not finished, but ready for more features and improvements... // /////////////////////////////////////////////////////////////////////////////////////////////////// // // ANALOG IN: // ANALOG 0 : Population: 0=almost nothing. 1=Full grain // ANALOG 1 : Depth of each grin, in ms. // ANALOG 2 : Position in the table = delay // ANALOG 3 : Speed = pitch change of the grains // ANALOG 4 : Feedback // /////////////////////////////////////////////////////////////////////////////////////////////////// import( all.lib ); // FOR 4 grains - MONO // UI ////////////////////////////////////////// popul = 1 - hslider( population[BELA: ANALOG_0] , 1, 0, 1, 0.001); // Coef 1= maximum; 0 = almost nothing (0.95) taille = hslider( taille[BELA: ANALOG_1] , 100, 4, 200, 0.001 ); // Size in millisecondes decal = 1 - hslider( decal[BELA: ANALOG_2] ,0,0,1,0.001); // read position compared to table srite position speed = hslider( speed[BELA: ANALOG_3] , 1, 0.125, 4, 0.001); feedback = hslider( feedback[BELA: ANALOG_4] ,0,0,2,0.001); freq = 1000/taille; tmpTaille = taille*ma.SR/ 1000; clocSize = int(tmpTaille + (tmpTaille*popul*10)); // duration between 2 clicks // CLK GENERAL ///////////////////////////////// // 4 clicks vers 4 generateurs de grains. // (idem clk freq/4 et un compteur...) detect1(x) = select2 (x 10, 0, 1); detect2(x) = select2 (x clocSize*1/3, 0, 1) : select2 (x (clocSize*1/3)+10, 0, _); detect3(x) = select2 (x clocSize*2/3, 0, 1) : select2 (x (clocSize*2/3)+10, 0, _); detect4(x) = select2 (x clocSize-10, 0, 1); cloc = (%(_,clocSize))~(+(1)) : (detect1: trig),(detect2: trig),(detect3: trig),(detect4: trig); // SIGNAUX Ctrls Player //////////////////////// trig = _ :_,mem: ; envelop = *(2*PI):+(PI):cos:*(0.5):+(0.5); rampe(f, t) = delta : (+ : select2(t,_,delta 0) : max(0)) ~ _ : raz with { raz(x) = select2 (x 1, x, 0); delta = sh(f,t)/ma.SR; sh(x,t) = ba.sAndH(t,x); }; rampe2(speed, t) = delta : (+ : select2(t,_,delta 0) : max(0)) ~ _ with { delta = sh(speed,t); sh(x,t) = ba.sAndH(t,x); }; // RWTable ////////////////////////////////////// unGrain(input, clk) = (linrwtable( wf , rindex) : *(0.2 * EnvGrain)) with { SR = 44100; buffer_sec = 1; size = int(SR * buffer_sec); init = 0.; EnvGrain = clk : (rampe(freq) : envelop); windex = (%(_,size) ) ~ ( +(1) ); posTabl = int(ba.sAndH(clk, windex)); rindex = %(int(rampe2(speed, clk)) + posTabl + int(size * decal), size); wf = size, init, int(windex), input; }; // LINEAR_INTERPOLATION_RWTABLE ////////////////////////////////// // read rwtable with linear interpolation // wf : waveform to read ( wf is defined by (size_buffer,init, windex, input )) // x : position to read (0 = x size(wf)) and float // nota: rwtable(size, init, windex, input, rindex) linrwtable(wf,x) = linterpolation(y0,y1,d) with { x0 = int(x); // x1 = int(x+1); // d = x-x0; y0 = rwtable(wf,x0); // y1 = rwtable(wf,x1); // linterpolation(v0,v1,c) = v0*(1-c)+v1*c; }; // FINALISATION ///////////////////////////////////////////////////////////////////////////////////// routeur (a, b, c, d, e) = a, b, a, c, a, d, a, e; processus = _ , cloc : routeur : (unGrain, unGrain, unGrain, unGrain) : fi.dcblockerat(20); process = _,_: ((+(_,_) :processus) ~(*(feedback))),((+(_,_) :processus) ~(*(feedback))); Try it Yourself >>","title":"GrainGenerator"},{"location":"examples/bela/#granulator","text":"// FROM FAUST DEMO // Designed to use the Analog Input for parameters contr\u00f4les. // /////////////////////////////////////////////////////////////////////////////////////////////////// // // ANALOG IN: // ANALOG 0 : Grain Size // ANALOG 1 : Speed // ANALOG 2 : Probability // (others analog inputs are not used) // /////////////////////////////////////////////////////////////////////////////////////////////////// process = vgroup( Granulator , environment { declare name Granulator ; declare author Adapted from sfIter by Christophe Lebreton ; /* =========== DESCRIPTION ============= - The granulator takes very small parts of a sound, called GRAINS, and plays them at a varying speed - Front = Medium size grains - Back = short grains - Left Slow rhythm - Right = Fast rhythm - Bottom = Regular occurrences - Head = Irregular occurrences */ import( stdfaust.lib ); process = hgroup( Granulator , *(excitation : ampf)); excitation = noiseburst(gate,P) * (gain); ampf = an.amp_follower_ud(duree_env,duree_env); //----------------------- NOISEBURST ------------------------- noiseburst(gate,P) = no.noise : *(gate : trigger(P)) with { upfront(x) = (x-x') 0; decay(n,x) = x - (x 0)/n; release(n) = + ~ decay(n); trigger(n) = upfront : release(n) : (0.0); }; //------------------------------------------------------------- P = freq; // fundamental period in samples freq = hslider( [1]GrainSize[BELA: ANALOG_0] , 200,5,2205,1); // la frequence donne la largeur de bande extraite du bruit blanc Pmax = 4096; // maximum P (for de.delay-line allocation) // PHASOR_BIN ////////////////////////////// phasor_bin (init) = (+(float(speed)/float(ma.SR)) : fmod(_,1.0)) ~ *(init); gate = phasor_bin(1) :-(0.001):pulsar; gain = 1; // PULSAR ////////////////////////////// //Le pulsar permet de creer une 'pulsation' plus ou moins aleatoire (proba). pulsar = _ :((_ (ratio_env)):@(100))*(proba (_,abs(no.noise):ba.latch)); speed = hslider ( [2]Speed[BELA: ANALOG_1] , 10,1,20,0.0001):fi.lowpass(1,1); ratio_env = 0.5; fade = (0.5); // min 0 pour eviter division par 0 proba = hslider ( [3]Probability[BELA: ANALOG_2] , 70,50,100,1) * (0.01):fi.lowpass(1,1); duree_env = 1/(speed: / (ratio_env*(0.25)*fade)); }.process); Try it Yourself >>","title":"granulator"},{"location":"examples/bela/#repeater","text":"// REPEATER: // Freeze and repeat a small part of input signal 'n' time' // /////////////////////////////////////////////////////////////////////////////////////////////////// // // ANALOG IN: // ANALOG 0 : Duration (ms) between 2 repeat series (500 to 2000 ms) // ANALOG 1 : Duration of one repeat (2 to 200 ms) // ANALOG 2 : Number of repeat // /////////////////////////////////////////////////////////////////////////////////////////////////// import( all.lib ); process = _, _ , (pathClock : compteurUpReset2(nbRepet): rampePlayer, _) : routageIO : rec_play_table , rec_play_table; /////////////////////////////////////////////////////////////////////////////////////////////////// // General loop duration MasterTaille =hslider( MasterTaille[BELA: ANALOG_0] , 500, 200, 2000,0.01); MasterClocSize = int(MasterTaille*ma.SR/ 1000); // Depth of repeat fragments taille =hslider( taille[BELA: ANALOG_1] , 50, 2, 200,0.01); clocSize = int(taille*ma.SR/ 1000); // Number of repeat fragments nbRepet = int (hslider( nbRepet[BELA: ANALOG_2] ,4,1,16,1) ); trig = _ :_,mem: ; routageIO (a, b, c, d) = a, c, d, b, c, d; rec_play_table(input, inReadIndex, reset) = ( rwtable( wf , rindex):fi.dcblockerat(20) ) with { SR = 44100; buffer_sec = 2; size = int(SR * buffer_sec); init = 0.; windex = (%(_,size))~(+(1):*(1-reset)); rindex = (%( int(inReadIndex),size)); wf = size, init, int(windex), input; }; MasterClock = (%(_,MasterClocSize))~(+(1)) : detect with { detect(x) = select2 (x 100, 0, 1); }; SlaveClock(reset) = (%(_,clocSize))~(+(1):*(1-reset)); detect1(x) = select2 (x clocSize/2, 0, 1); pathClock = MasterClock : trig, _ : SlaveClock, _ : detect1, _ ; compteurUpReset2(nb, in, reset) = ((in:trig), reset : (routage : memo2)~_), reset with { memo2(a, b) = (ba.if(b 0.5, 0, _) )~(+(a)); compare(value) = ba.if(value nb, 1, 0); // :trig; routage(d,e,f) = e , (f, compare(d) : RSLatch : +(f)); }; RSLatch(R, S) = latch(S,R) with { trig = _ :_,mem: ; latch(S,R) = _~( ba.if(R 0.5, 0, _) : ba.if(S 0.5,1,_) ); }; rampePlayer(reset) = rampe with { rst = reset : trig; rampe = _~(+(1):*(1-rst)); toZero = _ : ba.if(reset 0.5,0,_); }; Try it Yourself >>","title":"repeater"},{"location":"examples/bela/#simplefx_analog","text":"import( stdfaust.lib ); // /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // // This version use ANALOG IN to controle some of the parameters. // Other parameters continue to be available by MIDI or OSC. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_4 : Distortion Drive // ANALOG_5 : Flanger Dry/Wet // ANALOG_6 : Reverberation Dry/Wet // ANALOG_7 : Reverberation Room size // // MIDI: // CC 7 : Volume // CC 10 : Pan // // CC 13 : Flanger Delay // CC 13 : Flanger Delay // CC 94 : Flanger Feedback // // CC 95 : Reverberation Damp // CC 90: Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: vol = hslider( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider ( drive[BELA: ANALOG_4] ,0.3,0,1,0.001); // Flanger curdel = hslider( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider( dryWetFlang[BELA: ANALOG_5] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[BELA: ANALOG_7] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[BELA: ANALOG_6] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effets = _ *(vol) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; process = effets; Try it Yourself >>","title":"simpleFX_Analog"},{"location":"examples/bela/#simplefx","text":"import( stdfaust.lib ); // /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // (All are available by OSC) // // CC 7 : Volume // CC 10 : Pan // // CC 92 : Distortion Drive // // CC 13 : Flanger Delay // CC 93 : Flanger Dry/Wet // CC 94 : Flanger Feedback // // CC 12 : Reverberation Room size // CC 91 : Reverberation Dry/Wet // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: vol = hslider ( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider ( drive[midi:ctrl 92] ,0.3,0,1,0.001); // Flanger curdel = hslider ( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider ( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider ( dryWetFlang[midi:ctrl 93] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Panoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[midi:ctrl 12] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[midi:ctrl 91] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effets = _ *(vol) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; process = effets; Try it Yourself >>","title":"simpleFX"},{"location":"examples/bela/#simplesynth_analog","text":"import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // A very simple subtractive synthesizer with 1 VCO 1 VCF. // The VCO Waveform is variable between Saw and Square // The frequency is modulated by an LFO // The envelope control volum and filter frequency // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : waveform (Saw to square) // ANALOG_1 : Filter Cutoff frequency // ANALOG_2 : Filter resonance (Q) // ANALOG_3 : Filter Envelope Modulation // // MIDI: // CC 79 : Filter keyboard tracking (0 to X2, default 1) // // Envelope // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // // CC 78 : LFO frequency (0.001Hz to 10Hz) // CC 1 : LFO Amplitude (Modulation) // /////////////////////////////////////////////////////////////////////////////////////////////////// // // HUI ////////////////////////////////////////////////// // Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 0.5, 0.01);// MIDI KEYBOARD // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); // VCO wfFade = hslider( waveform[BELA: ANALOG_0] ,0.5,0,1,0.001):si.smoo; // VCF res = hslider( resonnance[BELA: ANALOG_2] ,0.5,0,1,0.001):si.smoo; fr = hslider( fc[BELA: ANALOG_1] , 10, 15, 12000, 0.001):si.smoo; track = hslider( tracking[midi:ctrl 79] , 1, 0, 2, 0.001); envMod = hslider( envMod[BELA: ANALOG_3] ,50,0,100,0.01):si.smoo; // ENV att = 0.01 * (hslider ( attack[midi:ctrl 73] ,0.1,0.1,400,0.001)); dec = 0.01 * (hslider ( decay[midi:ctrl 76] ,60,0.1,400,0.001)); sust = hslider ( sustain[midi:ctrl 77] ,0.2,0,1,0.001); rel = 0.01 * (hslider ( release[midi:ctrl 72] ,100,0.1,400,0.001)); // LFO lfoFreq = hslider ( lfoFreq[midi:ctrl 78] ,6,0.001,10,0.001):si.smoo; modwheel = hslider ( modwheel[midi:ctrl 1] ,0,0,0.5,0.001):si.smoo; // PROCESS ///////////////////////////////////////////// allfreq = (midifreq * pitchwheel) + LFO; // VCF cutoff = ((allfreq * track) + fr + (envMod * midigain * env)) : min(ma.SR/8); // VCO oscillo(f) = (os.sawtooth(f)*(1-wfFade))+(os.square(f)*wfFade); // VCA volume = midigain * env; // Enveloppe env = en.adsre(att,dec,sust,rel,midigate); // LFO LFO = os.lf_triangle(lfoFreq)*modwheel*10; // SYNTH //////////////////////////////////////////////// synth = (oscillo(allfreq) :ve.moog_vcf(res,cutoff)) * volume; // PROCESS ///////////////////////////////////////////// process = synth; Try it Yourself >>","title":"simpleSynth_Analog"},{"location":"examples/bela/#simplesynth","text":"import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // A very simple subtractive synthesizer with 1 VCO 1 VCF. // The VCO Waveform is variable between Saw and Square // The frequency is modulated by an LFO // The envelope control volum and filter frequency // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // // CC 70 : waveform (Saw to square) // CC 71 : Filter resonance (Q) // CC 74 : Filter Cutoff frequency // CC 79 : Filter keyboard tracking (0 to X2, default 1) // CC 75 : Filter Envelope Modulation // // Envelope // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // // CC 78 : LFO frequency (0.001Hz to 10Hz) // CC 1 : LFO Amplitude (Modulation) // /////////////////////////////////////////////////////////////////////////////////////////////////// // // HUI ////////////////////////////////////////////////// // Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 0.5, 0.01);// MIDI KEYBOARD // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); // VCO wfFade= hslider( waveform[midi:ctrl 70] ,0.5,0,1,0.001):si.smoo; // VCF res = hslider( resonnance[midi:ctrl 71] ,0.5,0,1,0.001):si.smoo; fr = hslider( fc[midi:ctrl 74] , 10, 15, 12000, 0.001):si.smoo; track = hslider( tracking[midi:ctrl 79] , 1, 0, 2, 0.001); envMod = hslider( envMod[midi:ctrl 75] ,50,0,100,0.01):si.smoo; // ENV att = 0.01 * (hslider ( attack[midi:ctrl 73] ,0.1,0.1,400,0.001)); dec = 0.01 * (hslider ( decay[midi:ctrl 76] ,60,0.1,400,0.001)); sust = hslider ( sustain[midi:ctrl 77] ,0.1,0,1,0.001); rel = 0.01 * (hslider ( release[midi:ctrl 72] ,100,0.1,400,0.001)); // LFO lfoFreq = hslider( lfoFreq[midi:ctrl 78] ,6,0.001,10,0.001):si.smoo; modwheel = hslider( modwheel[midi:ctrl 1] ,0,0,0.5,0.001):si.smoo; // PROCESS ///////////////////////////////////////////// allfreq = (midifreq * pitchwheel) + LFO; // VCF cutoff = ((allfreq * track) + fr + (envMod * midigain * env)) : min(ma.SR/8); // VCO oscillo(f) = (os.sawtooth(f)*(1-wfFade))+(os.square(f)*wfFade); // VCA volume = midigain * env; // Enveloppe env = en.adsre(att,dec,sust,rel,midigate); // LFO LFO = os.lf_triangle(lfoFreq)*modwheel*10; // SYNTH //////////////////////////////////////////////// synth = (oscillo(allfreq) :ve.moog_vcf(res,cutoff)) * volume; // PROCESS ///////////////////////////////////////////// process = synth; Try it Yourself >>","title":"simpleSynth"},{"location":"examples/bela/#simplesynth_fx_analog","text":"import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // A very simple subtractive synthesizer with 1 VCO 1 VCF. // The VCO Waveform is variable between Saw and Square // The frequency is modulated by an LFO // The envelope control volum and filter frequency // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : waveform (Saw to square) // ANALOG_1 : Filter Cutoff frequency // ANALOG_2 : Filter resonance (Q) // ANALOG_3 : Filter Envelope Modulation // // MIDI: // CC 79 : Filter keyboard tracking (0 to X2, default 1) // // Envelope // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // // CC 78 : LFO frequency (0.001Hz to 10Hz) // CC 1 : LFO Amplitude (Modulation) // /////////////////////////////////////////////////////////////////////////////////////////////////// // // HUI ////////////////////////////////////////////////// // Keyboard midigate = button( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 0.5, 0.01);// MIDI KEYBOARD // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); // VCO wfFade = hslider( waveform[BELA: ANALOG_0] ,0.5,0,1,0.001):si.smoo; // VCF res = hslider( resonnance[BELA: ANALOG_2] ,0.5,0,1,0.001):si.smoo; fr = hslider( fc[BELA: ANALOG_1] , 10, 15, 12000, 0.001):si.smoo; track = hslider( tracking[midi:ctrl 79] , 1, 0, 2, 0.001); envMod = hslider( envMod[BELA: ANALOG_3] ,50,0,100,0.01):si.smoo; // ENV att = 0.01 * (hslider ( attack[midi:ctrl 73] ,0.1,0.1,400,0.001)); dec = 0.01 * (hslider ( decay[midi:ctrl 76] ,60,0.1,400,0.001)); sust = hslider ( sustain[midi:ctrl 77] ,0.2,0,1,0.001); rel = 0.01 * (hslider ( release[midi:ctrl 72] ,100,0.1,400,0.001)); // LFO lfoFreq = hslider( lfoFreq[midi:ctrl 78] ,6,0.001,10,0.001):si.smoo; modwheel = hslider( modwheel[midi:ctrl 1] ,0,0,0.5,0.001):si.smoo; // PROCESS ///////////////////////////////////////////// allfreq = (midifreq * pitchwheel) + LFO; // VCF cutoff = ((allfreq * track) + fr + (envMod * midigain * env)) : min(ma.SR/8); // VCO oscillo(f) = (os.sawtooth(f)*(1-wfFade))+(os.square(f)*wfFade); // VCA volume = midigain * env; // Enveloppe env = en.adsre(att,dec,sust,rel,midigate); // LFO LFO = os.lf_triangle(lfoFreq)*modwheel*10; // SYNTH //////////////////////////////////////////////// synth = (oscillo(allfreq) :ve.moog_vcf(res,cutoff)) * volume; //#################################################################################################// //##################################### EFFECT SECTION ############################################// //#################################################################################################// // // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // // This version use ANALOG IN to controle some of the parameters. // Other parameters continue to be available by MIDI or OSC. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_4 : Distortion Drive // ANALOG_5 : Flanger Dry/Wet // ANALOG_6 : Reverberation Dry/Wet // ANALOG_7 : Reverberation Room size // // MIDI: // CC 7 : Volume // CC 10 : Pan // // CC 13 : Flanger Delay // CC 13 : Flanger Delay // CC 94 : Flanger Feedback // // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: volFX = hslider ( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider ( drive[BELA: ANALOG_4] ,0.3,0,1,0.001); // Flanger curdel = hslider ( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider ( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider ( dryWetFlang[BELA: ANALOG_5] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[BELA: ANALOG_7] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[BELA: ANALOG_6] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; // PROCESS ///////////////////////////////////////////// process = synth; Try it Yourself >>","title":"simpleSynth_FX_Analog"},{"location":"examples/bela/#simplesynth_fx","text":"import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // A very simple subtractive synthesizer with 1 VCO 1 VCF. // The VCO Waveform is variable between Saw and Square // The frequency is modulated by an LFO // The envelope control volum and filter frequency // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // // CC 70 : waveform (Saw to square) // CC 71 : Filter resonance (Q) // CC 74 : Filter Cutoff frequency // CC 79 : Filter keyboard tracking (0 to X2, default 1) // CC 75 : Filter Envelope Modulation // // Envelope // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // // CC 78 : LFO frequency (0.001Hz to 10Hz) // CC 1 : LFO Amplitude (Modulation) // /////////////////////////////////////////////////////////////////////////////////////////////////// // // HUI ////////////////////////////////////////////////// // Keyboard midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 0.5, 0.01);// MIDI KEYBOARD // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); // VCO wfFade = hslider( waveform[midi:ctrl 70] ,0.5,0,1,0.001):si.smoo; // VCF res = hslider( resonnance[midi:ctrl 71] ,0.5,0,1,0.001):si.smoo; fr = hslider( fc[midi:ctrl 74] , 10, 15, 12000, 0.001):si.smoo; track = hslider( tracking[midi:ctrl 79] , 1, 0, 2, 0.001); envMod = hslider( envMod[midi:ctrl 75] ,50,0,100,0.01):si.smoo; // ENV att = 0.01 * (hslider ( attack[midi:ctrl 73] ,0.1,0.1,400,0.001)); dec = 0.01 * (hslider ( decay[midi:ctrl 76] ,60,0.1,400,0.001)); sust = hslider ( sustain[midi:ctrl 77] ,0.1,0,1,0.001); rel = 0.01 * (hslider ( release[midi:ctrl 72] ,100,0.1,400,0.001)); // LFO lfoFreq = hslider ( lfoFreq[midi:ctrl 78] ,6,0.001,10,0.001):si.smoo; modwheel= hslider ( modwheel[midi:ctrl 1] ,0,0,0.5,0.001):si.smoo; // PROCESS ///////////////////////////////////////////// allfreq = (midifreq * pitchwheel) + LFO; // VCF cutoff= ((allfreq * track) + fr + (envMod * midigain * env)) : min(ma.SR/8); // VCO oscillo(f) = (os.sawtooth(f)*(1-wfFade))+(os.square(f)*wfFade); // VCA volume = midigain * env; // Enveloppe env = en.adsre(att,dec,sust,rel,midigate); // LFO LFO = os.lf_triangle(lfoFreq)*modwheel*10; // SYNTH //////////////////////////////////////////////// synth = (oscillo(allfreq) :ve.moog_vcf(res,cutoff)) * volume; //#################################################################################################// //##################################### EFFECT SECTION ############################################// //#################################################################################################// // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // (All are available by OSC) // // CC 7 : Volume // CC 10 : Pan // // CC 92 : Distortion Drive // // CC 13 : Flanger Delay // CC 93 : Flanger Dry/Wet // CC 94 : Flanger Feedback // // CC 12 : Reverberation Room size // CC 91 : Reverberation Dry/Wet // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: volFX = hslider ( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider ( drive[midi:ctrl 92] ,0.3,0,1,0.001); // Flanger curdel = hslider ( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider ( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider ( dryWetFlang[midi:ctrl 93] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[midi:ctrl 12] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[midi:ctrl 91] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; // PROCESS ///////////////////////////////////////////// process = synth; Try it Yourself >>","title":"simpleSynth_FX"},{"location":"examples/bela/#wavesynth_analog","text":"import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple demo of wavetable synthesis. A LFO modulate the interpolation between 4 tables. // It's possible to add more tables step. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : Wave travelling // ANALOG_1 : LFO Frequency // ANALOG_2 : LFO Depth (wave travel modulation) // ANALOG_3 : Release // // MIDI: // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 1, 0.01); waveTravel = hslider( waveTravel[BELA: ANALOG_0] ,0,0,1,0.01); // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; // LFO lfoDepth = hslider( lfoDepth[BELA: ANALOG_2] ,0,0.,1,0.001):si.smoo; lfoFreq = hslider( lfoFreq[BELA: ANALOG_1] ,0.1,0.01,10,0.001):si.smoo; moov = ((os.lf_trianglepos(lfoFreq) * lfoDepth) + waveTravel) : min(1) : max(0); volA = hslider( A[midi:ctrl 73] ,0.01,0.01,4,0.01); volD = hslider( D[midi:ctrl 76] ,0.6,0.01,8,0.01); volS = hslider( S[midi:ctrl 77] ,0.2,0,1,0.01); volR = hslider( R[BELA: ANALOG_3] ,0.8,0.01,8,0.01); envelop = en.adsre(volA,volD,volS,volR,midigate); // Out Amplitude vol = envelop * midigain; WF(tablesize, rang) = abs((fmod ((1+(float(ba.time)*rang)/float(tablesize)), 4.0 ))-2) -1.; // 4 WF maxi with this version: scanner(nb, position) = -(_,soustraction) : *(_,coef) : cos : max(0) with { coef = 3.14159 * ((nb-1)*0.5); soustraction = select2( position 0, 0, (position/(nb-1)) ); }; wfosc(freq) = (rdtable(tablesize, wt1, faze)*(moov : scanner(4,0)))+(rdtable(tablesize, wt2, faze)*(moov : scanner(4,1))) + (rdtable(tablesize, wt3, faze)*(moov : scanner(4,2)))+(rdtable(tablesize, wt4, faze)*(moov : scanner(4,3))) with { tablesize = 1024; wt1 = WF(tablesize, 16); wt2 = WF(tablesize, 8); wt3 = WF(tablesize, 6); wt4 = WF(tablesize, 4); faze = int(os.phasor(tablesize,freq)); }; process = wfosc(gFreq) * vol; Try it Yourself >>","title":"WaveSynth_Analog"},{"location":"examples/bela/#wavesynth","text":"import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple demo of wavetable synthesis. A LFO modulate the interpolation between 4 tables. // It's possible to add more tables step. // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // // CC 1 : LFO Depth (wave travel modulation) // CC 14 : LFO Frequency // CC 70 : Wave travelling // // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 1, 0.01); waveTravel = hslider( waveTravel [midi:ctrl ] ,0,0,1,0.01); // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; // LFO lfoDepth = hslider ( lfoDepth[midi:ctrl 1] ,0,0.,1,0.001):si.smoo; lfoFreq = hslider ( lfoFreq[midi:ctrl 14] ,0.1,0.01,10,0.001):si.smoo; moov = ((os.lf_trianglepos(lfoFreq) * lfoDepth) + waveTravel) : min(1) : max(0); volA = hslider( A[midi:ctrl 73] ,0.01,0.01,4,0.01); volD = hslider( D[midi:ctrl 76] ,0.6,0.01,8,0.01); volS = hslider( S[midi:ctrl 77] ,0.2,0,1,0.01); volR = hslider( R[midi:ctrl 72] ,0.8,0.01,8,0.01); envelop = en.adsre(volA,volD,volS,volR,midigate); // Out Amplitude vol = envelop * midigain ; WF(tablesize, rang) = abs((fmod ((1+(float(ba.time)*rang)/float(tablesize)), 4.0 ))-2) -1.; // 4 WF maxi with this version: scanner(nb, position) = -(_,soustraction) : *(_,coef) : cos : max(0) with{ coef = 3.14159 * ((nb-1)*0.5); soustraction = select2( position 0, 0, (position/(nb-1)) ); }; wfosc(freq) = (rdtable(tablesize, wt1, faze)*(moov : scanner(4,0)))+(rdtable(tablesize, wt2, faze)*(moov : scanner(4,1))) + (rdtable(tablesize, wt3, faze)*(moov : scanner(4,2)))+(rdtable(tablesize, wt4, faze)*(moov : scanner(4,3))) with { tablesize = 1024; wt1 = WF(tablesize, 16); wt2 = WF(tablesize, 8); wt3 = WF(tablesize, 6); wt4 = WF(tablesize, 4); faze = int(os.phasor(tablesize,freq)); }; process = wfosc(gFreq) * vol; Try it Yourself >>","title":"WaveSynth"},{"location":"examples/bela/#wavesynth_fx_analog","text":"import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple demo of wavetable synthesis. A LFO modulate the interpolation between 4 tables. // It's possible to add more tables step. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_0 : Wave travelling // ANALOG_1 : LFO Frequency // ANALOG_2 : LFO Depth (wave travel modulation) // ANALOG_3 : Release // // MIDI: // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 1, 0.01); waveTravel = hslider( waveTravel[BELA: ANALOG_0] ,0,0,1,0.01); // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; // LFO lfoDepth = hslider( lfoDepth[BELA: ANALOG_2] ,0,0.,1,0.001):si.smoo; lfoFreq = hslider( lfoFreq[BELA: ANALOG_1] ,0.1,0.01,10,0.001):si.smoo; moov = ((os.lf_trianglepos(lfoFreq) * lfoDepth) + waveTravel) : min(1) : max(0); volA = hslider( A[midi:ctrl 73] ,0.01,0.01,4,0.01); volD = hslider( D[midi:ctrl 76] ,0.6,0.01,8,0.01); volS = hslider( S[midi:ctrl 77] ,0.2,0,1,0.01); volR = hslider( R[BELA: ANALOG_3] ,0.8,0.01,8,0.01); envelop = en.adsre(volA,volD,volS,volR,midigate); // Out Amplitude vol = envelop * midigain ; WF(tablesize, rang) = abs((fmod ((1+(float(ba.time)*rang)/float(tablesize)), 4.0 ))-2) -1.; // 4 WF maxi with this version: scanner(nb, position) = -(_,soustraction) : *(_,coef) : cos : max(0) with { coef = 3.14159 * ((nb-1)*0.5); soustraction = select2( position 0, 0, (position/(nb-1)) ); }; wfosc(freq) = (rdtable(tablesize, wt1, faze)*(moov : scanner(4,0)))+(rdtable(tablesize, wt2, faze)*(moov : scanner(4,1))) + (rdtable(tablesize, wt3, faze)*(moov : scanner(4,2)))+(rdtable(tablesize, wt4, faze)*(moov : scanner(4,3))) with { tablesize = 1024; wt1 = WF(tablesize, 16); wt2 = WF(tablesize, 8); wt3 = WF(tablesize, 6); wt4 = WF(tablesize, 4); faze = int(os.phasor(tablesize,freq)); }; //#################################################################################################// //##################################### EFFECT SECTION ############################################// //#################################################################################################// // // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // // This version use ANALOG IN to controle some of the parameters. // Other parameters continue to be available by MIDI or OSC. // /////////////////////////////////////////////////////////////////////////////////////////////////// // ANALOG IMPLEMENTATION: // // ANALOG_4 : Distortion Drive // ANALOG_5 : Flanger Dry/Wet // ANALOG_6 : Reverberation Dry/Wet // ANALOG_7 : Reverberation Room size // // MIDI: // CC 7 : Volume // CC 10 : Pan // // CC 13 : Flanger Delay // CC 13 : Flanger Delay // CC 94 : Flanger Feedback // // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: volFX = hslider( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider ( drive[BELA: ANALOG_4] ,0.3,0,1,0.001); // Flanger curdel = hslider( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider( dryWetFlang[BELA: ANALOG_5] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[BELA: ANALOG_7] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[BELA: ANALOG_6] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; process = wfosc(gFreq) * vol; Try it Yourself >>","title":"WaveSynth_FX_Analog"},{"location":"examples/bela/#wavesynth_fx","text":"import( stdfaust.lib ); /////////////////////////////////////////////////////////////////////////////////////////////////// // // Simple demo of wavetable synthesis. A LFO modulate the interpolation between 4 tables. // It's possible to add more tables step. // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // // CC 1 : LFO Depth (wave travel modulation) // CC 14 : LFO Frequency // CC 70 : Wave travelling // // CC 73 : Attack // CC 76 : Decay // CC 77 : Sustain // CC 72 : Release // /////////////////////////////////////////////////////////////////////////////////////////////////// // GENERAL midigate = button ( gate ); midifreq = nentry( freq[unit:Hz] , 440, 20, 20000, 1); midigain = nentry( gain , 0.5, 0, 1, 0.01); waveTravel = hslider( waveTravel [midi:ctrl ] ,0,0,1,0.01); // pitchwheel pitchwheel = hslider( bend [midi:pitchwheel] ,1,0.001,10,0.01); gFreq = midifreq * pitchwheel; // LFO lfoDepth = hslider( lfoDepth[midi:ctrl 1] ,0,0.,1,0.001):si.smoo; lfoFreq = hslider( lfoFreq[midi:ctrl 14] ,0.1,0.01,10,0.001):si.smoo; moov = ((os.lf_trianglepos(lfoFreq) * lfoDepth) + waveTravel) : min(1) : max(0); volA = hslider( A[midi:ctrl 73] ,0.01,0.01,4,0.01); volD = hslider( D[midi:ctrl 76] ,0.6,0.01,8,0.01); volS = hslider( S[midi:ctrl 77] ,0.2,0,1,0.01); volR = hslider( R[midi:ctrl 72] ,0.8,0.01,8,0.01); envelop = en.adsre(volA,volD,volS,volR,midigate); // Out Amplitude vol = envelop * midigain ; WF(tablesize, rang) = abs((fmod ((1+(float(ba.time)*rang)/float(tablesize)), 4.0 ))-2) -1.; // 4 WF maxi with this version: scanner(nb, position) = -(_,soustraction) : *(_,coef) : cos : max(0) with { coef = 3.14159 * ((nb-1)*0.5); soustraction = select2( position 0, 0, (position/(nb-1)) ); }; wfosc(freq) = (rdtable(tablesize, wt1, faze)*(moov : scanner(4,0)))+(rdtable(tablesize, wt2, faze)*(moov : scanner(4,1))) + (rdtable(tablesize, wt3, faze)*(moov : scanner(4,2)))+(rdtable(tablesize, wt4, faze)*(moov : scanner(4,3))) with { tablesize = 1024; wt1 = WF(tablesize, 16); wt2 = WF(tablesize, 8); wt3 = WF(tablesize, 6); wt4 = WF(tablesize, 4); faze = int(os.phasor(tablesize,freq)); }; //#################################################################################################// //##################################### EFFECT SECTION ############################################// //#################################################################################################// // Simple FX chaine build for a mono synthesizer. // It controle general volume and pan. // FX Chaine is: // Drive // Flanger // Reverberation // /////////////////////////////////////////////////////////////////////////////////////////////////// // MIDI IMPLEMENTATION: // (All are available by OSC) // // CC 7 : Volume // CC 10 : Pan // // CC 92 : Distortion Drive // // CC 13 : Flanger Delay // CC 93 : Flanger Dry/Wet // CC 94 : Flanger Feedback // // CC 12 : Reverberation Room size // CC 91 : Reverberation Dry/Wet // CC 95 : Reverberation Damp // CC 90 : Reverberation Stereo Width // /////////////////////////////////////////////////////////////////////////////////////////////////// // VOLUME: volFX = hslider( volume[midi:ctrl 7] ,1,0,1,0.001);// Should be 7 according to MIDI CC norm. // EFFECTS ///////////////////////////////////////////// drive = hslider ( drive[midi:ctrl 92] ,0.3,0,1,0.001); // Flanger curdel = hslider( flangDel[midi:ctrl 13] ,4,0.001,10,0.001); fb = hslider( flangFeedback[midi:ctrl 94] ,0.7,0,1,0.001); fldw = hslider( dryWetFlang[midi:ctrl 93] ,0.5,0,1,0.001); flanger = efx with { fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10); efx = _ : _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw); }; // Pannoramique: panno = _ : sp.panner(hslider ( pan[midi:ctrl 10] ,0.5,0,1,0.001)) : _,_; // REVERB (from freeverb_demo) reverb = _,_ : (*(g)*fixedgain,*(g)*fixedgain : re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)), *(1-g), *(1-g) : _,_ with { scaleroom = 0.28; offsetroom = 0.7; allpassfeed = 0.5; scaledamp = 0.4; fixedgain = 0.1; origSR = 44100; damping = vslider( Damp[midi:ctrl 95] ,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR; combfeed = vslider( RoomSize[midi:ctrl 12] , 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom; spatSpread = vslider( Stereo[midi:ctrl 90] ,0.6,0,1,0.01)*46*ma.SR/origSR; g = vslider( dryWetReverb[midi:ctrl 91] , 0.4, 0, 1, 0.001); // (g = Dry/Wet) }; // Dry-Wet (from C. LEBRETON) dry_wet(dw,x,y) = wet*y + dry*x with { wet = 0.5*(dw+1.0); dry = 1.0-wet; }; // ALL effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb; process = wfosc(gFreq) * vol; Try it Yourself >>","title":"WaveSynth_FX"},{"location":"examples/delayEcho/","text":"delayEcho echo // WARNING: This a legacy example based on a deprecated library . Check misceffects.lib // for more accurate examples of echo functions declare name echo ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //----------------------------------------------- // A Simple Echo //----------------------------------------------- import( stdfaust.lib ); process = vgroup( echo-simple , ef.echo1s); Try it Yourself >> quadEcho // WARNING: This a legacy example based on a deprecated library . Check misceffects.lib // for more accurate examples of echo functions declare name quadEcho ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2007 ; //----------------------------------------------- // A 1 second quadriphonic Echo //----------------------------------------------- import( stdfaust.lib ); process = vgroup( stereo echo , multi(ef.echo1s, 4)) with{ multi(f,1) = f; multi(f,n) = f,multi(f,n-1); }; Try it Yourself >> smoothDelay declare name smoothDelay ; declare author Yann Orlarey ; declare copyright Grame ; declare version 1.0 ; declare license STK-4.3 ; //--------------------------process---------------------------- // // A stereo smooth delay with a feedback control // // This example shows how to use sdelay, a delay that doesn't // click and doesn't transpose when the delay time is changed //------------------------------------------------------------- import( stdfaust.lib ); process = par(i, 2, voice) with { voice = (+ : de.sdelay(N, interp, dtime)) ~ *(fback); N = int(2^19); interp = hslider( interpolation[unit:ms][style:knob] ,10,1,100,0.1)*ma.SR/1000.0; dtime = hslider( delay[unit:ms][style:knob] , 0, 0, 5000, 0.1)*ma.SR/1000.0; fback = hslider( feedback[style:knob] ,0,0,100,0.1)/100.0; }; Try it Yourself >> stereoEcho // WARNING: This a legacy example based on a deprecated library . Check misceffects.lib // for more accurate examples of echo functions declare name stereoEcho ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2007 ; //----------------------------------------------- // A 1 second Stereo Echo //----------------------------------------------- import( stdfaust.lib ); process = vgroup( stereo echo , (ef.echo1s, ef.echo1s)); Try it Yourself >> tapiir declare name tapiir ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //====================================================== // // TAPIIR // (from Maarten de Boer's Tapiir) // //====================================================== import( stdfaust.lib ); dsize = 524288; // user interface //--------------- tap(n) = vslider( tap %n , 0,0,1,0.1); in(n) = vslider( input %n , 1,0,1,0.1); gain = vslider( gain , 1,0,1,0.1); del = vslider( delay (sec) , 0, 0, 5, 0.01) * ma.SR; // mixer and matrix //----------------------------------------------------------- mixer(taps,lines) = par(i,taps,*(tap(i))), par(i,lines,*(in(i))) : *(gain); matrix(taps,lines) = ( si.bus(lines+taps) : tgroup( , par(i, taps, hgroup( Tap %i , mixer(taps,lines) : de.delay(dsize,del)))) ) ~ si.bus(taps); // tapiir //-------- tapiir(taps,lines) = vgroup( Tapiir , si.bus(lines) : (matrix(taps,lines), si.bus(lines)) : vgroup( outputs , par( i, lines, hgroup( output %i , mixer(taps,lines)) ) ) ); process = tapiir(6,2); Try it Yourself >>","title":" delayEcho "},{"location":"examples/delayEcho/#delayecho","text":"","title":"delayEcho"},{"location":"examples/delayEcho/#echo","text":"// WARNING: This a legacy example based on a deprecated library . Check misceffects.lib // for more accurate examples of echo functions declare name echo ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //----------------------------------------------- // A Simple Echo //----------------------------------------------- import( stdfaust.lib ); process = vgroup( echo-simple , ef.echo1s); Try it Yourself >>","title":"echo"},{"location":"examples/delayEcho/#quadecho","text":"// WARNING: This a legacy example based on a deprecated library . Check misceffects.lib // for more accurate examples of echo functions declare name quadEcho ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2007 ; //----------------------------------------------- // A 1 second quadriphonic Echo //----------------------------------------------- import( stdfaust.lib ); process = vgroup( stereo echo , multi(ef.echo1s, 4)) with{ multi(f,1) = f; multi(f,n) = f,multi(f,n-1); }; Try it Yourself >>","title":"quadEcho"},{"location":"examples/delayEcho/#smoothdelay","text":"declare name smoothDelay ; declare author Yann Orlarey ; declare copyright Grame ; declare version 1.0 ; declare license STK-4.3 ; //--------------------------process---------------------------- // // A stereo smooth delay with a feedback control // // This example shows how to use sdelay, a delay that doesn't // click and doesn't transpose when the delay time is changed //------------------------------------------------------------- import( stdfaust.lib ); process = par(i, 2, voice) with { voice = (+ : de.sdelay(N, interp, dtime)) ~ *(fback); N = int(2^19); interp = hslider( interpolation[unit:ms][style:knob] ,10,1,100,0.1)*ma.SR/1000.0; dtime = hslider( delay[unit:ms][style:knob] , 0, 0, 5000, 0.1)*ma.SR/1000.0; fback = hslider( feedback[style:knob] ,0,0,100,0.1)/100.0; }; Try it Yourself >>","title":"smoothDelay"},{"location":"examples/delayEcho/#stereoecho","text":"// WARNING: This a legacy example based on a deprecated library . Check misceffects.lib // for more accurate examples of echo functions declare name stereoEcho ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2007 ; //----------------------------------------------- // A 1 second Stereo Echo //----------------------------------------------- import( stdfaust.lib ); process = vgroup( stereo echo , (ef.echo1s, ef.echo1s)); Try it Yourself >>","title":"stereoEcho"},{"location":"examples/delayEcho/#tapiir","text":"declare name tapiir ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //====================================================== // // TAPIIR // (from Maarten de Boer's Tapiir) // //====================================================== import( stdfaust.lib ); dsize = 524288; // user interface //--------------- tap(n) = vslider( tap %n , 0,0,1,0.1); in(n) = vslider( input %n , 1,0,1,0.1); gain = vslider( gain , 1,0,1,0.1); del = vslider( delay (sec) , 0, 0, 5, 0.01) * ma.SR; // mixer and matrix //----------------------------------------------------------- mixer(taps,lines) = par(i,taps,*(tap(i))), par(i,lines,*(in(i))) : *(gain); matrix(taps,lines) = ( si.bus(lines+taps) : tgroup( , par(i, taps, hgroup( Tap %i , mixer(taps,lines) : de.delay(dsize,del)))) ) ~ si.bus(taps); // tapiir //-------- tapiir(taps,lines) = vgroup( Tapiir , si.bus(lines) : (matrix(taps,lines), si.bus(lines)) : vgroup( outputs , par( i, lines, hgroup( output %i , mixer(taps,lines)) ) ) ); process = tapiir(6,2); Try it Yourself >>","title":"tapiir"},{"location":"examples/dynamic/","text":"dynamic compressor declare name compressor ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Compressor demo application ; import( stdfaust.lib ); process = dm.compressor_demo; Try it Yourself >> distortion declare name distortion ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Distortion demo application. ; import( stdfaust.lib ); process = dm.cubicnl_demo; Try it Yourself >> gateCompressor declare name gateCompressor ; import( stdfaust.lib ); process = // ol.sawtooth_demo : // el.gate_demo : ef.compressor_demo : fi.spectral_level_demo : _,_; vgroup( [1] , dm.sawtooth_demo) : vgroup( [2] , dm.gate_demo) : vgroup( [3] , dm.compressor_demo) : vgroup( [4] , dm.spectral_level_demo) : _,_; Try it Yourself >> noiseGate declare name noiseGate ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Gate demo application. ; import( stdfaust.lib ); process = dm.gate_demo; Try it Yourself >> volume declare name volume ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //----------------------------------------------- // Volume control in dB //----------------------------------------------- import( stdfaust.lib ); gain = vslider( [1] , 0, -70, +4, 0.1) : ba.db2linear : si.smoo; process = *(gain); Try it Yourself >>","title":" dynamic "},{"location":"examples/dynamic/#dynamic","text":"","title":"dynamic"},{"location":"examples/dynamic/#compressor","text":"declare name compressor ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Compressor demo application ; import( stdfaust.lib ); process = dm.compressor_demo; Try it Yourself >>","title":"compressor"},{"location":"examples/dynamic/#distortion","text":"declare name distortion ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Distortion demo application. ; import( stdfaust.lib ); process = dm.cubicnl_demo; Try it Yourself >>","title":"distortion"},{"location":"examples/dynamic/#gatecompressor","text":"declare name gateCompressor ; import( stdfaust.lib ); process = // ol.sawtooth_demo : // el.gate_demo : ef.compressor_demo : fi.spectral_level_demo : _,_; vgroup( [1] , dm.sawtooth_demo) : vgroup( [2] , dm.gate_demo) : vgroup( [3] , dm.compressor_demo) : vgroup( [4] , dm.spectral_level_demo) : _,_; Try it Yourself >>","title":"gateCompressor"},{"location":"examples/dynamic/#noisegate","text":"declare name noiseGate ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Gate demo application. ; import( stdfaust.lib ); process = dm.gate_demo; Try it Yourself >>","title":"noiseGate"},{"location":"examples/dynamic/#volume","text":"declare name volume ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //----------------------------------------------- // Volume control in dB //----------------------------------------------- import( stdfaust.lib ); gain = vslider( [1] , 0, -70, +4, 0.1) : ba.db2linear : si.smoo; process = *(gain); Try it Yourself >>","title":"volume"},{"location":"examples/filtering/","text":"filtering APF // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name APF ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = APF(x,F,G,Q); Try it Yourself >> bandFilter // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name bandFilter ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; import( stdfaust.lib ); //---------------------second order filter-------------------------- // filter(Q,F,G) // Q : quality factor [1..100] // F : frequency (Hz) // G : gain [0..1] //------------------------------------------------------------------ filter(Q,F,G) = fi.TF2( (1 + K/Q + K*K) / D, 2 * (K*K - 1) / D, (1 - K/Q + K*K) / D, 2 * (K*K - 1) / D, (1 - V*K/Q + K*K) / D ) with { V = ba.db2linear(G); K = tan(ma.PI*F/ma.SR); D = 1 + V*K/Q + K*K; }; //--------------- Band Filter with user interface ------------------ // bandfilter(F) // F : default frequency (Hz) // //------------------------------------------------------------------ bandfilter(F) = filter( nentry( Q factor [style:knob] ,50,0.1,100,0.1), nentry( freq [unit:Hz][style:knob] , F, 20, 20000, 1), 0 - vslider( gain [unit:dB] , 0, -50, 50, 0.1) ); //------------------------- Process -------------------------------- process = vgroup( Bandfilter , bandfilter(1000)); Try it Yourself >> BPF // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name BPF ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = BPF(x,F,G,Q); Try it Yourself >> cryBaby declare name cryBaby ; declare description Application demonstrating the CryBaby wah pedal emulation ; import( stdfaust.lib ); process = dm.crybaby_demo; Try it Yourself >> DNN // Forward Deep Neural Net (DNN), any number of layers of any size each declare name DNN ; declare author JOS ; declare license STK-4.3 ; import( stdfaust.lib ); layerSizes = (8,5,8); // autoencoder with 8 in out, 5-state hidden layer w(m,n,k) = m*100+n*10+k; // placeholder weights: m=layer, n=fromNode, k=destNode M = ba.count(layerSizes); N(l) = ba.take(l+1,layerSizes); // Nodes per layer process = seq(m, M-1, layer(m)) // look at weights: // process = par(m,M,par(n,N(m),par(k,N(m),w(m,n,k)))) with { layer(m) = weights(m) : nonlinearities(m); nonlinearities(m) = bus(N(m)*N(m+1)) : par(n,N(m+1),nl(n)); weights(m) = bus(N(m)) : par(n,N(m),(bus(N(m+1)) :wts(m,n))); wts(m,n) = bus(N(m+1)) : par(k,N(m+1),*(w(m,n,k))); nl(n,x) = x * (x 0); // ReLU bus(N) = par(k,N,_); }; Try it Yourself >> filterBank declare name filterBank ; declare description Graphic Equalizer consisting of a filter-bank driving a bank of faders ; import( stdfaust.lib ); process = dm.filterbank_demo; Try it Yourself >> graphicEqLab declare name graphicEqLab ; declare description Signal generators through a filter bank with spectrum analysis display ; import( stdfaust.lib ); process = // ol.sawtooth_demo : fl.filterbank_demo : fl.spectral_level_demo : _,_; vgroup( [1] ,dm.sawtooth_demo) : vgroup( [2] ,dm.filterbank_demo) : vgroup( [3] ,dm.spectral_level_demo) : _,_; Try it Yourself >> highShelf // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name highShelf ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = highShelf(x,F,G,Q); Try it Yourself >> HPF // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name HPF ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = HPF(x,F,G,Q); Try it Yourself >> lfBoost // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name lfboost ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------------------------ // DAFX, Digital Audio Effects (Wiley ed.) // chapter 2 : filters // section 2.3 : Equalizers // page 53 : second order shelving filter design //------------------------------------------------------------------ import( stdfaust.lib ); //----------------------low frequency boost filter ------------------------------- // lfboost(F,G) // F : frequency (in Hz) // G : gain (in dB) // //-------------------------------------------------------------------------------- lfboost(F,G) = fi.TF2((1 + sqrt(2*V)*K + V*K*K) / denom, 2 * (V*K*K - 1) / denom, (1 - sqrt(2*V)*K + V*K*K) / denom, 2 * (K*K - 1) / denom, (1 - sqrt(2)*K + K*K) / denom) with { V = ba.db2linear(G); K = tan(ma.PI*F/ma.SR); denom = 1 + sqrt(2)*K + K*K; }; //====================low frequency boost process =============================== process = vgroup( lowboost , lfboost(nentry( freq [unit:Hz][style:knob] , 100, 20, 150, 1), vslider( gain [unit:dB] , 0, -20, 20, 0.1))); Try it Yourself >> lowBoost // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name lowboost ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------------------------ // DAFX, Digital Audio Effects (Wiley ed.) // chapter 2 : filters // section 2.3 : Equalizers // page 53 : second order shelving filter design //------------------------------------------------------------------ import( stdfaust.lib ); //------------------- low-frequency shelving boost (table 2.3) -------------------- V0(g) = pow(10,g/20.0); K(fc) = tan(ma.PI*fc/ma.SR); square(x) = x*x; denom(fc) = 1 + sqrt(2)*K(fc) + square(K(fc)); lfboost(fc, g) = fi.TF2((1 + sqrt(2*V0(g))*K(fc) + V0(g)*square(K(fc))) / denom(fc), 2 * (V0(g)*square(K(fc)) - 1) / denom(fc), (1 - sqrt(2*V0(g))*K(fc) + V0(g)*square(K(fc))) / denom(fc), 2 * (square(K(fc)) - 1) / denom(fc), (1 - sqrt(2)*K(fc) + square(K(fc))) / denom(fc)); //------------------------------ User Interface ----------------------------------- freq = hslider( [1]freq [unit:Hz][style:knob] , 1000, 20, 20000, 0.1); gain = hslider( [2]gain [unit:dB][style:knob] , 0, -20, 20, 0.1); //----------------------------------- Process ------------------------------------- process = vgroup( low-freq shelving boost , lfboost(freq,gain)); Try it Yourself >> lowCut // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name lowcut ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------------------------ // DAFX, Digital Audio Effects (Wiley ed.) // chapter 2 : filters // section 2.3 : Equalizers // page 53 : second order shelving filter design //------------------------------------------------------------------ import( stdfaust.lib ); //------------------- low-frequency shelving cut (table 2.3) -------------------- V0(g) = pow(10,g/-20.0); K(fc) = tan(ma.PI*fc/ma.SR); squ(x) = x*x; denom(fc,g) = 1 + sqrt(2*V0(g))*K(fc) + V0(g)*squ(K(fc)); lfcut(fc, g) = fi.TF2((1 + sqrt(2)*K(fc) + squ(K(fc))) / denom(fc,g), 2 * (squ(K(fc)) - 1) / denom(fc,g), (1 - sqrt(2)*K(fc) + squ(K(fc))) / denom(fc,g), 2 * (V0(g)*squ(K(fc)) - 1) / denom(fc,g), (1 - sqrt(2*V0(g))*K(fc) + V0(g)*squ(K(fc))) / denom(fc,g)); //------------------------------ User Interface ----------------------------------- freq = hslider( freq [unit:Hz][style:knob] , 100, 20, 5000, 1); att = hslider( attenuation [unit:dB][style:knob] , 0, -96, 10, 0.1); //----------------------------------- Process ------------------------------------- process = vgroup( low-freq shelving cut , lfcut(freq,att)); Try it Yourself >> lowShelf // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name lowShelf ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = lowShelf(x,F,G,Q); Try it Yourself >> LPF // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name LPF ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = LPF(x,F,G,Q); Try it Yourself >> moogVCF declare name moogVCF ; declare description Exercise and compare three Moog VCF implementations ; import( stdfaust.lib ); process = dm.moog_vcf_demo; Try it Yourself >> notch // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name notch ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = notch(x,F,G,Q); Try it Yourself >> parametricEqLab declare name parametricEqLab ; declare description Demonstrate the Parametric Equalizer sections on test signals with spectrum analysis display ; import( stdfaust.lib ); //process = ol.sawtooth_demo : fl.parametric_eq_demo : // fl.mth_octave_spectral_level_demo(2) : _,_; process = vgroup( [1] , dm.sawtooth_demo) : vgroup( [2] , dm.parametric_eq_demo) : vgroup( [3] , dm.mth_octave_spectral_level_demo(2)) : _,_; Try it Yourself >> parametricEqualizer declare name parametricEqualizer ; declare description Exercise and compare Parametric Equalizer sections on test signals ; import( stdfaust.lib ); process = dm.parametric_eq_demo; Try it Yourself >> peakingEQ // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name peakingEQ ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = peakingEQ(x,F,G,Q); Try it Yourself >> peakNotch // WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name peakNotch ; import( maxmsp.lib ); G = hslider( Gain [unit: lin] , 1, 0, 8, 0.01); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = peakNotch(x,F,G,Q); Try it Yourself >> spectralTilt declare name spectralTilt ; declare description Demonstrate the Spectral Tilt effect on test signals ; import( stdfaust.lib ); O = 2; // filter order process = dm.spectral_tilt_demo(2); Try it Yourself >> vcfWahLab import( stdfaust.lib ); declare description Demonstrate competing variable-lowpass-filter effects on test signals with spectrum analysis display ; declare name vcfWahLab ; // process = ol.sawtooth_demo : // el.crybaby_demo : el.moog_vcf_demo : el.wah4_demo : // fl.spectral_level_demo : _,_; process = vgroup( [1] , dm.sawtooth_demo) : vgroup( [2] , dm.crybaby_demo) : vgroup( [3] , dm.wah4_demo) : vgroup( [4] , dm.moog_vcf_demo) : vgroup( [5] , dm.spectral_level_demo) : _,_; Try it Yourself >> vocoder declare name Vocoder ; declare version 0.0 ; declare author RM ; declare description Use example of the vocoder function where an impulse train is used as excitation. ; import( stdfaust.lib ); process = dm.vocoder_demo; Try it Yourself >> wahPedal declare name wahPedal ; declare description Demonstrate the Fourth-Order Wah pedal (similar to the Moog VCF) ; import( stdfaust.lib ); process = dm.wah4_demo; Try it Yourself >>","title":" filtering "},{"location":"examples/filtering/#filtering","text":"","title":"filtering"},{"location":"examples/filtering/#apf","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name APF ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = APF(x,F,G,Q); Try it Yourself >>","title":"APF"},{"location":"examples/filtering/#bandfilter","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name bandFilter ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; import( stdfaust.lib ); //---------------------second order filter-------------------------- // filter(Q,F,G) // Q : quality factor [1..100] // F : frequency (Hz) // G : gain [0..1] //------------------------------------------------------------------ filter(Q,F,G) = fi.TF2( (1 + K/Q + K*K) / D, 2 * (K*K - 1) / D, (1 - K/Q + K*K) / D, 2 * (K*K - 1) / D, (1 - V*K/Q + K*K) / D ) with { V = ba.db2linear(G); K = tan(ma.PI*F/ma.SR); D = 1 + V*K/Q + K*K; }; //--------------- Band Filter with user interface ------------------ // bandfilter(F) // F : default frequency (Hz) // //------------------------------------------------------------------ bandfilter(F) = filter( nentry( Q factor [style:knob] ,50,0.1,100,0.1), nentry( freq [unit:Hz][style:knob] , F, 20, 20000, 1), 0 - vslider( gain [unit:dB] , 0, -50, 50, 0.1) ); //------------------------- Process -------------------------------- process = vgroup( Bandfilter , bandfilter(1000)); Try it Yourself >>","title":"bandFilter"},{"location":"examples/filtering/#bpf","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name BPF ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = BPF(x,F,G,Q); Try it Yourself >>","title":"BPF"},{"location":"examples/filtering/#crybaby","text":"declare name cryBaby ; declare description Application demonstrating the CryBaby wah pedal emulation ; import( stdfaust.lib ); process = dm.crybaby_demo; Try it Yourself >>","title":"cryBaby"},{"location":"examples/filtering/#dnn","text":"// Forward Deep Neural Net (DNN), any number of layers of any size each declare name DNN ; declare author JOS ; declare license STK-4.3 ; import( stdfaust.lib ); layerSizes = (8,5,8); // autoencoder with 8 in out, 5-state hidden layer w(m,n,k) = m*100+n*10+k; // placeholder weights: m=layer, n=fromNode, k=destNode M = ba.count(layerSizes); N(l) = ba.take(l+1,layerSizes); // Nodes per layer process = seq(m, M-1, layer(m)) // look at weights: // process = par(m,M,par(n,N(m),par(k,N(m),w(m,n,k)))) with { layer(m) = weights(m) : nonlinearities(m); nonlinearities(m) = bus(N(m)*N(m+1)) : par(n,N(m+1),nl(n)); weights(m) = bus(N(m)) : par(n,N(m),(bus(N(m+1)) :wts(m,n))); wts(m,n) = bus(N(m+1)) : par(k,N(m+1),*(w(m,n,k))); nl(n,x) = x * (x 0); // ReLU bus(N) = par(k,N,_); }; Try it Yourself >>","title":"DNN"},{"location":"examples/filtering/#filterbank","text":"declare name filterBank ; declare description Graphic Equalizer consisting of a filter-bank driving a bank of faders ; import( stdfaust.lib ); process = dm.filterbank_demo; Try it Yourself >>","title":"filterBank"},{"location":"examples/filtering/#graphiceqlab","text":"declare name graphicEqLab ; declare description Signal generators through a filter bank with spectrum analysis display ; import( stdfaust.lib ); process = // ol.sawtooth_demo : fl.filterbank_demo : fl.spectral_level_demo : _,_; vgroup( [1] ,dm.sawtooth_demo) : vgroup( [2] ,dm.filterbank_demo) : vgroup( [3] ,dm.spectral_level_demo) : _,_; Try it Yourself >>","title":"graphicEqLab"},{"location":"examples/filtering/#highshelf","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name highShelf ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = highShelf(x,F,G,Q); Try it Yourself >>","title":"highShelf"},{"location":"examples/filtering/#hpf","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name HPF ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = HPF(x,F,G,Q); Try it Yourself >>","title":"HPF"},{"location":"examples/filtering/#lfboost","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name lfboost ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------------------------ // DAFX, Digital Audio Effects (Wiley ed.) // chapter 2 : filters // section 2.3 : Equalizers // page 53 : second order shelving filter design //------------------------------------------------------------------ import( stdfaust.lib ); //----------------------low frequency boost filter ------------------------------- // lfboost(F,G) // F : frequency (in Hz) // G : gain (in dB) // //-------------------------------------------------------------------------------- lfboost(F,G) = fi.TF2((1 + sqrt(2*V)*K + V*K*K) / denom, 2 * (V*K*K - 1) / denom, (1 - sqrt(2*V)*K + V*K*K) / denom, 2 * (K*K - 1) / denom, (1 - sqrt(2)*K + K*K) / denom) with { V = ba.db2linear(G); K = tan(ma.PI*F/ma.SR); denom = 1 + sqrt(2)*K + K*K; }; //====================low frequency boost process =============================== process = vgroup( lowboost , lfboost(nentry( freq [unit:Hz][style:knob] , 100, 20, 150, 1), vslider( gain [unit:dB] , 0, -20, 20, 0.1))); Try it Yourself >>","title":"lfBoost"},{"location":"examples/filtering/#lowboost","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name lowboost ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------------------------ // DAFX, Digital Audio Effects (Wiley ed.) // chapter 2 : filters // section 2.3 : Equalizers // page 53 : second order shelving filter design //------------------------------------------------------------------ import( stdfaust.lib ); //------------------- low-frequency shelving boost (table 2.3) -------------------- V0(g) = pow(10,g/20.0); K(fc) = tan(ma.PI*fc/ma.SR); square(x) = x*x; denom(fc) = 1 + sqrt(2)*K(fc) + square(K(fc)); lfboost(fc, g) = fi.TF2((1 + sqrt(2*V0(g))*K(fc) + V0(g)*square(K(fc))) / denom(fc), 2 * (V0(g)*square(K(fc)) - 1) / denom(fc), (1 - sqrt(2*V0(g))*K(fc) + V0(g)*square(K(fc))) / denom(fc), 2 * (square(K(fc)) - 1) / denom(fc), (1 - sqrt(2)*K(fc) + square(K(fc))) / denom(fc)); //------------------------------ User Interface ----------------------------------- freq = hslider( [1]freq [unit:Hz][style:knob] , 1000, 20, 20000, 0.1); gain = hslider( [2]gain [unit:dB][style:knob] , 0, -20, 20, 0.1); //----------------------------------- Process ------------------------------------- process = vgroup( low-freq shelving boost , lfboost(freq,gain)); Try it Yourself >>","title":"lowBoost"},{"location":"examples/filtering/#lowcut","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name lowcut ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------------------------ // DAFX, Digital Audio Effects (Wiley ed.) // chapter 2 : filters // section 2.3 : Equalizers // page 53 : second order shelving filter design //------------------------------------------------------------------ import( stdfaust.lib ); //------------------- low-frequency shelving cut (table 2.3) -------------------- V0(g) = pow(10,g/-20.0); K(fc) = tan(ma.PI*fc/ma.SR); squ(x) = x*x; denom(fc,g) = 1 + sqrt(2*V0(g))*K(fc) + V0(g)*squ(K(fc)); lfcut(fc, g) = fi.TF2((1 + sqrt(2)*K(fc) + squ(K(fc))) / denom(fc,g), 2 * (squ(K(fc)) - 1) / denom(fc,g), (1 - sqrt(2)*K(fc) + squ(K(fc))) / denom(fc,g), 2 * (V0(g)*squ(K(fc)) - 1) / denom(fc,g), (1 - sqrt(2*V0(g))*K(fc) + V0(g)*squ(K(fc))) / denom(fc,g)); //------------------------------ User Interface ----------------------------------- freq = hslider( freq [unit:Hz][style:knob] , 100, 20, 5000, 1); att = hslider( attenuation [unit:dB][style:knob] , 0, -96, 10, 0.1); //----------------------------------- Process ------------------------------------- process = vgroup( low-freq shelving cut , lfcut(freq,att)); Try it Yourself >>","title":"lowCut"},{"location":"examples/filtering/#lowshelf","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name lowShelf ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = lowShelf(x,F,G,Q); Try it Yourself >>","title":"lowShelf"},{"location":"examples/filtering/#lpf","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name LPF ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = LPF(x,F,G,Q); Try it Yourself >>","title":"LPF"},{"location":"examples/filtering/#moogvcf","text":"declare name moogVCF ; declare description Exercise and compare three Moog VCF implementations ; import( stdfaust.lib ); process = dm.moog_vcf_demo; Try it Yourself >>","title":"moogVCF"},{"location":"examples/filtering/#notch","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name notch ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = notch(x,F,G,Q); Try it Yourself >>","title":"notch"},{"location":"examples/filtering/#parametriceqlab","text":"declare name parametricEqLab ; declare description Demonstrate the Parametric Equalizer sections on test signals with spectrum analysis display ; import( stdfaust.lib ); //process = ol.sawtooth_demo : fl.parametric_eq_demo : // fl.mth_octave_spectral_level_demo(2) : _,_; process = vgroup( [1] , dm.sawtooth_demo) : vgroup( [2] , dm.parametric_eq_demo) : vgroup( [3] , dm.mth_octave_spectral_level_demo(2)) : _,_; Try it Yourself >>","title":"parametricEqLab"},{"location":"examples/filtering/#parametricequalizer","text":"declare name parametricEqualizer ; declare description Exercise and compare Parametric Equalizer sections on test signals ; import( stdfaust.lib ); process = dm.parametric_eq_demo; Try it Yourself >>","title":"parametricEqualizer"},{"location":"examples/filtering/#peakingeq","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name peakingEQ ; import( maxmsp.lib ); G = hslider( Gain [unit:dB] , 0, -10, 10, 0.1); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = peakingEQ(x,F,G,Q); Try it Yourself >>","title":"peakingEQ"},{"location":"examples/filtering/#peaknotch","text":"// WARNING: This a legacy example based on a deprecated library . Check filters.lib // for more accurate examples of filter functions declare name peakNotch ; import( maxmsp.lib ); G = hslider( Gain [unit: lin] , 1, 0, 8, 0.01); F = hslider( Freq , 1000, 100, 10000, 1); Q = hslider( Q , 1, 0.01, 100, 0.01); process(x) = peakNotch(x,F,G,Q); Try it Yourself >>","title":"peakNotch"},{"location":"examples/filtering/#spectraltilt","text":"declare name spectralTilt ; declare description Demonstrate the Spectral Tilt effect on test signals ; import( stdfaust.lib ); O = 2; // filter order process = dm.spectral_tilt_demo(2); Try it Yourself >>","title":"spectralTilt"},{"location":"examples/filtering/#vcfwahlab","text":"import( stdfaust.lib ); declare description Demonstrate competing variable-lowpass-filter effects on test signals with spectrum analysis display ; declare name vcfWahLab ; // process = ol.sawtooth_demo : // el.crybaby_demo : el.moog_vcf_demo : el.wah4_demo : // fl.spectral_level_demo : _,_; process = vgroup( [1] , dm.sawtooth_demo) : vgroup( [2] , dm.crybaby_demo) : vgroup( [3] , dm.wah4_demo) : vgroup( [4] , dm.moog_vcf_demo) : vgroup( [5] , dm.spectral_level_demo) : _,_; Try it Yourself >>","title":"vcfWahLab"},{"location":"examples/filtering/#vocoder","text":"declare name Vocoder ; declare version 0.0 ; declare author RM ; declare description Use example of the vocoder function where an impulse train is used as excitation. ; import( stdfaust.lib ); process = dm.vocoder_demo; Try it Yourself >>","title":"vocoder"},{"location":"examples/filtering/#wahpedal","text":"declare name wahPedal ; declare description Demonstrate the Fourth-Order Wah pedal (similar to the Moog VCF) ; import( stdfaust.lib ); process = dm.wah4_demo; Try it Yourself >>","title":"wahPedal"},{"location":"examples/gameaudio/","text":"gameaudio bubble declare name bubble ; declare description Production of a water drop bubble sound. ; declare license MIT ; declare copyright (c) 2017: Yann Orlarey, GRAME ; import( stdfaust.lib ); //---------------------------bubble-------------------------- // bubble(f0, trig) : produces a water drop bubble sound // // #### Usage // // // bubble(f0, trig) : _ // // // Where: // // * f0 : base frequency of bubble sound // * trig: trigs the bubble sound on the rising front // // #### Example // // // button( drop ) : bubble(600) : _ // // // #### Reference: // // http://www.cs.ubc.ca/~kvdoel/publications/tap05.pdf //------------------------------------------------------------ bubble(f0,trig) = os.osc(f) * (exp(-damp*time) : si.smooth(0.99)) with { damp = 0.043*f0 + 0.0014*f0^(3/2); f = f0*(1+sigma*time); sigma = eta * damp; eta = 0.075; time = 0 : (select2(trig trig'):+(1)) ~ _ : ba.samp2sec; }; process = button( drop ) : bubble(hslider( v:bubble/freq , 600, 150, 2000, 1)) : dm.freeverb_demo; Try it Yourself >> rain //----------------------rain-------------------------- // A very simple rain simulator // // #### Usage // // // rain(d,l) : _,_ // // // Where: // // * d: is the density of the rain: between 0 and 1 // * l: is the level (volume) of the rain: between 0 and 1 // //---------------------------------------------------------- import( stdfaust.lib ); rain(density,level) = no.multinoise(2) : par(i, 2, drop) : par(i, 2, *(level)) with { drop = _ : @(1), (abs density) : *; }; process = rain ( hslider( v:rain/density , 300, 0, 1000, 1) / 1000, hslider( v:rain/volume , 0.5, 0, 1, 0.01) ); Try it Yourself >> wind //----------------------wind-------------------------- // A very simple wind simulator, based on a filtered white noise // // #### Usage // // // wind(f) : _ // // // Where: // // * f: is the force of the wind: between 0 and 1 // //---------------------------------------------------------- import( stdfaust.lib ); wind(force) = no.multinoise(2) : par(i, 2, ve.moog_vcf_2bn(force,freq)) : par(i, 2, *(force)) with { freq = (force*87)+1 : ba.pianokey2hz; }; process = wind ( hslider( v:wind/force ,0.66,0,1,0.01) : si.smooth (0.997) ); Try it Yourself >>","title":" gameaudio "},{"location":"examples/gameaudio/#gameaudio","text":"","title":"gameaudio"},{"location":"examples/gameaudio/#bubble","text":"declare name bubble ; declare description Production of a water drop bubble sound. ; declare license MIT ; declare copyright (c) 2017: Yann Orlarey, GRAME ; import( stdfaust.lib ); //---------------------------bubble-------------------------- // bubble(f0, trig) : produces a water drop bubble sound // // #### Usage // // // bubble(f0, trig) : _ // // // Where: // // * f0 : base frequency of bubble sound // * trig: trigs the bubble sound on the rising front // // #### Example // // // button( drop ) : bubble(600) : _ // // // #### Reference: // // http://www.cs.ubc.ca/~kvdoel/publications/tap05.pdf //------------------------------------------------------------ bubble(f0,trig) = os.osc(f) * (exp(-damp*time) : si.smooth(0.99)) with { damp = 0.043*f0 + 0.0014*f0^(3/2); f = f0*(1+sigma*time); sigma = eta * damp; eta = 0.075; time = 0 : (select2(trig trig'):+(1)) ~ _ : ba.samp2sec; }; process = button( drop ) : bubble(hslider( v:bubble/freq , 600, 150, 2000, 1)) : dm.freeverb_demo; Try it Yourself >>","title":"bubble"},{"location":"examples/gameaudio/#rain","text":"//----------------------rain-------------------------- // A very simple rain simulator // // #### Usage // // // rain(d,l) : _,_ // // // Where: // // * d: is the density of the rain: between 0 and 1 // * l: is the level (volume) of the rain: between 0 and 1 // //---------------------------------------------------------- import( stdfaust.lib ); rain(density,level) = no.multinoise(2) : par(i, 2, drop) : par(i, 2, *(level)) with { drop = _ : @(1), (abs density) : *; }; process = rain ( hslider( v:rain/density , 300, 0, 1000, 1) / 1000, hslider( v:rain/volume , 0.5, 0, 1, 0.01) ); Try it Yourself >>","title":"rain"},{"location":"examples/gameaudio/#wind","text":"//----------------------wind-------------------------- // A very simple wind simulator, based on a filtered white noise // // #### Usage // // // wind(f) : _ // // // Where: // // * f: is the force of the wind: between 0 and 1 // //---------------------------------------------------------- import( stdfaust.lib ); wind(force) = no.multinoise(2) : par(i, 2, ve.moog_vcf_2bn(force,freq)) : par(i, 2, *(force)) with { freq = (force*87)+1 : ba.pianokey2hz; }; process = wind ( hslider( v:wind/force ,0.66,0,1,0.01) : si.smooth (0.997) ); Try it Yourself >>","title":"wind"},{"location":"examples/generator/","text":"generator filterOsc declare name filterOSC ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Simple application demoing filter based oscillators. ; import( stdfaust.lib ); process = dm.oscrs_demo; Try it Yourself >> noise // WARNING: This a legacy example based on a deprecated library . Check noises.lib // for more accurate examples of noise functions declare name Noise ; declare version 1.1 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2009 ; //----------------------------------------------------------------- // Noise generator and demo file for the Faust math documentation //----------------------------------------------------------------- mdoc \\section{Presentation of the noise.dsp Faust program} This program describes a white noise generator with an interactive volume, using a random function. \\subsection{The random function} The \\texttt{random} function describes a generator of random numbers, which equation follows. You should notice hereby the use of an integer arithmetic on 32 bits, relying on integer wrapping for big numbers. equation random /equation \\subsection{The noise function} The white noise then corresponds to: equation noise /equation /mdoc random = +(12345)~*(1103515245); noise = random/2147483647.0; mdoc \\subsection{Just add a user interface element to play volume!} Endly, the sound level of this program is controlled by a user slider, which gives the following equation: equation process /equation /mdoc mdoc \\section{Block-diagram schema of process} This process is illustrated on figure 1. diagram process /diagram /mdoc process = noise * vslider( Volume[style:knob][acc: 0 0 -10 0 10] , 0.5, 0, 1, 0.1); mdoc \\section{Notice of this documentation} You might be careful of certain information and naming conventions used in this documentation: notice/ \\section{Listing of the input code} The following listing shows the input Faust code, parsed to compile this mathematical documentation. listing/ /mdoc Try it Yourself >> noiseMetadata // WARNING: This a legacy example based on a deprecated library . Check noises.lib // for more accurate examples of noise functions mdoc \\title{ metadata name /metadata } \\author{ metadata author /metadata } \\date{\\today} \\maketitle \\begin{tabular}{ll} \\hline \\textbf{name} metadata name /metadata \\\\ \\textbf{version} metadata version /metadata \\\\ \\textbf{author} metadata author /metadata \\\\ \\textbf{license} metadata license /metadata \\\\ \\textbf{copyright} metadata copyright /metadata \\\\ \\hline \\end{tabular} \\bigskip /mdoc //----------------------------------------------------------------- // Noise generator and demo file for the Faust math documentation //----------------------------------------------------------------- declare name noiseMetadata ; // avoid same name as in noise.dsp declare version 1.1 ; declare author Grame ; declare author Yghe ; declare license BSD ; declare copyright (c)GRAME 2009 ; mdoc \\section{Presentation of the noise.dsp Faust program} This program describes a white noise generator with an interactive volume, using a random function. \\subsection{The random function} /mdoc random = +(12345)~*(1103515245); mdoc The \\texttt{random} function describes a generator of random numbers, which equation follows. You should notice hereby the use of an integer arithmetic on 32 bits, relying on integer wrapping for big numbers. equation random /equation \\subsection{The noise function} /mdoc noise = random/2147483647.0; mdoc The white noise then corresponds to: equation noise /equation \\subsection{Just add a user interface element to play volume!} /mdoc process = noise * vslider( Volume[style:knob] , 0, 0, 1, 0.1); mdoc Endly, the sound level of this program is controlled by a user slider, which gives the following equation: equation process /equation \\section{Block-diagram schema of process} This process is illustrated on figure 1. diagram process /diagram \\section{Notice of this documentation} You might be careful of certain information and naming conventions used in this documentation: notice / \\section{Listing of the input code} The following listing shows the input Faust code, parsed to compile this mathematical documentation. listing mdoctags= false dependencies= false distributed= false / /mdoc Try it Yourself >> osc declare name osc ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2009 ; //----------------------------------------------- // Sinusoidal Oscillator //----------------------------------------------- import( stdfaust.lib ); vol = hslider( volume [unit:dB] , 0, -96, 0, 0.1) : ba.db2linear : si.smoo ; freq = hslider( freq [unit:Hz] , 1000, 20, 24000, 1); process = vgroup( Oscillator , os.osc(freq) * vol); Try it Yourself >> osci declare name osci ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2009 ; //----------------------------------------------- // Sinusoidal Oscillator // (with linear interpolation) //----------------------------------------------- import( stdfaust.lib ); vol = hslider( volume [unit:dB] , 0, -96, 0, 0.1) : ba.db2linear : si.smoo ; freq = hslider( freq [unit:Hz] , 1000, 20, 24000, 1); process = vgroup( Oscillator , os.osci(freq) * vol); Try it Yourself >> sawtoothLab declare name sawtoothLab ; declare version 0.0 ; declare author JOS, revised by RM ; declare description An application demonstrating the different sawtooth oscillators of Faust. ; import( stdfaust.lib ); process = dm.sawtooth_demo; Try it Yourself >> virtualAnalog declare name VirtualAnalog ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Virtual analog oscillator demo application. ; import( stdfaust.lib ); process = dm.virtual_analog_oscillator_demo; Try it Yourself >> virtualAnalogLab declare name virtualAnalogLab ; import( stdfaust.lib ); process = vgroup( [1] , dm.virtual_analog_oscillator_demo) : vgroup( [2] , dm.moog_vcf_demo) : vgroup( [3] , dm.spectral_level_demo) // See also: vgroup( [3] , dm.fft_spectral_level_demo(32)) : _,_; Try it Yourself >>","title":" generator "},{"location":"examples/generator/#generator","text":"","title":"generator"},{"location":"examples/generator/#filterosc","text":"declare name filterOSC ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Simple application demoing filter based oscillators. ; import( stdfaust.lib ); process = dm.oscrs_demo; Try it Yourself >>","title":"filterOsc"},{"location":"examples/generator/#noise","text":"// WARNING: This a legacy example based on a deprecated library . Check noises.lib // for more accurate examples of noise functions declare name Noise ; declare version 1.1 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2009 ; //----------------------------------------------------------------- // Noise generator and demo file for the Faust math documentation //----------------------------------------------------------------- mdoc \\section{Presentation of the noise.dsp Faust program} This program describes a white noise generator with an interactive volume, using a random function. \\subsection{The random function} The \\texttt{random} function describes a generator of random numbers, which equation follows. You should notice hereby the use of an integer arithmetic on 32 bits, relying on integer wrapping for big numbers. equation random /equation \\subsection{The noise function} The white noise then corresponds to: equation noise /equation /mdoc random = +(12345)~*(1103515245); noise = random/2147483647.0; mdoc \\subsection{Just add a user interface element to play volume!} Endly, the sound level of this program is controlled by a user slider, which gives the following equation: equation process /equation /mdoc mdoc \\section{Block-diagram schema of process} This process is illustrated on figure 1. diagram process /diagram /mdoc process = noise * vslider( Volume[style:knob][acc: 0 0 -10 0 10] , 0.5, 0, 1, 0.1); mdoc \\section{Notice of this documentation} You might be careful of certain information and naming conventions used in this documentation: notice/ \\section{Listing of the input code} The following listing shows the input Faust code, parsed to compile this mathematical documentation. listing/ /mdoc Try it Yourself >>","title":"noise"},{"location":"examples/generator/#noisemetadata","text":"// WARNING: This a legacy example based on a deprecated library . Check noises.lib // for more accurate examples of noise functions mdoc \\title{ metadata name /metadata } \\author{ metadata author /metadata } \\date{\\today} \\maketitle \\begin{tabular}{ll} \\hline \\textbf{name} metadata name /metadata \\\\ \\textbf{version} metadata version /metadata \\\\ \\textbf{author} metadata author /metadata \\\\ \\textbf{license} metadata license /metadata \\\\ \\textbf{copyright} metadata copyright /metadata \\\\ \\hline \\end{tabular} \\bigskip /mdoc //----------------------------------------------------------------- // Noise generator and demo file for the Faust math documentation //----------------------------------------------------------------- declare name noiseMetadata ; // avoid same name as in noise.dsp declare version 1.1 ; declare author Grame ; declare author Yghe ; declare license BSD ; declare copyright (c)GRAME 2009 ; mdoc \\section{Presentation of the noise.dsp Faust program} This program describes a white noise generator with an interactive volume, using a random function. \\subsection{The random function} /mdoc random = +(12345)~*(1103515245); mdoc The \\texttt{random} function describes a generator of random numbers, which equation follows. You should notice hereby the use of an integer arithmetic on 32 bits, relying on integer wrapping for big numbers. equation random /equation \\subsection{The noise function} /mdoc noise = random/2147483647.0; mdoc The white noise then corresponds to: equation noise /equation \\subsection{Just add a user interface element to play volume!} /mdoc process = noise * vslider( Volume[style:knob] , 0, 0, 1, 0.1); mdoc Endly, the sound level of this program is controlled by a user slider, which gives the following equation: equation process /equation \\section{Block-diagram schema of process} This process is illustrated on figure 1. diagram process /diagram \\section{Notice of this documentation} You might be careful of certain information and naming conventions used in this documentation: notice / \\section{Listing of the input code} The following listing shows the input Faust code, parsed to compile this mathematical documentation. listing mdoctags= false dependencies= false distributed= false / /mdoc Try it Yourself >>","title":"noiseMetadata"},{"location":"examples/generator/#osc","text":"declare name osc ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2009 ; //----------------------------------------------- // Sinusoidal Oscillator //----------------------------------------------- import( stdfaust.lib ); vol = hslider( volume [unit:dB] , 0, -96, 0, 0.1) : ba.db2linear : si.smoo ; freq = hslider( freq [unit:Hz] , 1000, 20, 24000, 1); process = vgroup( Oscillator , os.osc(freq) * vol); Try it Yourself >>","title":"osc"},{"location":"examples/generator/#osci","text":"declare name osci ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2009 ; //----------------------------------------------- // Sinusoidal Oscillator // (with linear interpolation) //----------------------------------------------- import( stdfaust.lib ); vol = hslider( volume [unit:dB] , 0, -96, 0, 0.1) : ba.db2linear : si.smoo ; freq = hslider( freq [unit:Hz] , 1000, 20, 24000, 1); process = vgroup( Oscillator , os.osci(freq) * vol); Try it Yourself >>","title":"osci"},{"location":"examples/generator/#sawtoothlab","text":"declare name sawtoothLab ; declare version 0.0 ; declare author JOS, revised by RM ; declare description An application demonstrating the different sawtooth oscillators of Faust. ; import( stdfaust.lib ); process = dm.sawtooth_demo; Try it Yourself >>","title":"sawtoothLab"},{"location":"examples/generator/#virtualanalog","text":"declare name VirtualAnalog ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Virtual analog oscillator demo application. ; import( stdfaust.lib ); process = dm.virtual_analog_oscillator_demo; Try it Yourself >>","title":"virtualAnalog"},{"location":"examples/generator/#virtualanaloglab","text":"declare name virtualAnalogLab ; import( stdfaust.lib ); process = vgroup( [1] , dm.virtual_analog_oscillator_demo) : vgroup( [2] , dm.moog_vcf_demo) : vgroup( [3] , dm.spectral_level_demo) // See also: vgroup( [3] , dm.fft_spectral_level_demo(32)) : _,_; Try it Yourself >>","title":"virtualAnalogLab"},{"location":"examples/misc/","text":"misc capture declare name capture ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------- // Capture : record up to 8s of sound and // playback the recorded sound in loop //------------------------------------------------- import( stdfaust.lib ); B = button( Capture ); // Capture sound while pressed I = int(B); // convert button signal from float to integer R = (I-I') = 0; // Reset capture when button is pressed D = (+(I):*(R))~_; // Compute capture duration while button is pressed: 0..NNNN0..MMM capture = *(B) : (+ : de.delay(8*65536, D-1)) ~ *(1.0-B) ; level = hslider( level (db) , 0, -96, 4, 0.1) : ba.db2linear : si.smoo; process = vgroup( Audio Capture , capture : *(level) ) ; Try it Yourself >> matrix declare name matrix ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //----------------------------------------------- // Audio Matrix : N inputs x M outputs //----------------------------------------------- import( stdfaust.lib ); Fader(in) = ba.db2linear(vslider( Input %in , -10, -96, 4, 0.1)); Mixer(N,out) = hgroup( Output %out , par(in, N, *(Fader(in)) ) : _ ); Matrix(N,M) = tgroup( Matrix %N x %M , par(in, N, _) : par(out, M, Mixer(N, out))); process = Matrix(8, 8); Try it Yourself >> midiTester declare name midiTester ; declare version 1.0 ; declare author Vincent Rateau, GRAME ; declare license GPL v3 ; declare reference www.sonejo.net ; // FAUST MIDI TESTER process = _*0, (vgroup( FAUST MIDI TESTER , hgroup( [1] , controltester, noteontester, noteofftester, midiclocktester), hgroup( [2] , kattester, pctester, chattester, pitchwheeltester) : _)) : attach; /////////////////////////// //Ctrl tester (ctrl ): tester(midi in, midi out) controltester = vgroup( CTRL IN/OUT , valuetest(50,51), booltest(100,101)) with{ valuetest(i,o) = hslider( Ctrl Value IN (Ctrl %i) [midi:ctrl %i] , 60, 0, 127, 1) : hbargraph( Ctrl Value OUT (Ctrl %o) [midi:ctrl %o] , 0, 127); booltest(i,o) = checkbox( Ctrl Bool IN (Ctrl %i) [midi:ctrl %i] ) : hbargraph( Ctrl Bool OUT (Ctrl %o) [midi:ctrl %o] , 0, 1); }; //Note tester (keyon) : tester(midi in, midi out) noteontester = vgroup( NOTE ON IN/OUT , valuetest(50,51), booltest(100,101)) with{ valuetest(i,o) = hslider( NoteOn Value IN (Note %i) [midi:keyon %i] , 60, 0, 127, 1) : hbargraph( NoteOn Value OUT (Note %o) [midi:keyon %o] , 0, 127); booltest(i,o) = checkbox( NoteOn Bool IN (Note %i) [midi:keyon %i] ) : hbargraph( NoteOn Bool OUT (Note %o) [midi:keyon %o] , 0, 1); }; //Note tester (keyoff) : tester(midi in, midi out) noteofftester = vgroup( NOTE OFF IN/OUT , valuetest(50,51), booltest(100,101)) with{ valuetest(i,o) = hslider( NoteOff Value IN (Note %i) [midi:keyoff %i] , 60, 0, 127, 1) : hbargraph( NoteOff Value OUT (Note %o) [midi:keyoff %o] , 0, 127); booltest(i,o) = checkbox( NoteOff Bool IN (Note %i) [midi:keyoff %i] ) : hbargraph( NoteOff Bool OUT (Note %o) [midi:keyoff %o] , 0, 1); }; //Midisync tester midiclocktester = vgroup( MIDI SYNC (IN) , clock, startstop) with{ clock = checkbox( MIDI clock signal [midi:clock] ); startstop = checkbox( MIDI START/STOP [midi:start] [midi:stop] ); }; //Key Aftertouch tester (keypress) : tester(midi in, midi out) kattester = vgroup( KEY AFTERTOUCH (KAT) IN/OUT ,valuetest(50,51), booltest(100,101)) with{ valuetest(i,o) = hslider( Note KAT Value IN (Note %i) [midi:keypress %i] , 60, 0, 127, 1) : hbargraph( Note KAT Value OUT (Note %o) [midi:keypress %o] , 0, 127); booltest(i,o) = checkbox( Note KAT Bool IN (Note %i) [midi:keypress %i] ) : hbargraph( Note KAT Bool OUT (Note %o) [midi:keypress %o] , 0, 1); }; //ProgramChange tester (pgm) : tester(midi in, midi out) pctester = vgroup( PROGRAM CHANGE (PC) IN/OUT ,valuetest(50,51), booltest(100,101)) with{ valuetest(i,o) = hslider( ProgramChange Value IN (PC %i) [midi:pgm %i] , 60, 0, 127, 1) : hbargraph( ProgramChange Value OUT (PC %o) [midi:pgm %o] , 0, 127); booltest(i,o) = checkbox( ProgramChange Bool IN (PC %i) [midi:pgm %i] ) : hbargraph( ProgramChange Bool OUT (PC %o) [midi:pgm %o] , 0, 1); }; //Channel Aftertourch tester (chanpress) : tester(midi in, midi out) chattester = vgroup( CHANNEL AFTERTOUCH (CHAT) IN/OUT ,valuetest(50,51), booltest(100,101)) with{ valuetest(i,o) = hslider( Note CHAT Value IN (Note %i) [midi:chanpress %i] , 60, 0, 127, 1) : hbargraph( Note CHAT Value OUT (Note %o) [midi:chanpress %o] , 0, 127); booltest(i,o) = checkbox( Note CHAT Bool IN (Note %i) [midi:chanpress %i] ) : hbargraph( Note CHAT Bool OUT (Note %o) [midi:chanpress %o] , 0, 1); }; //Pitchwheel tester (pitchwheel) : tester(midi in, midi out) pitchwheeltester = vgroup( PITCHWHEEL IN/OUT ,valuetest, booltest) with{ valuetest = hslider( Pitchwheel Value IN [midi:pitchwheel] , 0, -8192, 8191, 1) : hbargraph( Pitchwheel Value OUT[midi:pitchwheel] , -8192, 8191); booltest = checkbox( Pitchwheel Bool IN [midi:pitchwheel] ) : hbargraph( Pitchwheel Bool OUT [midi:pitchwheel] , 0, 1); }; Try it Yourself >> switcher declare name switcher ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2007 ; //----------------------------------------------- // Switch between two stereo sources. // Useful to compare these two sources // The parameter c\\in{0,1} indicates the // channels to select //----------------------------------------------- switch(c,x0,x1,y0,y1) = sel(c,x0,y0), sel(c,x1,y1) with { sel(c,x,y) = (1-c)*x + c*y; }; process = switch(hslider( source 0 - source 1 ,0,0,1,1)); Try it Yourself >> tester2 declare name tester2 ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2014 ; //----------------------------------------------- // Stereo Audio Tester : send a test signal (sine, // noise, pink) on a stereo channel //----------------------------------------------- import( stdfaust.lib ); pink = f : (+ ~ g) with { f(x) = 0.04957526213389*x - 0.06305581334498*x' + 0.01483220320740*x''; g(x) = 1.80116083982126*x - 0.80257737639225*x'; }; // User interface //---------------- transition(n) = \\(old,new).(ba.if(old new, min(old+1.0/n,new), max(old-1.0/n,new))) ~ _; vol = hslider( [2] volume [unit:dB] , -96, -96, 0, 1): ba.db2linear : si.smoo; freq = hslider( [1] freq [unit:Hz][scale:log] , 440, 40, 20000, 1); wave = nentry( [3] signal [style:menu{'white noise':0;'pink noise':1;'sine':2}] , 0, 0, 2, 1) : int; dest = nentry( [4] channel [style:radio{'none':0;'left':1;'right':2;'both':3}] , 0, 0, 3, 1) : int; testsignal = no.noise, pink(no.noise), os.osci(freq): select3(wave); process = vgroup( Stereo Audio Tester , testsignal*vol : par(i, 2, *((dest (i+1)) != 0 : transition(4410))) ); Try it Yourself >> tester declare name tester ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //----------------------------------------------- // Tester : tests louspeakers // Send a test signal( sine, noise, pink) to one // of 8 loudspeakers //----------------------------------------------- import( stdfaust.lib ); // TODO: this should be rewritten with the pink noise function of noises.lib pink = f : (+ ~ g) with { f(x) = 0.04957526213389*x - 0.06305581334498*x' + 0.01483220320740*x''; g(x) = 1.80116083982126*x - 0.80257737639225*x'; }; // User interface //---------------- vol = hslider( [2] volume [unit:dB] , -96, -96, 0, 1): ba.db2linear : si.smoo; freq = hslider( [1] freq [unit:Hz] , 1000, 10, 20000, 1); dest = hslider( [3] destination , 0, 0, 8, 1); testsignal = os.osci(freq)*checkbox( sine wave ) + no.noise * checkbox( white noise ) + pink(no.noise) * ba.db2linear(20) * checkbox( pink noise ); process = vgroup( Audio Tester , testsignal*vol : par(i, 8, *(dest==i)) ); Try it Yourself >> UITester declare name UITester ; declare version 1.0 ; declare author O. Guillerminet ; declare license BSD ; declare copyright (c) O. Guillerminet 2012 ; vbox = vgroup( vbox , checkbox( check1 ), checkbox( check2 ), nentry( knob0[style:knob] , 60, 0, 127, 0.1)); sliders = hgroup( sliders , vslider( vslider1 , 60, 0, 127, 0.1), vslider( vslider2 , 60, 0, 127, 0.1), vslider( vslider3 , 60, 0, 127, 0.1)); knobs = hgroup( knobs , vslider( knob1[style:knob] , 60, 0, 127, 0.1), vslider( knob2[style:knob] , 60, 0, 127, 0.1), vslider( knob3[style:knob] , 60, 0, 127, 0.1)); smallhbox1 = hgroup( small box 1 , vslider( vslider5 [unit:Hz] , 60, 0, 127, 0.1), vslider( vslider6 [unit:Hz] , 60, 0, 127, 0.1), vslider( knob4[style:knob] , 60, 0, 127, 0.1), nentry( num1 [unit:f] , 60, 0, 127, 0.1), vbargraph( vbar1 , 0, 127)); smallhbox2 = hgroup( small box 2 , vslider( vslider7 [unit:Hz] , 60, 0, 127, 0.1), vslider( vslider8 [unit:Hz] , 60, 0, 127, 0.1), vslider( knob5[style:knob] , 60, 0, 127, 0.1), nentry( num2 [unit:f] , 60, 0, 127, 0.1), vbargraph( vbar2 , 0, 127)); smallhbox3 = hgroup( small box 3 , vslider( vslider9 [unit:Hz] , 60, 0, 127, 0.1), vslider( vslider10 [unit:m] , 60, 0, 127, 0.1), vslider( knob6[style:knob] , 60, 0, 127, 0.1), nentry( num3 [unit:f] , 60, 0, 127, 0.1), vbargraph( vbar3 , 0, 127)); subhbox1 = hgroup( sub box 1 , smallhbox2, smallhbox3); vmisc = vgroup( vmisc , vslider( vslider4 [unit:Hz] , 60, 0, 127, 0.1), button( button ), hslider( hslider [unit:Hz] , 60, 0, 127, 0.1), smallhbox1, subhbox1, hbargraph( hbar , 0, 127)); hmisc = hgroup( hmisc , vslider( vslider4 [unit:f] , 60, 0, 127, 0.1), button( button ), hslider( hslider , 60, 0, 127, 0.1), nentry( num [unit:f] , 60, 0, 127, 0.1), vbargraph( vbar , 0, 127), hbargraph( hbar , 0, 127)); //------------------------- Process -------------------------------- process = tgroup( grp 1 , vbox, sliders, knobs, vmisc, hmisc); Try it Yourself >>","title":" misc "},{"location":"examples/misc/#misc","text":"","title":"misc"},{"location":"examples/misc/#capture","text":"declare name capture ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------- // Capture : record up to 8s of sound and // playback the recorded sound in loop //------------------------------------------------- import( stdfaust.lib ); B = button( Capture ); // Capture sound while pressed I = int(B); // convert button signal from float to integer R = (I-I') = 0; // Reset capture when button is pressed D = (+(I):*(R))~_; // Compute capture duration while button is pressed: 0..NNNN0..MMM capture = *(B) : (+ : de.delay(8*65536, D-1)) ~ *(1.0-B) ; level = hslider( level (db) , 0, -96, 4, 0.1) : ba.db2linear : si.smoo; process = vgroup( Audio Capture , capture : *(level) ) ; Try it Yourself >>","title":"capture"},{"location":"examples/misc/#matrix","text":"declare name matrix ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //----------------------------------------------- // Audio Matrix : N inputs x M outputs //----------------------------------------------- import( stdfaust.lib ); Fader(in) = ba.db2linear(vslider( Input %in , -10, -96, 4, 0.1)); Mixer(N,out) = hgroup( Output %out , par(in, N, *(Fader(in)) ) : _ ); Matrix(N,M) = tgroup( Matrix %N x %M , par(in, N, _) : par(out, M, Mixer(N, out))); process = Matrix(8, 8); Try it Yourself >>","title":"matrix"},{"location":"examples/misc/#miditester","text":"declare name midiTester ; declare version 1.0 ; declare author Vincent Rateau, GRAME ; declare license GPL v3 ; declare reference www.sonejo.net ; // FAUST MIDI TESTER process = _*0, (vgroup( FAUST MIDI TESTER , hgroup( [1] , controltester, noteontester, noteofftester, midiclocktester), hgroup( [2] , kattester, pctester, chattester, pitchwheeltester) : _)) : attach; /////////////////////////// //Ctrl tester (ctrl ): tester(midi in, midi out) controltester = vgroup( CTRL IN/OUT , valuetest(50,51), booltest(100,101)) with{ valuetest(i,o) = hslider( Ctrl Value IN (Ctrl %i) [midi:ctrl %i] , 60, 0, 127, 1) : hbargraph( Ctrl Value OUT (Ctrl %o) [midi:ctrl %o] , 0, 127); booltest(i,o) = checkbox( Ctrl Bool IN (Ctrl %i) [midi:ctrl %i] ) : hbargraph( Ctrl Bool OUT (Ctrl %o) [midi:ctrl %o] , 0, 1); }; //Note tester (keyon) : tester(midi in, midi out) noteontester = vgroup( NOTE ON IN/OUT , valuetest(50,51), booltest(100,101)) with{ valuetest(i,o) = hslider( NoteOn Value IN (Note %i) [midi:keyon %i] , 60, 0, 127, 1) : hbargraph( NoteOn Value OUT (Note %o) [midi:keyon %o] , 0, 127); booltest(i,o) = checkbox( NoteOn Bool IN (Note %i) [midi:keyon %i] ) : hbargraph( NoteOn Bool OUT (Note %o) [midi:keyon %o] , 0, 1); }; //Note tester (keyoff) : tester(midi in, midi out) noteofftester = vgroup( NOTE OFF IN/OUT , valuetest(50,51), booltest(100,101)) with{ valuetest(i,o) = hslider( NoteOff Value IN (Note %i) [midi:keyoff %i] , 60, 0, 127, 1) : hbargraph( NoteOff Value OUT (Note %o) [midi:keyoff %o] , 0, 127); booltest(i,o) = checkbox( NoteOff Bool IN (Note %i) [midi:keyoff %i] ) : hbargraph( NoteOff Bool OUT (Note %o) [midi:keyoff %o] , 0, 1); }; //Midisync tester midiclocktester = vgroup( MIDI SYNC (IN) , clock, startstop) with{ clock = checkbox( MIDI clock signal [midi:clock] ); startstop = checkbox( MIDI START/STOP [midi:start] [midi:stop] ); }; //Key Aftertouch tester (keypress) : tester(midi in, midi out) kattester = vgroup( KEY AFTERTOUCH (KAT) IN/OUT ,valuetest(50,51), booltest(100,101)) with{ valuetest(i,o) = hslider( Note KAT Value IN (Note %i) [midi:keypress %i] , 60, 0, 127, 1) : hbargraph( Note KAT Value OUT (Note %o) [midi:keypress %o] , 0, 127); booltest(i,o) = checkbox( Note KAT Bool IN (Note %i) [midi:keypress %i] ) : hbargraph( Note KAT Bool OUT (Note %o) [midi:keypress %o] , 0, 1); }; //ProgramChange tester (pgm) : tester(midi in, midi out) pctester = vgroup( PROGRAM CHANGE (PC) IN/OUT ,valuetest(50,51), booltest(100,101)) with{ valuetest(i,o) = hslider( ProgramChange Value IN (PC %i) [midi:pgm %i] , 60, 0, 127, 1) : hbargraph( ProgramChange Value OUT (PC %o) [midi:pgm %o] , 0, 127); booltest(i,o) = checkbox( ProgramChange Bool IN (PC %i) [midi:pgm %i] ) : hbargraph( ProgramChange Bool OUT (PC %o) [midi:pgm %o] , 0, 1); }; //Channel Aftertourch tester (chanpress) : tester(midi in, midi out) chattester = vgroup( CHANNEL AFTERTOUCH (CHAT) IN/OUT ,valuetest(50,51), booltest(100,101)) with{ valuetest(i,o) = hslider( Note CHAT Value IN (Note %i) [midi:chanpress %i] , 60, 0, 127, 1) : hbargraph( Note CHAT Value OUT (Note %o) [midi:chanpress %o] , 0, 127); booltest(i,o) = checkbox( Note CHAT Bool IN (Note %i) [midi:chanpress %i] ) : hbargraph( Note CHAT Bool OUT (Note %o) [midi:chanpress %o] , 0, 1); }; //Pitchwheel tester (pitchwheel) : tester(midi in, midi out) pitchwheeltester = vgroup( PITCHWHEEL IN/OUT ,valuetest, booltest) with{ valuetest = hslider( Pitchwheel Value IN [midi:pitchwheel] , 0, -8192, 8191, 1) : hbargraph( Pitchwheel Value OUT[midi:pitchwheel] , -8192, 8191); booltest = checkbox( Pitchwheel Bool IN [midi:pitchwheel] ) : hbargraph( Pitchwheel Bool OUT [midi:pitchwheel] , 0, 1); }; Try it Yourself >>","title":"midiTester"},{"location":"examples/misc/#switcher","text":"declare name switcher ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2007 ; //----------------------------------------------- // Switch between two stereo sources. // Useful to compare these two sources // The parameter c\\in{0,1} indicates the // channels to select //----------------------------------------------- switch(c,x0,x1,y0,y1) = sel(c,x0,y0), sel(c,x1,y1) with { sel(c,x,y) = (1-c)*x + c*y; }; process = switch(hslider( source 0 - source 1 ,0,0,1,1)); Try it Yourself >>","title":"switcher"},{"location":"examples/misc/#tester2","text":"declare name tester2 ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2014 ; //----------------------------------------------- // Stereo Audio Tester : send a test signal (sine, // noise, pink) on a stereo channel //----------------------------------------------- import( stdfaust.lib ); pink = f : (+ ~ g) with { f(x) = 0.04957526213389*x - 0.06305581334498*x' + 0.01483220320740*x''; g(x) = 1.80116083982126*x - 0.80257737639225*x'; }; // User interface //---------------- transition(n) = \\(old,new).(ba.if(old new, min(old+1.0/n,new), max(old-1.0/n,new))) ~ _; vol = hslider( [2] volume [unit:dB] , -96, -96, 0, 1): ba.db2linear : si.smoo; freq = hslider( [1] freq [unit:Hz][scale:log] , 440, 40, 20000, 1); wave = nentry( [3] signal [style:menu{'white noise':0;'pink noise':1;'sine':2}] , 0, 0, 2, 1) : int; dest = nentry( [4] channel [style:radio{'none':0;'left':1;'right':2;'both':3}] , 0, 0, 3, 1) : int; testsignal = no.noise, pink(no.noise), os.osci(freq): select3(wave); process = vgroup( Stereo Audio Tester , testsignal*vol : par(i, 2, *((dest (i+1)) != 0 : transition(4410))) ); Try it Yourself >>","title":"tester2"},{"location":"examples/misc/#tester","text":"declare name tester ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //----------------------------------------------- // Tester : tests louspeakers // Send a test signal( sine, noise, pink) to one // of 8 loudspeakers //----------------------------------------------- import( stdfaust.lib ); // TODO: this should be rewritten with the pink noise function of noises.lib pink = f : (+ ~ g) with { f(x) = 0.04957526213389*x - 0.06305581334498*x' + 0.01483220320740*x''; g(x) = 1.80116083982126*x - 0.80257737639225*x'; }; // User interface //---------------- vol = hslider( [2] volume [unit:dB] , -96, -96, 0, 1): ba.db2linear : si.smoo; freq = hslider( [1] freq [unit:Hz] , 1000, 10, 20000, 1); dest = hslider( [3] destination , 0, 0, 8, 1); testsignal = os.osci(freq)*checkbox( sine wave ) + no.noise * checkbox( white noise ) + pink(no.noise) * ba.db2linear(20) * checkbox( pink noise ); process = vgroup( Audio Tester , testsignal*vol : par(i, 8, *(dest==i)) ); Try it Yourself >>","title":"tester"},{"location":"examples/misc/#uitester","text":"declare name UITester ; declare version 1.0 ; declare author O. Guillerminet ; declare license BSD ; declare copyright (c) O. Guillerminet 2012 ; vbox = vgroup( vbox , checkbox( check1 ), checkbox( check2 ), nentry( knob0[style:knob] , 60, 0, 127, 0.1)); sliders = hgroup( sliders , vslider( vslider1 , 60, 0, 127, 0.1), vslider( vslider2 , 60, 0, 127, 0.1), vslider( vslider3 , 60, 0, 127, 0.1)); knobs = hgroup( knobs , vslider( knob1[style:knob] , 60, 0, 127, 0.1), vslider( knob2[style:knob] , 60, 0, 127, 0.1), vslider( knob3[style:knob] , 60, 0, 127, 0.1)); smallhbox1 = hgroup( small box 1 , vslider( vslider5 [unit:Hz] , 60, 0, 127, 0.1), vslider( vslider6 [unit:Hz] , 60, 0, 127, 0.1), vslider( knob4[style:knob] , 60, 0, 127, 0.1), nentry( num1 [unit:f] , 60, 0, 127, 0.1), vbargraph( vbar1 , 0, 127)); smallhbox2 = hgroup( small box 2 , vslider( vslider7 [unit:Hz] , 60, 0, 127, 0.1), vslider( vslider8 [unit:Hz] , 60, 0, 127, 0.1), vslider( knob5[style:knob] , 60, 0, 127, 0.1), nentry( num2 [unit:f] , 60, 0, 127, 0.1), vbargraph( vbar2 , 0, 127)); smallhbox3 = hgroup( small box 3 , vslider( vslider9 [unit:Hz] , 60, 0, 127, 0.1), vslider( vslider10 [unit:m] , 60, 0, 127, 0.1), vslider( knob6[style:knob] , 60, 0, 127, 0.1), nentry( num3 [unit:f] , 60, 0, 127, 0.1), vbargraph( vbar3 , 0, 127)); subhbox1 = hgroup( sub box 1 , smallhbox2, smallhbox3); vmisc = vgroup( vmisc , vslider( vslider4 [unit:Hz] , 60, 0, 127, 0.1), button( button ), hslider( hslider [unit:Hz] , 60, 0, 127, 0.1), smallhbox1, subhbox1, hbargraph( hbar , 0, 127)); hmisc = hgroup( hmisc , vslider( vslider4 [unit:f] , 60, 0, 127, 0.1), button( button ), hslider( hslider , 60, 0, 127, 0.1), nentry( num [unit:f] , 60, 0, 127, 0.1), vbargraph( vbar , 0, 127), hbargraph( hbar , 0, 127)); //------------------------- Process -------------------------------- process = tgroup( grp 1 , vbox, sliders, knobs, vmisc, hmisc); Try it Yourself >>","title":"UITester"},{"location":"examples/phasing/","text":"phasing flanger declare name flanger ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Flanger effect application. ; import( stdfaust.lib ); process = dm.flanger_demo; Try it Yourself >> phaser declare name phaser ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Phaser demo application. ; import( stdfaust.lib ); process = dm.phaser2_demo; Try it Yourself >> phaserFlangerLab declare name phaserFlangerLab ; import( stdfaust.lib ); //process = ol.sawtooth_demo : // el.flanger_demo : el.phaser2_demo : fl.spectral_level_demo : _,_; fx_stack = vgroup( [1] , dm.sawtooth_demo) : vgroup( [2] , dm.flanger_demo) : vgroup( [3] , dm.phaser2_demo); level_viewer(x,y) = attach(x, vgroup( [4] , dm.spectral_level_demo(x+y))),y; process = fx_stack : level_viewer; Try it Yourself >>","title":" phasing "},{"location":"examples/phasing/#phasing","text":"","title":"phasing"},{"location":"examples/phasing/#flanger","text":"declare name flanger ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Flanger effect application. ; import( stdfaust.lib ); process = dm.flanger_demo; Try it Yourself >>","title":"flanger"},{"location":"examples/phasing/#phaser","text":"declare name phaser ; declare version 0.0 ; declare author JOS, revised by RM ; declare description Phaser demo application. ; import( stdfaust.lib ); process = dm.phaser2_demo; Try it Yourself >>","title":"phaser"},{"location":"examples/phasing/#phaserflangerlab","text":"declare name phaserFlangerLab ; import( stdfaust.lib ); //process = ol.sawtooth_demo : // el.flanger_demo : el.phaser2_demo : fl.spectral_level_demo : _,_; fx_stack = vgroup( [1] , dm.sawtooth_demo) : vgroup( [2] , dm.flanger_demo) : vgroup( [3] , dm.phaser2_demo); level_viewer(x,y) = attach(x, vgroup( [4] , dm.spectral_level_demo(x+y))),y; process = fx_stack : level_viewer; Try it Yourself >>","title":"phaserFlangerLab"},{"location":"examples/physicalModeling/","text":"physicalModeling brass declare name Brass ; declare description Simple brass instrument physical model with physical parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.brass_ui : _,_; Try it Yourself >> brassMIDI declare name BrassMIDI ; declare description Simple MIDI-controllable brass instrument physical model with physical parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.brass_ui_MIDI : _,_; Try it Yourself >> churchBell declare name ChurchBell ; declare description Generic church bell physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.churchBell_ui : _,_; Try it Yourself >> clarinet declare name Clarinet ; declare description Simple clarinet physical model with physical parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.clarinet_ui : _,_; Try it Yourself >> clarinetMIDI declare name ClarinetMIDI ; declare description Simple MIDI-controllable clarinet physical model with physical parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.clarinet_ui_MIDI : _,_; Try it Yourself >> djembeMIDI declare name DjembeMIDI ; declare description Simple MIDI-controllable djembe physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.djembe_ui_MIDI : _,_; Try it Yourself >> elecGuitarMIDI declare name ElecGuitarMidi ; declare description Simple electric guitar model without effect chain. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); // TODO: We could potentially add an audio effect chain here process = pm.elecGuitar_ui_MIDI : _,_; Try it Yourself >> englishBell declare name EnglishChurchBell ; declare description English church bell physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.englishBell_ui : _,_; Try it Yourself >> flute declare name Flute ; declare description Simple flute physical model with physical parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.flute_ui : _,_; Try it Yourself >> fluteMIDI declare name FluteMIDI ; declare description Simple MIDI-controllable flute physical model with physical parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.flute_ui_MIDI : _,_; Try it Yourself >> frenchBell declare name FrenchChurchBell ; declare description French church bell physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.frenchBell_ui : _,_; Try it Yourself >> germanBell declare name GermanChurchBell ; declare description German church bell physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.germanBell_ui : _,_; Try it Yourself >> guitarMIDI declare name GuitarMidi ; declare description Simple acoustic guitar model with steel strings. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.guitar_ui_MIDI : _,_; Try it Yourself >> karplus declare name KarplusStrong ; declare description Simple call of the Karplus-Strong model for the Faust physical modeling library ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.ks_ui_MIDI : _,_; Try it Yourself >> marimbaMIDI // WARNING: this model is incomplete and is only here for testing purposes declare name MarimbaMIDI ; declare description Simple MIDI-controllable marimba physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.marimba_ui_MIDI : _,_; Try it Yourself >> modularInterpInstrMIDI declare name ModularInterpInstrMidi ; declare description String instrument with a modular body ; declare license MIT ; declare copyright (c)Romain Michon John Granzow, CCRMA (Stanford University), GRAME, University of Michigan ; import( stdfaust.lib ); process = pm.modularInterpInstr_ui_MIDI : _,_; Try it Yourself >> nylonGuitarMIDI declare name NylonGuitarMidi ; declare description Simple acoustic guitar model with nylon strings. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.nylonGuitar_ui_MIDI : _,_; Try it Yourself >> russianBell declare name RussianChurchBell ; declare description Russian church bell physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.russianBell_ui : _,_; Try it Yourself >> standardBell declare name StandardChurchBell ; declare description Standard church bell physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.standardBell_ui : _,_; Try it Yourself >> violin declare name Violin ; declare description Simple violin physical model controlled with continuous parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.violin_ui : _,_; Try it Yourself >> violinMIDI declare name ViolinMidi ; declare description Simple MIDI-controllable violin physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.violin_ui_MIDI : _,_; Try it Yourself >> vocalBP declare name Vocal BandPass ; declare description Simple source-filter vocal synthesizer. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.SFFormantModelBP_ui : _,_; Try it Yourself >> vocalBPMIDI declare name Vocal BandPass MIDI ; declare description Simple MIDI-controllable source-filter vocal synthesizer. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.SFFormantModelBP_ui_MIDI : _,_; Try it Yourself >> vocalFOF declare name Vocal FOF ; declare description FOF vocal synthesizer. ; declare license MIT ; declare copyright (c)Mike Olsen, CCRMA (Stanford University) ; import( stdfaust.lib ); process = pm.SFFormantModelFofSmooth_ui : _,_; Try it Yourself >> vocalFOFMIDI declare name Vocal FOF MIDI ; declare description MIDI-controllable FOF vocal synthesizer. ; declare license MIT ; declare copyright (c)Mike Olsen, CCRMA (Stanford University) ; import( stdfaust.lib ); process = pm.SFFormantModelFofSmooth_ui_MIDI : _,_; Try it Yourself >>","title":" physicalModeling "},{"location":"examples/physicalModeling/#physicalmodeling","text":"","title":"physicalModeling"},{"location":"examples/physicalModeling/#brass","text":"declare name Brass ; declare description Simple brass instrument physical model with physical parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.brass_ui : _,_; Try it Yourself >>","title":"brass"},{"location":"examples/physicalModeling/#brassmidi","text":"declare name BrassMIDI ; declare description Simple MIDI-controllable brass instrument physical model with physical parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.brass_ui_MIDI : _,_; Try it Yourself >>","title":"brassMIDI"},{"location":"examples/physicalModeling/#churchbell","text":"declare name ChurchBell ; declare description Generic church bell physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.churchBell_ui : _,_; Try it Yourself >>","title":"churchBell"},{"location":"examples/physicalModeling/#clarinet","text":"declare name Clarinet ; declare description Simple clarinet physical model with physical parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.clarinet_ui : _,_; Try it Yourself >>","title":"clarinet"},{"location":"examples/physicalModeling/#clarinetmidi","text":"declare name ClarinetMIDI ; declare description Simple MIDI-controllable clarinet physical model with physical parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.clarinet_ui_MIDI : _,_; Try it Yourself >>","title":"clarinetMIDI"},{"location":"examples/physicalModeling/#djembemidi","text":"declare name DjembeMIDI ; declare description Simple MIDI-controllable djembe physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.djembe_ui_MIDI : _,_; Try it Yourself >>","title":"djembeMIDI"},{"location":"examples/physicalModeling/#elecguitarmidi","text":"declare name ElecGuitarMidi ; declare description Simple electric guitar model without effect chain. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); // TODO: We could potentially add an audio effect chain here process = pm.elecGuitar_ui_MIDI : _,_; Try it Yourself >>","title":"elecGuitarMIDI"},{"location":"examples/physicalModeling/#englishbell","text":"declare name EnglishChurchBell ; declare description English church bell physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.englishBell_ui : _,_; Try it Yourself >>","title":"englishBell"},{"location":"examples/physicalModeling/#flute","text":"declare name Flute ; declare description Simple flute physical model with physical parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.flute_ui : _,_; Try it Yourself >>","title":"flute"},{"location":"examples/physicalModeling/#flutemidi","text":"declare name FluteMIDI ; declare description Simple MIDI-controllable flute physical model with physical parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.flute_ui_MIDI : _,_; Try it Yourself >>","title":"fluteMIDI"},{"location":"examples/physicalModeling/#frenchbell","text":"declare name FrenchChurchBell ; declare description French church bell physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.frenchBell_ui : _,_; Try it Yourself >>","title":"frenchBell"},{"location":"examples/physicalModeling/#germanbell","text":"declare name GermanChurchBell ; declare description German church bell physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.germanBell_ui : _,_; Try it Yourself >>","title":"germanBell"},{"location":"examples/physicalModeling/#guitarmidi","text":"declare name GuitarMidi ; declare description Simple acoustic guitar model with steel strings. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.guitar_ui_MIDI : _,_; Try it Yourself >>","title":"guitarMIDI"},{"location":"examples/physicalModeling/#karplus","text":"declare name KarplusStrong ; declare description Simple call of the Karplus-Strong model for the Faust physical modeling library ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.ks_ui_MIDI : _,_; Try it Yourself >>","title":"karplus"},{"location":"examples/physicalModeling/#marimbamidi","text":"// WARNING: this model is incomplete and is only here for testing purposes declare name MarimbaMIDI ; declare description Simple MIDI-controllable marimba physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.marimba_ui_MIDI : _,_; Try it Yourself >>","title":"marimbaMIDI"},{"location":"examples/physicalModeling/#modularinterpinstrmidi","text":"declare name ModularInterpInstrMidi ; declare description String instrument with a modular body ; declare license MIT ; declare copyright (c)Romain Michon John Granzow, CCRMA (Stanford University), GRAME, University of Michigan ; import( stdfaust.lib ); process = pm.modularInterpInstr_ui_MIDI : _,_; Try it Yourself >>","title":"modularInterpInstrMIDI"},{"location":"examples/physicalModeling/#nylonguitarmidi","text":"declare name NylonGuitarMidi ; declare description Simple acoustic guitar model with nylon strings. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.nylonGuitar_ui_MIDI : _,_; Try it Yourself >>","title":"nylonGuitarMIDI"},{"location":"examples/physicalModeling/#russianbell","text":"declare name RussianChurchBell ; declare description Russian church bell physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.russianBell_ui : _,_; Try it Yourself >>","title":"russianBell"},{"location":"examples/physicalModeling/#standardbell","text":"declare name StandardChurchBell ; declare description Standard church bell physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.standardBell_ui : _,_; Try it Yourself >>","title":"standardBell"},{"location":"examples/physicalModeling/#violin","text":"declare name Violin ; declare description Simple violin physical model controlled with continuous parameters. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.violin_ui : _,_; Try it Yourself >>","title":"violin"},{"location":"examples/physicalModeling/#violinmidi","text":"declare name ViolinMidi ; declare description Simple MIDI-controllable violin physical model. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.violin_ui_MIDI : _,_; Try it Yourself >>","title":"violinMIDI"},{"location":"examples/physicalModeling/#vocalbp","text":"declare name Vocal BandPass ; declare description Simple source-filter vocal synthesizer. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.SFFormantModelBP_ui : _,_; Try it Yourself >>","title":"vocalBP"},{"location":"examples/physicalModeling/#vocalbpmidi","text":"declare name Vocal BandPass MIDI ; declare description Simple MIDI-controllable source-filter vocal synthesizer. ; declare license MIT ; declare copyright (c)Romain Michon, CCRMA (Stanford University), GRAME ; import( stdfaust.lib ); process = pm.SFFormantModelBP_ui_MIDI : _,_; Try it Yourself >>","title":"vocalBPMIDI"},{"location":"examples/physicalModeling/#vocalfof","text":"declare name Vocal FOF ; declare description FOF vocal synthesizer. ; declare license MIT ; declare copyright (c)Mike Olsen, CCRMA (Stanford University) ; import( stdfaust.lib ); process = pm.SFFormantModelFofSmooth_ui : _,_; Try it Yourself >>","title":"vocalFOF"},{"location":"examples/physicalModeling/#vocalfofmidi","text":"declare name Vocal FOF MIDI ; declare description MIDI-controllable FOF vocal synthesizer. ; declare license MIT ; declare copyright (c)Mike Olsen, CCRMA (Stanford University) ; import( stdfaust.lib ); process = pm.SFFormantModelFofSmooth_ui_MIDI : _,_; Try it Yourself >>","title":"vocalFOFMIDI"},{"location":"examples/pitchShifting/","text":"pitchShifting pitchShifter declare name pitchShifter ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //-------------------------------------- // very simple real time pitch shifter //-------------------------------------- import( stdfaust.lib ); pitchshifter = vgroup( Pitch Shifter , ef.transpose( hslider( window (samples) , 1000, 50, 10000, 1), hslider( xfade (samples) , 10, 1, 10000, 1), hslider( shift (semitones) , 0, -12, +12, 0.1) ) ); process = pitchshifter; Try it Yourself >>","title":" pitchShifting "},{"location":"examples/pitchShifting/#pitchshifting","text":"","title":"pitchShifting"},{"location":"examples/pitchShifting/#pitchshifter","text":"declare name pitchShifter ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //-------------------------------------- // very simple real time pitch shifter //-------------------------------------- import( stdfaust.lib ); pitchshifter = vgroup( Pitch Shifter , ef.transpose( hslider( window (samples) , 1000, 50, 10000, 1), hslider( xfade (samples) , 10, 1, 10000, 1), hslider( shift (semitones) , 0, -12, +12, 0.1) ) ); process = pitchshifter; Try it Yourself >>","title":"pitchShifter"},{"location":"examples/psychoacoustic/","text":"psychoacoustic harmonicExciter declare exciter_name harmonicExciter ; declare exciter_author Priyanka Shekar (pshekar@ccrma.stanford.edu), revised by RM ; declare exciter_copyright Copyright (c) 2013 Priyanka Shekar ; declare exciter_version 1.0 ; declare exciter_license MIT License (MIT) ; declare description Psychoacoustic harmonic exciter, with GUI ; import( stdfaust.lib ); process = dm.exciter; Try it Yourself >>","title":" psychoacoustic "},{"location":"examples/psychoacoustic/#psychoacoustic","text":"","title":"psychoacoustic"},{"location":"examples/psychoacoustic/#harmonicexciter","text":"declare exciter_name harmonicExciter ; declare exciter_author Priyanka Shekar (pshekar@ccrma.stanford.edu), revised by RM ; declare exciter_copyright Copyright (c) 2013 Priyanka Shekar ; declare exciter_version 1.0 ; declare exciter_license MIT License (MIT) ; declare description Psychoacoustic harmonic exciter, with GUI ; import( stdfaust.lib ); process = dm.exciter; Try it Yourself >>","title":"harmonicExciter"},{"location":"examples/reverb/","text":"reverb fdnRev declare name fdnRev ; declare version 0.0 ; declare author JOS, Revised by RM ; declare description A feedback delay network reverb. ; import( stdfaust.lib ); process = dm.fdnrev0_demo(16,5,3); Try it Yourself >> freeverb declare name freeverb ; declare version 0.0 ; declare author RM ; declare description Freeverb demo application. ; import( stdfaust.lib ); process = dm.freeverb_demo; Try it Yourself >> reverbDesigner declare name reverbDesigner ; import( stdfaust.lib ); N = 16; // Feedback Delay Network (FDN) order (power of 2, 2 to 16) NB = 5; // Number of T60-controlled frequency-bands (3 or more) BSO = 3; // Order of each lowpass/highpass bandsplit (odd positive integer) process = dm.fdnrev0_demo(N,NB,BSO); Try it Yourself >> reverbTester declare name reverbTester ; declare version 0.0 ; declare author RM ; declare description Handy test inputs for reverberator demos below. ; import( stdfaust.lib ); process = dm.stereo_reverb_tester; Try it Yourself >> zitaRev declare name zitaRev ; declare version 0.0 ; declare author JOS, Revised by RM ; declare description Example GUI for zita_rev1_stereo (mostly following the Linux zita-rev1 GUI). ; import( stdfaust.lib ); process = dm.zita_rev1; Try it Yourself >> zitaRevFDN declare name zitaRevFDN ; declare version 0.0 ; declare author JOS, Revised by RM ; declare description Reverb demo application based on zita_rev_fdn. ; import( stdfaust.lib ); process = dm.zita_rev_fdn_demo; Try it Yourself >>","title":" reverb "},{"location":"examples/reverb/#reverb","text":"","title":"reverb"},{"location":"examples/reverb/#fdnrev","text":"declare name fdnRev ; declare version 0.0 ; declare author JOS, Revised by RM ; declare description A feedback delay network reverb. ; import( stdfaust.lib ); process = dm.fdnrev0_demo(16,5,3); Try it Yourself >>","title":"fdnRev"},{"location":"examples/reverb/#freeverb","text":"declare name freeverb ; declare version 0.0 ; declare author RM ; declare description Freeverb demo application. ; import( stdfaust.lib ); process = dm.freeverb_demo; Try it Yourself >>","title":"freeverb"},{"location":"examples/reverb/#reverbdesigner","text":"declare name reverbDesigner ; import( stdfaust.lib ); N = 16; // Feedback Delay Network (FDN) order (power of 2, 2 to 16) NB = 5; // Number of T60-controlled frequency-bands (3 or more) BSO = 3; // Order of each lowpass/highpass bandsplit (odd positive integer) process = dm.fdnrev0_demo(N,NB,BSO); Try it Yourself >>","title":"reverbDesigner"},{"location":"examples/reverb/#reverbtester","text":"declare name reverbTester ; declare version 0.0 ; declare author RM ; declare description Handy test inputs for reverberator demos below. ; import( stdfaust.lib ); process = dm.stereo_reverb_tester; Try it Yourself >>","title":"reverbTester"},{"location":"examples/reverb/#zitarev","text":"declare name zitaRev ; declare version 0.0 ; declare author JOS, Revised by RM ; declare description Example GUI for zita_rev1_stereo (mostly following the Linux zita-rev1 GUI). ; import( stdfaust.lib ); process = dm.zita_rev1; Try it Yourself >>","title":"zitaRev"},{"location":"examples/reverb/#zitarevfdn","text":"declare name zitaRevFDN ; declare version 0.0 ; declare author JOS, Revised by RM ; declare description Reverb demo application based on zita_rev_fdn. ; import( stdfaust.lib ); process = dm.zita_rev_fdn_demo; Try it Yourself >>","title":"zitaRevFDN"},{"location":"examples/smartKeyboard/","text":"smartKeyboard acGuitar //############################### acGuitar.dsp ################################# // Faust instrument specifically designed for faust2smartkeyb where 6 virtual // nylon strings can be strummed and plucked using a dedicated keyboard. The // extra strumming keyboard could be easily replaced by an external strumming // interface while the touch screen could keep being used to change the pitch // of the strings. // // ## SmartKeyboard Use Strategy // // The first 6 keyboards implement each individual string of the instrument. A // seventh keybaord is used a strumming/plucking interface. As mentionned // previously, it could be easily replaced by an external interface. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. // However it was specifically designed to be used with faust2smartkeyb. For // best results, we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp acGuitar.dsp // // // ## Version/Licence // // Version 0.0, Aug. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //############################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'7', 'Max Keyboard Polyphony':'0', 'Rounding Mode':'2', 'Keyboard 0 - Number of Keys':'14', 'Keyboard 1 - Number of Keys':'14', 'Keyboard 2 - Number of Keys':'14', 'Keyboard 3 - Number of Keys':'14', 'Keyboard 4 - Number of Keys':'14', 'Keyboard 5 - Number of Keys':'14', 'Keyboard 6 - Number of Keys':'6', 'Keyboard 0 - Lowest Key':'52', 'Keyboard 1 - Lowest Key':'57', 'Keyboard 2 - Lowest Key':'62', 'Keyboard 3 - Lowest Key':'67', 'Keyboard 4 - Lowest Key':'71', 'Keyboard 5 - Lowest Key':'76', 'Keyboard 0 - Send Keyboard Freq':'1', 'Keyboard 1 - Send Keyboard Freq':'1', 'Keyboard 2 - Send Keyboard Freq':'1', 'Keyboard 3 - Send Keyboard Freq':'1', 'Keyboard 4 - Send Keyboard Freq':'1', 'Keyboard 5 - Send Keyboard Freq':'1', 'Keyboard 6 - Piano Keyboard':'0', 'Keyboard 6 - Send Key Status':'1', 'Keyboard 6 - Key 0 - Label':'S0', 'Keyboard 6 - Key 1 - Label':'S1', 'Keyboard 6 - Key 2 - Label':'S2', 'Keyboard 6 - Key 3 - Label':'S3', 'Keyboard 6 - Key 4 - Label':'S4', 'Keyboard 6 - Key 5 - Label':'S5' } ; import( stdfaust.lib ); // SMARTKEYBOARD PARAMS kbfreq(0) = hslider( kb0freq ,164.8,20,10000,0.01); kbbend(0) = hslider( kb0bend ,1,0,10,0.01); kbfreq(1) = hslider( kb1freq ,220,20,10000,0.01); kbbend(1) = hslider( kb1bend ,1,0,10,0.01); kbfreq(2) = hslider( kb2freq ,293.7,20,10000,0.01); kbbend(2) = hslider( kb2bend ,1,0,10,0.01); kbfreq(3) = hslider( kb3freq ,392,20,10000,0.01); kbbend(3) = hslider( kb3bend ,1,0,10,0.01); kbfreq(4) = hslider( kb4freq ,493.9,20,10000,0.01); kbbend(4) = hslider( kb4bend ,1,0,10,0.01); kbfreq(5) = hslider( kb5freq ,659.2,20,10000,0.01); kbbend(5) = hslider( kb5bend ,1,0,10,0.01); kb6kstatus(0) = hslider( kb6k0status ,0,0,1,1) : ==(1) | ==(4) : int; kb6kstatus(1) = hslider( kb6k1status ,0,0,1,1) : ==(1) | ==(4) : int; kb6kstatus(2) = hslider( kb6k2status ,0,0,1,1) : ==(1) | ==(4) : int; kb6kstatus(3) = hslider( kb6k3status ,0,0,1,1) : ==(1) | ==(4) : int; kb6kstatus(4) = hslider( kb6k4status ,0,0,1,1) : ==(1) | ==(4) : int; kb6kstatus(5) = hslider( kb6k5status ,0,0,1,1) : ==(1) | ==(4) : int; // MODEL PARAMETERS // strings length sl(i) = kbfreq(i)*kbbend(i) : pm.f2l : si.smoo; // pluck position is controlled by the x axis of the accel pluckPosition = hslider( pluckPosition[acc: 1 0 -10 0 10] ,0.5,0,1,0.01) : si.smoo; // ASSEMBLING MODELS // number of strings nStrings = 6; guitar = par(i,nStrings, kb6kstatus(i) : ba.impulsify : // using raw impulses to drive the models pm.nylonGuitarModel(sl(i),pluckPosition)) : _; process = guitar : _,_; Try it Yourself >> bells //################################ bells.dsp ################################### // Faust instrument specifically designed for faust2smartkeyb where the // physical models of 4 different bells can be played using screen pads. The // models are taken from physmodels.lib. // // ## SmartKeyboard Use Strategy // // The SmartKeyboard interface is used to implement percussion pads where // the X/Y position of fingers is retrieved to control the strike position on // the bells. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. // However it was specifically designed to be used with faust2smartkeyb. For // best results, we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp bells.dsp // // // ## Version/Licence // // Version 0.0, Aug. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //############################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'2', 'Max Keyboard Polyphony':'0', 'Keyboard 0 - Number of Keys':'2', 'Keyboard 1 - Number of Keys':'2', 'Keyboard 0 - Send Freq':'0', 'Keyboard 1 - Send Freq':'0', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 0 - Send Key Status':'1', 'Keyboard 1 - Send Key Status':'1', 'Keyboard 0 - Send X':'1', 'Keyboard 0 - Send Y':'1', 'Keyboard 1 - Send X':'1', 'Keyboard 1 - Send Y':'1', 'Keyboard 0 - Key 0 - Label':'English Bell', 'Keyboard 0 - Key 1 - Label':'French Bell', 'Keyboard 1 - Key 0 - Label':'German Bell', 'Keyboard 1 - Key 1 - Label':'Russian Bell' } ; import( stdfaust.lib ); // SMARTKEYBOARD PARAMS kb0k0status = hslider( kb0k0status ,0,0,1,1) : min(1) : int; kb0k1status = hslider( kb0k1status ,0,0,1,1) : min(1) : int; kb1k0status = hslider( kb1k0status ,0,0,1,1) : min(1) : int; kb1k1status = hslider( kb1k1status ,0,0,1,1) : min(1) : int; x = hslider( x ,1,0,1,0.001); y = hslider( y ,1,0,1,0.001); // MODEL PARAMETERS strikeCutoff = 6500; strikeSharpness = 0.5; strikeGain = 1; // synthesize 10 modes out of 50 nModes = 10; // resonance duration is 30s t60 = 30; // number of excitation pos (retrieved from model) nExPos = 7; // computing excitation position from X and Y exPos = min((x*2-1 : abs),(y*2-1 : abs))*(nExPos-1) : int; // ASSEMBLING MODELS bells = (kb0k0status : pm.strikeModel(10,strikeCutoff,strikeSharpness,strikeGain) : pm.englishBellModel(nModes,exPos,t60,1,3)) + (kb0k1status : pm.strikeModel(10,strikeCutoff,strikeSharpness,strikeGain) : pm.frenchBellModel(nModes,exPos,t60,1,3)) + (kb1k0status : pm.strikeModel(10,strikeCutoff,strikeSharpness,strikeGain) : pm.germanBellModel(nModes,exPos,t60,1,2.5)) + (kb1k1status : pm.strikeModel(10,strikeCutoff,strikeSharpness,strikeGain) : pm.russianBellModel(nModes,exPos,t60,1,3)) : *(0.2); process = bells : _,_; Try it Yourself >> bowed //##################################### bowed.dsp ######################################## // Faust instrument specifically designed for faust2smartkeyb implementing a // non-polyphonic synthesizer (e.g., physical model; etc.) using a combination of // different types of UI elements. // // ## SmartKeyboard Use Strategy // // 5 keyboards are declared (4 actual keyboards and 1 control surface). We want to // disable the voice allocation system and we want to activate a voice on start-up // so that all strings are constantly running so we set Max Keyboard Polyphony to // 0. Since we don't want the first 4 keyboards to send the X and Y position of // fingers on the screen, we set Send X and Send Y to 0 for all these keyboards. // Similarly, we don't want the fifth keyboard to send pitch information to the synth // so we set Send Freq to 0 for that keyboard. Finally, we deactivate piano keyboard // mode for the fifth keyboard to make sure that color doesn't change when the key is // touch and that note names are not displayed. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp midiOnly.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'5', 'Max Keyboard Polyphony':'0', 'Rounding Mode':'1', 'Keyboard 0 - Number of Keys':'19', 'Keyboard 1 - Number of Keys':'19', 'Keyboard 2 - Number of Keys':'19', 'Keyboard 3 - Number of Keys':'19', 'Keyboard 4 - Number of Keys':'1', 'Keyboard 4 - Send Freq':'0', 'Keyboard 0 - Send X':'0', 'Keyboard 1 - Send X':'0', 'Keyboard 2 - Send X':'0', 'Keyboard 3 - Send X':'0', 'Keyboard 0 - Send Y':'0', 'Keyboard 1 - Send Y':'0', 'Keyboard 2 - Send Y':'0', 'Keyboard 3 - Send Y':'0', 'Keyboard 0 - Lowest Key':'55', 'Keyboard 1 - Lowest Key':'62', 'Keyboard 2 - Lowest Key':'69', 'Keyboard 3 - Lowest Key':'76', 'Keyboard 4 - Piano Keyboard':'0', 'Keyboard 4 - Key 0 - Label':'Bow' } ; import( stdfaust.lib ); // parameters f = hslider( freq ,400,50,2000,0.01); bend = hslider( bend ,1,0,10,0.01); keyboard = hslider( keyboard ,0,0,5,1) : int; key = hslider( key ,0,0,18,1) : int; x = hslider( x ,0.5,0,1,0.01) : si.smoo; y = hslider( y ,0,0,1,0.01) : si.smoo; // mapping freq = f*bend; // dirty motion tracker velocity = x-x' : abs : an.amp_follower_ar(0.1,1) : *(8000) : min(1); // 4 strings synthSet = par(i,4,synth(localFreq(i),velocity)) : _ with{ localFreq(i) = freq : ba.sAndH(keyboard == i) : si.smoo; synth(freq,velocity) = sy.fm((freq,freq + freq*modFreqRatio),index*velocity)*velocity with{ index = 1000; modFreqRatio = y*0.3; }; }; process = synthSet : _,_; Try it Yourself >> brass //############################### brass.dsp ################################### // Faust instrument specifically designed for faust2smartkeyb where a // trumpet physical model is controlled using some of the built-in sensors of // the device and the touchscreen. Some of these elements could be replaced by // external controllers (e.g., breath/mouth piece controller). // // ## SmartKeyboard Use Strategy // // 1 keyboard is used to implement the pistons of the trumpet (3 keys) and the // other allows to control the lips tension. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. // However it was specifically designed to be used with faust2smartkeyb. For // best results, we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp brass.dsp // // // ## Version/Licence // // Version 0.0, Aug. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //############################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'2', 'Max Keyboard Polyphony':'0', 'Keyboard 0 - Number of Keys':'1', 'Keyboard 1 - Number of Keys':'3', 'Keyboard 0 - Send Freq':'0', 'Keyboard 1 - Send Freq':'0', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 0 - Send Key X':'1', 'Keyboard 1 - Send Key Status':'1', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Key 0 - Label':'Lips Tension', 'Keyboard 1 - Key 0 - Label':'P1', 'Keyboard 1 - Key 1 - Label':'P2', 'Keyboard 1 - Key 2 - Label':'P3' } ; import( stdfaust.lib ); // SMARTKEYBOARD PARAMS kb0k0x = hslider( kb0k0x ,0,0,1,1); kb1k0status = hslider( kb1k0status ,0,0,1,1) : min(1) : int; kb1k1status = hslider( kb1k1status ,0,0,1,1) : min(1) : int; kb1k2status = hslider( kb1k2status ,0,0,1,1) : min(1) : int; // MODEL PARAMETERS // pressure is controlled by accelerometer pressure = hslider( pressure[acc: 1 1 -10 0 10] ,0,0,1,0.01) : si.smoo; breathGain = 0.005; breathCutoff = 2000; vibratoFreq = 5; vibratoGain = 0; //pitch when no pistons are pushed basePitch = 48; // C4 // calculate pitch shift in function of piston combination pitchShift = ((kb1k0status == 0) (kb1k1status == 1) (kb1k2status == 0))*(1) + ((kb1k0status == 1) (kb1k1status == 0) (kb1k2status == 0))*(2) + ((kb1k0status == 1) (kb1k1status == 1) (kb1k2status == 0))*(3) + ((kb1k0status == 0) (kb1k1status == 1) (kb1k2status == 1))*(4) + ((kb1k0status == 1) (kb1k1status == 0) (kb1k2status == 1))*(5) + ((kb1k0status == 1) (kb1k1status == 1) (kb1k2status == 1))*(6); // tube length is calculated based on piston combination tubeLength = basePitch-pitchShift : ba.midikey2hz : pm.f2l : si.smoo; // lips tension is controlled using pad on screen lipsTension = kb0k0x : si.smoo; // default mute value mute = 0.5; // ASSEMBLING MODEL model = pm.blower(pressure,breathGain,breathCutoff,vibratoFreq,vibratoGain) : pm.brassModel(tubeLength,lipsTension,mute); process = model : _,_; Try it Yourself >> clarinet //############################### clarinet.dsp ################################# // Faust instrument specifically designed for faust2smartkeyb where a // clarinet physical model is controlled by an interface implementing // fingerings similar to that of a the real instrument. The pressure of the // breath in the mouthpiece of the clarinet is controlled by blowing on the // built-in microphone of the device. // // ## SmartKeyboard Use Strategy // // The device is meant to be held with 2 hands vertically in order to put all // fingers on the screen at the same time. Key combinations determine the // pitch of the instrument. A single voice is constantly ran. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. // However it was specifically designed to be used with faust2smartkeyb. For // best results, we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] clarinet.dsp // // // ## Version/Licence // // Version 0.0, Aug. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //############################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'2', 'Max Keyboard Polyphony':'0', 'Keyboard 0 - Number of Keys':'4', 'Keyboard 1 - Number of Keys':'5', 'Keyboard 0 - Send Freq':'0', 'Keyboard 1 - Send Freq':'0', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 0 - Send Key Status':'1', 'Keyboard 1 - Send Key Status':'1', 'Keyboard 0 - Key 3 - Label':'O+', 'Keyboard 1 - Key 4 - Label':'O-' } ; import( stdfaust.lib ); // SMARTKEYBOARD PARAMS kb0k0status = hslider( kb0k0status ,0,0,1,1) : min(1) : int; kb0k1status = hslider( kb0k1status ,0,0,1,1) : min(1) : int; kb0k2status = hslider( kb0k2status ,0,0,1,1) : min(1) : int; kb0k3status = hslider( kb0k3status ,0,0,1,1) : min(1) : int; kb1k0status = hslider( kb1k0status ,0,0,1,1) : min(1) : int; kb1k1status = hslider( kb1k1status ,0,0,1,1) : min(1) : int; kb1k2status = hslider( kb1k2status ,0,0,1,1) : min(1) : int; kb1k3status = hslider( kb1k3status ,0,0,1,1) : min(1) : int; kb1k4status = hslider( kb1k4status ,0,0,1,1) : min(1) : int; // MODEL PARAMETERS reedStiffness = hslider( reedStiffness[acc: 1 1 -10 0 10] ,0,0,1,0.01) : si.smoo; basePitch = 73; // C#4 pitchShift = // calculate pitch shfit in function of keys combination ((kb0k0status == 0) (kb0k1status == 1) (kb0k2status == 0) (kb1k0status == 0) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-1) + // C ((kb0k0status == 1) (kb0k1status == 0) (kb0k2status == 0) (kb1k0status == 0) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-2) + // B ((kb0k0status == 1) (kb0k1status == 0) (kb0k2status == 1) (kb1k0status == 0) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-3) + // Bb ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 0) (kb1k0status == 0) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-4) + // A ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 0) (kb1k0status == 1) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-5) + // G# ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 0) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-6) + // G ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 0) (kb1k1status == 1) (kb1k2status == 0) (kb1k3status == 0))*(-7) + // F# ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 1) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-8) + // F ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 1) (kb1k1status == 1) (kb1k2status == 0) (kb1k3status == 0))*(-9) + // E ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 1) (kb1k1status == 1) (kb1k2status == 0) (kb1k3status == 1))*(-10) + // Eb ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 1) (kb1k1status == 1) (kb1k2status == 1) (kb1k3status == 0))*(-11) + // D ((kb0k0status == 0) (kb0k1status == 0) (kb0k2status == 0) (kb1k0status == 0) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 1))*(-12) + // C# ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 1) (kb1k1status == 1) (kb1k2status == 1) (kb1k3status == 1))*(-13); // C octaveShiftUp = +(kb0k3status : ba.impulsify)~_; // counting up octaveShiftDown = +(kb1k4status : ba.impulsify)~_; // counting down octaveShift = (octaveShiftUp-octaveShiftDown)*(12); // tube length is just smoothed: could be improved tubeLength = basePitch+pitchShift+octaveShift : ba.midikey2hz : pm.f2l : si.smoo; bellOpening = 0.5; // ASSEMBLING MODEL model(pressure) = pm.clarinetModel(tubeLength,pressure,reedStiffness,bellOpening); // pressure is estimated from mic signal process = an.amp_follower_ud(0.02,0.02)*0.7 : model : _,_; Try it Yourself >> crazyGuiro //################################### crazyGuiro.dsp ##################################### // A simple smart phone Guiro where the touch screen is used to drive the instrument and // select its pitch and where the x and y axis of the accelerometer control the // resonance properties of the instrument. // // ## SmartKeyboard Use Strategy // // Since the sounds generated by this synth are very short, the strategy here is to take // advantage of the polyphony capabilities of the iOSKeyboard architecture by creating // a new voice every time a new key is pressed. Since the SmartKeyboard interface has a // large number of keys here (128), lots of sounds are generated when sliding a // finger across the keyboard. Also, it's interesting to notice that the freq parameter // is not used here. Instead keyboard and key are used which allows us to easily // make custom mappings. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] crazyGuiro.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## import( stdfaust.lib ); //========================= Smart Keyboard Configuration ================================= // 8 keyboards, each has 16 keys, none of them display key names. //======================================================================================== declare interface SmartKeyboard{ 'Number of Keyboards':'8', 'Keyboard 0 - Number of Keys':'16', 'Keyboard 1 - Number of Keys':'16', 'Keyboard 2 - Number of Keys':'16', 'Keyboard 3 - Number of Keys':'16', 'Keyboard 4 - Number of Keys':'16', 'Keyboard 5 - Number of Keys':'16', 'Keyboard 6 - Number of Keys':'16', 'Keyboard 7 - Number of Keys':'16', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 2 - Piano Keyboard':'0', 'Keyboard 3 - Piano Keyboard':'0', 'Keyboard 4 - Piano Keyboard':'0', 'Keyboard 5 - Piano Keyboard':'0', 'Keyboard 6 - Piano Keyboard':'0', 'Keyboard 7 - Piano Keyboard':'0' } ; //================================ Instrument Parameters ================================= // Creates the connection between the synth and the mobile device //======================================================================================== // the current keyboard keyboard = hslider( keyboard ,0,0,2,1); // the current key of the current keyboard key = hslider( key ,0,0,2,1); // the wet factor of the reverb wet = hslider( wet[acc: 0 0 -10 0 10] ,0,0,1,0.01); // the resonance factor of the reverb res = hslider( res[acc: 1 0 -10 0 10] ,0.5,0,1,0.01); // smart keyboard gate parameter gate = button( gate ); //=================================== Parameters Mapping ================================= //======================================================================================== // the resonance frequency of each click of the Guiro changes in function of // the selected keyboard and key on it minKey = 50; // min key of lowest keyboard keySkipKeyboard = 8; // key skip per keyboard drumResFreq = (key+minKey)+(keyboard*keySkipKeyboard) : ba.midikey2hz; reverbWet = wet : si.smoo; reverbRes = wet : si.smoo; // filter q q = 8; //============================================ DSP ======================================= //======================================================================================== reverb(wet,res) = _ : *(1-wet),(*(wet) : re.mono_freeverb(res, 0.5, 0.5, 0)) : _; process = sy.popFilterDrum(drumResFreq,q,gate) : reverb(wet,res) : _,_; Try it Yourself >> drums //##################################### drums.dsp ######################################## // Faust instrument specifically designed for faust2smartkeyb where 3 drums can // be controlled using pads. The X/Y postion of fingers is detected on each key // and use to control the strike postion on the virtual membrane. // // ## SmartKeyboard Use Strategy // // The drum physical model used here is implemented to be generic so that its // fundamental frequency can be changed for each voice. SmartKeyboard is used // in polyphonic mode so each new strike on the interface corresponds to a new // new voice. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp drums.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## // Interface with 2 keyboards of 2 and 1 keys (3 pads) // Static mode is used so that keys don't change color when touched // Note labels are hidden // Piano Keyboard mode is deactivated so all the keys look the same declare interface SmartKeyboard{ 'Number of Keyboards':'2', 'Keyboard 0 - Number of Keys':'2', 'Keyboard 1 - Number of Keys':'1', 'Keyboard 0 - Static Mode':'1', 'Keyboard 1 - Static Mode':'1', 'Keyboard 0 - Send X':'1', 'Keyboard 0 - Send Y':'1', 'Keyboard 1 - Send X':'1', 'Keyboard 1 - Send Y':'1', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 0 - Key 0 - Label':'High', 'Keyboard 0 - Key 1 - Label':'Mid', 'Keyboard 1 - Key 0 - Label':'Low' } ; import( stdfaust.lib ); // standard parameters gate = button( gate ); x = hslider( x ,1,0,1,0.001); y = hslider( y ,1,0,1,0.001); keyboard = hslider( keyboard ,0,0,1,1) : int; key = hslider( key ,0,0,1,1) : int; drumModel = pm.djembe(rootFreq,exPos,strikeSharpness,gain,gate) with{ // frequency of the lowest drum bFreq = 60; // retrieving pad ID (0-2) padID = 2-(keyboard*2+key); // drum root freq is computed in function of pad number rootFreq = bFreq*(padID+1); // excitation position exPos = min((x*2-1 : abs),(y*2-1 : abs)); strikeSharpness = 0.5; gain = 2; }; process = drumModel : _,_; Try it Yourself >> dubDub //################################### dubDub.dsp ##################################### // A simple smartphone abstract instrument than can be controlled using the touch // screen and the accelerometers of the device. // // ## SmartKeyboard Use Strategy // // The idea here is to use the SmartKeyboard interface as an X/Y control pad by just // creating one keyboard with on key and by retrieving the X and Y position on that single // key using the x and y standard parameters. Keyboard mode is deactivated so that // the color of the pad doesn't change when it is pressed. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] dubDub.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## declare name dubDub ; import( stdfaust.lib ); //========================= Smart Keyboard Configuration ================================= // (1 keyboards with 1 key configured as a pad. //======================================================================================== declare interface SmartKeyboard{ 'Number of Keyboards':'1', 'Keyboard 0 - Number of Keys':'1', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Send X':'1', 'Keyboard 0 - Send Y':'1' } ; //================================ Instrument Parameters ================================= // Creates the connection between the synth and the mobile device //======================================================================================== // SmartKeyboard X parameter x = hslider( x ,0,0,1,0.01); // SmartKeyboard Y parameter y = hslider( y ,0,0,1,0.01); // SmartKeyboard gate parameter gate = button( gate ); // modulation frequency is controlled with the x axis of the accelerometer modFreq = hslider( modFeq[acc: 0 0 -10 0 10] ,9,0.5,18,0.01); // general gain is controlled with the y axis of the accelerometer gain = hslider( gain[acc: 1 0 -10 0 10] ,0.5,0,1,0.01); //=================================== Parameters Mapping ================================= //======================================================================================== // sawtooth frequency minFreq = 80; maxFreq = 500; freq = x*(maxFreq-minFreq) + minFreq : si.polySmooth(gate,0.999,1); // filter q q = 8; // filter cutoff frequency is modulate with a triangle wave minFilterCutoff = 50; maxFilterCutoff = 5000; filterModFreq = modFreq : si.smoo; filterCutoff = (1-os.lf_trianglepos(modFreq)*(1-y))*(maxFilterCutoff-minFilterCutoff)+minFilterCutoff; // general gain of the synth generalGain = gain : ba.lin2LogGain : si.smoo; //============================================ DSP ======================================= //======================================================================================== process = sy.dubDub(freq,filterCutoff,q,gate)*generalGain : _,_; Try it Yourself >> elecGuitar //################################### elecGuitar.dsp ##################################### // Faust instruments specifically designed for faust2smartkeyb where an electric // guitar physical model is controlled using an isomorphic keyboard. Rock on! // // ## SmartKeyboard Use Strategy // // we want to create an isomorphic keyboard where each keyboard is monophonic and // implements a string . Keyboards should be one fourth apart from each other // (more or less like on a guitar). We want to be able to slide between keyboards // (strum) to trigger a new note (voice) and we want new fingers on a keyboard to // steal the pitch from the previous finger (sort of hammer on). // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect elecGuitarEffecr.dsp elecGuitar.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017: // https://ccrma.stanford.edu/~rmichon // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## // Interface with 6 monophonic keyboards one fourth apart from each other declare interface SmartKeyboard{ 'Number of Keyboards':'6', 'Max Keyboard Polyphony':'1', 'Keyboard 0 - Number of Keys':'13', 'Keyboard 1 - Number of Keys':'13', 'Keyboard 2 - Number of Keys':'13', 'Keyboard 3 - Number of Keys':'13', 'Keyboard 4 - Number of Keys':'13', 'Keyboard 5 - Number of Keys':'13', 'Keyboard 0 - Lowest Key':'72', 'Keyboard 1 - Lowest Key':'67', 'Keyboard 2 - Lowest Key':'62', 'Keyboard 3 - Lowest Key':'57', 'Keyboard 4 - Lowest Key':'52', 'Keyboard 5 - Lowest Key':'47', 'Rounding Mode':'2' } ; import( stdfaust.lib ); // standard parameters f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01) : si.polySmooth(gate,0.999,1); gain = hslider( gain ,1,0,1,0.01); s = hslider( sustain[midi:ctrl 64] ,0,0,1,1); // for sustain pedal t = button( gate ); // mapping params gate = t+s : min(1); freq = f*bend : max(60); // min freq is 60 Hz stringLength = freq : pm.f2l; pluckPosition = 0.8; mute = gate : si.polySmooth(gate,0.999,1); process = pm.elecGuitar(stringLength,pluckPosition,mute,gain,gate) : _,_; Try it Yourself >> fm //###################################### fm.dsp ########################################## // A simple smart phone percussion abstract sound toy based on an FM synth. // // ## SmartKeyboard Use Strategy // // The idea here is to use the SmartKeyboard interface as an X/Y control pad by just // creating one keyboard with on key and by retrieving the X and Y position on that single // key using the x and y standard parameters. Keyboard mode is deactivated so that // the color of the pad doesn't change when it is pressed. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] crazyGuiro.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## declare name fm ; import( stdfaust.lib ); //========================= Smart Keyboard Configuration ================================= // (1 keyboards with 1 key configured as a pad. //======================================================================================== declare interface SmartKeyboard{ 'Number of Keyboards':'1', 'Keyboard 0 - Number of Keys':'1', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Send X':'1', 'Keyboard 0 - Send Y':'1' } ; //================================ Instrument Parameters ================================= // Creates the connection between the synth and the mobile device //======================================================================================== // SmartKeyboard X parameter x = hslider( x ,0,0,1,0.01); // SmartKeyboard Y parameter y = hslider( y ,0,0,1,0.01); // SmartKeyboard gate parameter gate = button( gate ) ; // mode resonance duration is controlled with the x axis of the accelerometer modFreqRatio = hslider( res[acc: 0 0 -10 0 10] ,1,0,2,0.01) : si.smoo; //=================================== Parameters Mapping ================================= //======================================================================================== // carrier frequency minFreq = 80; maxFreq = 500; cFreq = x*(maxFreq-minFreq) + minFreq : si.polySmooth(gate,0.999,1); // modulator frequency modFreq = cFreq*modFreqRatio; // modulation index modIndex = y*1000 : si.smoo; //============================================ DSP ======================================= //======================================================================================== // since the generated sound is pretty chaotic, there is no need for an envelope generator fmSynth = sy.fm((cFreq,modFreq),(modIndex))*(gate : si.smoo)*0.5; process = fmSynth; Try it Yourself >> frog //################################### frog.dsp ##################################### // A simple smart phone abstract instrument than can be controlled using the touch // screen and the accelerometers of the device. // // ## SmartKeyboard Use Strategy // // The idea here is to use the SmartKeyboard interface as an X/Y control pad by just // creating one keyboard with on key and by retrieving the X and Y position on that single // key using the x and y standard parameters. Keyboard mode is deactivated so that // the color of the pad doesn't change when it is pressed. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] frog.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## declare name frog ; import( stdfaust.lib ); //========================= Smart Keyboard Configuration ================================= // (1 keyboards with 1 key configured as a pad. //======================================================================================== declare interface SmartKeyboard{ 'Number of Keyboards':'1', 'Keyboard 0 - Number of Keys':'1', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Send X':'1', 'Keyboard 0 - Send Y':'1' } ; //================================ Instrument Parameters ================================= // Creates the connection between the synth and the mobile device //======================================================================================== // SmartKeyboard X parameter x = hslider( x ,0,0,1,0.01); // SmartKeyboard Y parameter y = hslider( y ,0,0,1,0.01); // SmartKeyboard gate parameter gate = button( gate ); // the cutoff frequency of the filter is controlled with the x axis of the accelerometer cutoff = hslider( cutoff[acc: 0 0 -10 0 10] ,2500,50,5000,0.01); //=================================== Parameters Mapping ================================= //======================================================================================== maxFreq = 100; minFreq = 1; freq = x*(maxFreq-minFreq) + minFreq : si.polySmooth(gate,0.999,1); maxQ = 40; minQ = 1; q = (1-y)*(maxQ-minQ) + minQ : si.smoo; filterCutoff = cutoff : si.smoo; //============================================ DSP ======================================= //======================================================================================== process = sy.dubDub(freq,filterCutoff,q,gate) : _,_; Try it Yourself >> harp //######################################## harp.dsp ###################################### // A simple smart phone based harp (if we dare to call it like that). // // ## SmartKeyboard Use Strategy // // Since the sounds generated by this synth are very short, the strategy here is to take // advantage of the polyphony capabilities of the iOSKeyboard architecture by creating // a new voice every time a new key is pressed. Since the SmartKeyboard interface has a // large number of keys here (128), lots of sounds are generated when sliding a // finger across the keyboard. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] harp.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## declare name harp ; import( stdfaust.lib ); //========================= Smart Keyboard Configuration ================================= // (8 keyboards with 16 keys configured as a pitch matrix. //======================================================================================== declare interface SmartKeyboard{ 'Number of Keyboards':'8', 'Keyboard 0 - Number of Keys':'16', 'Keyboard 1 - Number of Keys':'16', 'Keyboard 2 - Number of Keys':'16', 'Keyboard 3 - Number of Keys':'16', 'Keyboard 4 - Number of Keys':'16', 'Keyboard 5 - Number of Keys':'16', 'Keyboard 6 - Number of Keys':'16', 'Keyboard 7 - Number of Keys':'16', 'Keyboard 0 - Lowest Key':'40', 'Keyboard 1 - Lowest Key':'45', 'Keyboard 2 - Lowest Key':'50', 'Keyboard 3 - Lowest Key':'55', 'Keyboard 4 - Lowest Key':'60', 'Keyboard 5 - Lowest Key':'65', 'Keyboard 6 - Lowest Key':'70', 'Keyboard 7 - Lowest Key':'75', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 2 - Piano Keyboard':'0', 'Keyboard 3 - Piano Keyboard':'0', 'Keyboard 4 - Piano Keyboard':'0', 'Keyboard 5 - Piano Keyboard':'0', 'Keyboard 6 - Piano Keyboard':'0', 'Keyboard 7 - Piano Keyboard':'0' } ; //================================ Instrument Parameters ================================= // Creates the connection between the synth and the mobile device //======================================================================================== // the string resonance in second is controlled by the x axis of the accelerometer res = hslider( res[acc: 0 0 -10 0 10] ,2,0.1,4,0.01); // Smart Keyboard frequency parameter freq = hslider( freq ,400,50,2000,0.01); // Smart Keyboard gate parameter gate = button( gate ); //=================================== Parameters Mapping ================================= //======================================================================================== stringFreq = freq; //============================================ DSP ======================================= //======================================================================================== process = sy.combString(freq,res,gate); Try it Yourself >> midiOnly //################################### midiOnly.dsp ###################################### // Faust instrument specifically designed for faust2smartkeyb implementing a MIDI // controllable app where the mobile device's touch screen is used to control // specific parameters of the synth continuously using two separate X/Y control surfaces. // // ## SmartKeyboard Use Strategy // // The SmartKeyboard configuration for this instrument consists in a single keyboard // with two keys. Each key implements a control surface. Piano Keyboard mode is // disabled so that key names are not displayed and that keys don't change color when // touched. Finally, Send Freq is set to 0 so that new voices are not allocated by // the touch screen and that the freq and bend parameters are not computed. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp midiOnly.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## // Interface with 4 polyphnic keyboards of 13 keys with the same config declare interface SmartKeyboard{ 'Number of Keyboards':'1', 'Keyboard 0 - Number of Keys':'2', 'Keyboard 0 - Send Freq':'0', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Send Key X':'1', 'Keyboard 0 - Key 0 - Label':'Mod Index', 'Keyboard 0 - Key 1 - Label':'Mod Freq' } ; import( stdfaust.lib ); f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01) : si.polySmooth(gate,0.999,1); gain = hslider( gain ,1,0,1,0.01); key = hslider( key ,0,0,1,1) : int; kb0k0x = hslider( kb0k0x[midi:ctrl 1] ,0.5,0,1,0.01) : si.smoo; kb0k1x = hslider( kb0k1x[midi:ctrl 1] ,0.5,0,1,0.01) : si.smoo; s = hslider( sustain[midi:ctrl 64] ,0,0,1,1); t = button( gate ); // fomating parameters gate = t+s : min(1); freq = f*bend; index = kb0k0x*1000; modFreqRatio = kb0k1x; envelope = gain*gate : si.smoo; process = sy.fm((freq,freq + freq*modFreqRatio),index*envelope)*envelope : _,_; Try it Yourself >> multiSynth //################################### multiSynth.dsp ###################################### // Faust instrument specifically designed for faust2smartkeyb where 4 keyboards // are used to control 4 independent synths. // // ## SmartKeyboard Use Strategy // // The SmartKeyboard configuration is relatively simple for this example and // only consists in four polyphonic keyboards in parallel. The keyboard standard // parameter is used to activate specific elements of the synthesizer. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp multiSynth.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## // Interface with 4 polyphnic keyboards of 13 keys with the same config declare interface SmartKeyboard{ 'Number of Keyboards':'4', 'Rounding Mode':'2', 'Inter-Keyboard Slide':'0', 'Keyboard 0 - Number of Keys':'13', 'Keyboard 1 - Number of Keys':'13', 'Keyboard 2 - Number of Keys':'13', 'Keyboard 3 - Number of Keys':'13', 'Keyboard 0 - Lowest Key':'60', 'Keyboard 1 - Lowest Key':'60', 'Keyboard 2 - Lowest Key':'60', 'Keyboard 3 - Lowest Key':'60', 'Keyboard 0 - Send Y':'1', 'Keyboard 1 - Send Y':'1', 'Keyboard 2 - Send Y':'1', 'Keyboard 3 - Send Y':'1' } ; import( stdfaust.lib ); // standard parameters f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01) : si.polySmooth(gate,0.999,1); gain = hslider( gain ,1,0,1,0.01); s = hslider( sustain[midi:ctrl 64] ,0,0,1,1); // for sustain pedal t = button( gate ); y = hslider( y[midi:ctrl 1] ,1,0,1,0.001) : si.smoo; keyboard = hslider( keyboard ,0,0,3,1) : int; // fomating parameters gate = t+s : min(1); freq = f*bend; cutoff = y*4000+50; // oscillators oscilators(0) = os.sawtooth(freq); oscilators(1) = os.triangle(freq); oscilators(2) = os.square(freq); oscilators(3) = os.osc(freq); // oscs are selected in function of the current keyboard synths = par(i,4,select2(keyboard == i,0,oscilators(i))) : fi.lowpass(3,cutoff) : *(envelope) with{ envelope = gate*gain : si.smoo; }; process = synths : _,_; Try it Yourself >> toy //##################################### toy.dsp ####################################### // Faust sound toy specifically designed for faust2smartkeyb where a funny // synth can be controlled using several fingers on the screen and the built-in // accelerometer. // // ## SmartKeyboard Use Strategy // // We just want a blank screen where the position of the different fingers on // the screen can be tracked and retrieved in the Faust object. For that, we // create one keyboard with one key, that should fill the screen. We ask the // interface to not compute the freq and bend parameters to save // computation by setting 'Keyboard 0 - Send Freq':'0'. We don't want the // color of the key to change when it is touched so we deactivate the // Piano Keyboard mode. Fingers should be numbered to be able to use the // numbered x and y parameters (x0, y0, x1, etc.), so Count Fingers // is enabled. Finally, by setting Max Keyboard Polyphony to 0, we deactivate // the voice allocation system and we automatically start a voice when the app // is launched. This means that fingers are no longer associated to specific voices. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] toy.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017: // https://ccrma.stanford.edu/~rmichon // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## // X/Y interface: one keyboard with one key // freq and bend are not computed // fingers are counted // voice is launched on startup declare interface SmartKeyboard{ 'Number of Keyboards':'1', 'Max Keyboard Polyphony':'0', 'Keyboard 0 - Number of Keys':'1', 'Keyboard 0 - Send Freq':'0', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 0 - Send Numbered X':'1', 'Keyboard 0 - Send Numbered Y':'1' } ; import( stdfaust.lib ); // parameters x0 = hslider( x0 ,0.5,0,1,0.01) : si.smoo; y0 = hslider( y0 ,0.5,0,1,0.01) : si.smoo; y1 = hslider( y1 ,0,0,1,0.01) : si.smoo; q = hslider( q[acc: 0 0 -10 0 10] ,30,10,50,0.01) : si.smoo; del = hslider( del[acc: 0 0 -10 0 10] ,0.5,0.01,1,0.01) : si.smoo; fb = hslider( fb[acc: 1 0 -10 0 10] ,0.5,0,1,0.01) : si.smoo; // mapping impFreq = 2 + x0*20; resFreq = y0*3000+300; // simple echo effect echo = +~(de.delay(65536,del*ma.SR)*fb); // putting it together process = os.lf_imptrain(impFreq) : fi.resonlp(resFreq,q,1) : echo : ef.cubicnl(y1,0)*0.95 : _,_; Try it Yourself >> trumpet //################################### trumpet.dsp ##################################### // A simple trumpet app... (for large screens). // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp trumpet.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## import( stdfaust.lib ); declare interface SmartKeyboard{ 'Number of Keyboards':'5', 'Max Keyboard Polyphony':'1', 'Mono Mode':'1', 'Keyboard 0 - Number of Keys':'13', 'Keyboard 1 - Number of Keys':'13', 'Keyboard 2 - Number of Keys':'13', 'Keyboard 3 - Number of Keys':'13', 'Keyboard 4 - Number of Keys':'13', 'Keyboard 0 - Lowest Key':'77', 'Keyboard 1 - Lowest Key':'72', 'Keyboard 2 - Lowest Key':'67', 'Keyboard 3 - Lowest Key':'62', 'Keyboard 4 - Lowest Key':'57', 'Rounding Mode':'2', 'Keyboard 0 - Send Y':'1', 'Keyboard 1 - Send Y':'1', 'Keyboard 2 - Send Y':'1', 'Keyboard 3 - Send Y':'1', 'Keyboard 4 - Send Y':'1', } ; // standard parameters f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01) : si.polySmooth(gate,0.999,1); gain = hslider( gain ,1,0,1,0.01); s = hslider( sustain[midi:ctrl 64] ,0,0,1,1); // for sustain pedal t = button( gate ); y = hslider( y[midi:ctrl 1] ,1,0,1,0.001) : si.smoo; // fomating parameters gate = t+s : min(1); freq = f*bend; cutoff = y*4000+50; envelope = gate*gain : si.smoo; process = os.sawtooth(freq)*envelope : fi.lowpass(3,cutoff) : _,_; Try it Yourself >> turenas //################################### turenas.dsp ######################################## // A simple smart phone percussion based on an additive synthesizer. // // ## SmartKeyboard Use Strategy // // Since the sounds generated by this synth are very short, the strategy here is to take // advantage of the polyphony capabilities of the iOSKeyboard architecture by creating // a new voice every time a new key is pressed. Since the SmartKeyboard interface has a // large number of keys here (180), lots of sounds are generated when sliding a // finger across the keyboard. // // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] turenas.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## declare name turenas ; import( stdfaust.lib ); //========================= Smart Keyboard Configuration ================================= // (10 keyboards with 18 keys each configured as a pitch matrix. //======================================================================================== declare interface SmartKeyboard{ 'Number of Keyboards':'10', 'Keyboard 0 - Number of Keys':'18', 'Keyboard 1 - Number of Keys':'18', 'Keyboard 2 - Number of Keys':'18', 'Keyboard 3 - Number of Keys':'18', 'Keyboard 4 - Number of Keys':'18', 'Keyboard 5 - Number of Keys':'18', 'Keyboard 6 - Number of Keys':'18', 'Keyboard 7 - Number of Keys':'18', 'Keyboard 8 - Number of Keys':'18', 'Keyboard 9 - Number of Keys':'18', 'Keyboard 0 - Lowest Key':'50', 'Keyboard 1 - Lowest Key':'55', 'Keyboard 2 - Lowest Key':'60', 'Keyboard 3 - Lowest Key':'65', 'Keyboard 4 - Lowest Key':'70', 'Keyboard 5 - Lowest Key':'75', 'Keyboard 6 - Lowest Key':'80', 'Keyboard 7 - Lowest Key':'85', 'Keyboard 8 - Lowest Key':'90', 'Keyboard 9 - Lowest Key':'95', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 2 - Piano Keyboard':'0', 'Keyboard 3 - Piano Keyboard':'0', 'Keyboard 4 - Piano Keyboard':'0', 'Keyboard 5 - Piano Keyboard':'0', 'Keyboard 6 - Piano Keyboard':'0', 'Keyboard 7 - Piano Keyboard':'0', 'Keyboard 8 - Piano Keyboard':'0', 'Keyboard 9 - Piano Keyboard':'0', 'Keyboard 0 - Send X':'0', 'Keyboard 1 - Send X':'0', 'Keyboard 2 - Send X':'0', 'Keyboard 3 - Send X':'0', 'Keyboard 4 - Send X':'0', 'Keyboard 5 - Send X':'0', 'Keyboard 6 - Send X':'0', 'Keyboard 7 - Send X':'0', 'Keyboard 8 - Send X':'0', 'Keyboard 9 - Send X':'0' } ; //================================ Instrument Parameters ================================= // Creates the connection between the synth and the mobile device //======================================================================================== // SmartKeyboard Y parameter y = hslider( y ,0,0,1,0.01); // Smart Keyboard frequency parameter freq = hslider( freq ,400,50,2000,0.01); // SmartKeyboard gate parameter gate = button( gate ); // mode resonance duration is controlled with the x axis of the accelerometer res = hslider( res[acc: 0 0 -10 0 10] ,2.5,0.01,5,0.01); //=================================== Parameters Mapping ================================= //======================================================================================== // number of modes nModes = 6; // distance between each mode maxModeSpread = 5; modeSpread = y*maxModeSpread; // computing modes frequency ratio modeFreqRatios = par(i,nModes,1+(i+1)/nModes*modeSpread); // computing modes gain minModeGain = 0.3; modeGains = par(i,nModes,1-(i+1)/(nModes*minModeGain)); // smoothed mode resonance modeRes = res : si.smoo; //============================================ DSP ======================================= //======================================================================================== process = sy.additiveDrum(freq,modeFreqRatios,modeGains,0.8,0.001,modeRes,gate)*0.05; Try it Yourself >> violin2 //############################### violin2.dsp ################################## // Faust instrument specifically designed for faust2smartkeyb where a // complete violin physical model can be played using the touch sceen // interface. Bowing is carried out by constantly moving a finger on the // y axis of a key. // // ## SmartKeyboard Use Strategy // // 4 keyboards are used to control the pitch of the 4 bowed strings. Strings // are connected to the virtual bow when they are touched. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. // However it was specifically designed to be used with faust2smartkeyb. For // best results, we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp violin.dsp // // // ## Version/Licence // // Version 0.0, Aug. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //############################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'4', 'Max Keyboard Polyphony':'0', 'Rounding Mode':'2', 'Send Fingers Count':'1', 'Keyboard 0 - Number of Keys':'12', 'Keyboard 1 - Number of Keys':'12', 'Keyboard 2 - Number of Keys':'12', 'Keyboard 3 - Number of Keys':'12', 'Keyboard 0 - Lowest Key':'55', 'Keyboard 1 - Lowest Key':'62', 'Keyboard 2 - Lowest Key':'69', 'Keyboard 3 - Lowest Key':'76', 'Keyboard 0 - Send Keyboard Freq':'1', 'Keyboard 1 - Send Keyboard Freq':'1', 'Keyboard 2 - Send Keyboard Freq':'1', 'Keyboard 3 - Send Keyboard Freq':'1', 'Keyboard 0 - Send Y':'1', 'Keyboard 1 - Send Y':'1', 'Keyboard 2 - Send Y':'1', 'Keyboard 3 - Send Y':'1' } ; import( stdfaust.lib ); // SMARTKEYBOARD PARAMS kbfreq(0) = hslider( kb0freq ,220,20,10000,0.01); kbbend(0) = hslider( kb0bend ,1,0,10,0.01); kbfreq(1) = hslider( kb1freq ,330,20,10000,0.01); kbbend(1) = hslider( kb1bend ,1,0,10,0.01); kbfreq(2) = hslider( kb2freq ,440,20,10000,0.01); kbbend(2) = hslider( kb2bend ,1,0,10,0.01); kbfreq(3) = hslider( kb3freq ,550,20,10000,0.01); kbbend(3) = hslider( kb3bend ,1,0,10,0.01); kbfingers(0) = hslider( kb0fingers ,0,0,10,1) : int; kbfingers(1) = hslider( kb1fingers ,0,0,10,1) : int; kbfingers(2) = hslider( kb2fingers ,0,0,10,1) : int; kbfingers(3) = hslider( kb3fingers ,0,0,10,1) : int; y = hslider( y ,0,0,1,1) : si.smoo; // MODEL PARAMETERS // strings lengths sl(i) = kbfreq(i)*kbbend(i) : pm.f2l : si.smoo; // string active only if fingers are touching the keyboard as(i) = kbfingers(i) 0; // retrieving finger displacement on screen (dirt simple) bowVel = y-y' : abs : *(3000) : min(1) : si.smoo; // bow position is constant but could be ontrolled by an external interface bowPos = 0.7; bowPress = 0.5; // ASSEMBLING MODELS // essentially 4 parallel violin strings model = par(i,4,pm.violinModel(sl(i),bowPress,bowVel*as(i),bowPos)) : _; process = model : _,_; Try it Yourself >> violin //############################### violin.dsp ################################### // Faust instrument specifically designed for faust2smartkeyb where a // complete violin physical model can be played using the touch sceen // interface. While the 4 virtual strings can be bowed using a control // surface on the screen, it could be easily substituted with an external // interface. // // ## SmartKeyboard Use Strategy // // 4 keyboards are used to control the pitch of the 4 bowed strings. Strings // are connected to the virtual bow when they are touched. A pad created from // a keybaord with a single key can be used to control the bow velocity and // pressure on the selected strings. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. // However it was specifically designed to be used with faust2smartkeyb. For // best results, we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp violin.dsp // // // ## Version/Licence // // Version 0.0, Aug. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //############################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'5', 'Max Keyboard Polyphony':'0', 'Rounding Mode':'2', 'Send Fingers Count':'1', 'Keyboard 0 - Number of Keys':'19', 'Keyboard 1 - Number of Keys':'19', 'Keyboard 2 - Number of Keys':'19', 'Keyboard 3 - Number of Keys':'19', 'Keyboard 4 - Number of Keys':'1', 'Keyboard 0 - Lowest Key':'55', 'Keyboard 1 - Lowest Key':'62', 'Keyboard 2 - Lowest Key':'69', 'Keyboard 3 - Lowest Key':'76', 'Keyboard 0 - Send Keyboard Freq':'1', 'Keyboard 1 - Send Keyboard Freq':'1', 'Keyboard 2 - Send Keyboard Freq':'1', 'Keyboard 3 - Send Keyboard Freq':'1', 'Keyboard 4 - Send Freq':'0', 'Keyboard 4 - Send Key X':'1', 'Keyboard 4 - Send Key Y':'1', 'Keyboard 4 - Key 0 - Label':'Bow', 'Keyboard 4 - Static Mode':'1' } ; import( stdfaust.lib ); // SMARTKEYBOARD PARAMS kbfreq(0) = hslider( kb0freq ,220,20,10000,0.01); kbbend(0) = hslider( kb0bend ,1,0,10,0.01); kbfreq(1) = hslider( kb1freq ,330,20,10000,0.01); kbbend(1) = hslider( kb1bend ,1,0,10,0.01); kbfreq(2) = hslider( kb2freq ,440,20,10000,0.01); kbbend(2) = hslider( kb2bend ,1,0,10,0.01); kbfreq(3) = hslider( kb3freq ,550,20,10000,0.01); kbbend(3) = hslider( kb3bend ,1,0,10,0.01); kb4k0x = hslider( kb4k0x ,0,0,1,1) : si.smoo; kb4k0y = hslider( kb4k0y ,0,0,1,1) : si.smoo; kbfingers(0) = hslider( kb0fingers ,0,0,10,1) : int; kbfingers(1) = hslider( kb1fingers ,0,0,10,1) : int; kbfingers(2) = hslider( kb2fingers ,0,0,10,1) : int; kbfingers(3) = hslider( kb3fingers ,0,0,10,1) : int; // MODEL PARAMETERS // strings lengths sl(i) = kbfreq(i)*kbbend(i) : pm.f2l : si.smoo; // string active only if fingers are touching the keyboard as(i) = kbfingers(i) 0; // bow pressure could also be controlled by an external parameter bowPress = kb4k0y; // retrieving finger displacement on screen (dirt simple) bowVel = kb4k0x-kb4k0x' : abs : *(8000) : min(1) : si.smoo; // bow position is constant but could be ontrolled by an external interface bowPos = 0.7; // ASSEMBLING MODELS // essentially 4 parallel violin strings model = par(i,4,pm.violinModel(sl(i),bowPress,bowVel*as(i),bowPos)) : _; process = model : _,_; Try it Yourself >> vocal //######################################## vocal.dsp ##################################### // A funny vocal synth app... // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] vocal.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## import( stdfaust.lib ); declare interface SmartKeyboard{ 'Number of Keyboards':'1', 'Max Keyboard Polyphony':'0', 'Keyboard 0 - Number of Keys':'1', 'Keyboard 0 - Send Freq':'0', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Send X':'1', 'Keyboard 0 - Piano Keyboard':'0' } ; // standard parameters vowel = hslider( vowel[acc: 0 0 -10 0 10] ,2,0,4,0.01) : si.smoo; x = hslider( x ,0.5,0,1,0.01) : si.smoo; vibrato = hslider( vibrato[acc: 1 0 -10 0 10] ,0.05,0,0.1,0.01); gain = hslider( gain ,0.25,0,1,0.01); // fomating parameters freq = x*200 + 50; voiceFreq = freq*(os.osc(6)*vibrato+1); process = pm.SFFormantModelBP(1,vowel,0,voiceFreq,gain) : _,_; Try it Yourself >>","title":" smartKeyboard "},{"location":"examples/smartKeyboard/#smartkeyboard","text":"","title":"smartKeyboard"},{"location":"examples/smartKeyboard/#acguitar","text":"//############################### acGuitar.dsp ################################# // Faust instrument specifically designed for faust2smartkeyb where 6 virtual // nylon strings can be strummed and plucked using a dedicated keyboard. The // extra strumming keyboard could be easily replaced by an external strumming // interface while the touch screen could keep being used to change the pitch // of the strings. // // ## SmartKeyboard Use Strategy // // The first 6 keyboards implement each individual string of the instrument. A // seventh keybaord is used a strumming/plucking interface. As mentionned // previously, it could be easily replaced by an external interface. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. // However it was specifically designed to be used with faust2smartkeyb. For // best results, we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp acGuitar.dsp // // // ## Version/Licence // // Version 0.0, Aug. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //############################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'7', 'Max Keyboard Polyphony':'0', 'Rounding Mode':'2', 'Keyboard 0 - Number of Keys':'14', 'Keyboard 1 - Number of Keys':'14', 'Keyboard 2 - Number of Keys':'14', 'Keyboard 3 - Number of Keys':'14', 'Keyboard 4 - Number of Keys':'14', 'Keyboard 5 - Number of Keys':'14', 'Keyboard 6 - Number of Keys':'6', 'Keyboard 0 - Lowest Key':'52', 'Keyboard 1 - Lowest Key':'57', 'Keyboard 2 - Lowest Key':'62', 'Keyboard 3 - Lowest Key':'67', 'Keyboard 4 - Lowest Key':'71', 'Keyboard 5 - Lowest Key':'76', 'Keyboard 0 - Send Keyboard Freq':'1', 'Keyboard 1 - Send Keyboard Freq':'1', 'Keyboard 2 - Send Keyboard Freq':'1', 'Keyboard 3 - Send Keyboard Freq':'1', 'Keyboard 4 - Send Keyboard Freq':'1', 'Keyboard 5 - Send Keyboard Freq':'1', 'Keyboard 6 - Piano Keyboard':'0', 'Keyboard 6 - Send Key Status':'1', 'Keyboard 6 - Key 0 - Label':'S0', 'Keyboard 6 - Key 1 - Label':'S1', 'Keyboard 6 - Key 2 - Label':'S2', 'Keyboard 6 - Key 3 - Label':'S3', 'Keyboard 6 - Key 4 - Label':'S4', 'Keyboard 6 - Key 5 - Label':'S5' } ; import( stdfaust.lib ); // SMARTKEYBOARD PARAMS kbfreq(0) = hslider( kb0freq ,164.8,20,10000,0.01); kbbend(0) = hslider( kb0bend ,1,0,10,0.01); kbfreq(1) = hslider( kb1freq ,220,20,10000,0.01); kbbend(1) = hslider( kb1bend ,1,0,10,0.01); kbfreq(2) = hslider( kb2freq ,293.7,20,10000,0.01); kbbend(2) = hslider( kb2bend ,1,0,10,0.01); kbfreq(3) = hslider( kb3freq ,392,20,10000,0.01); kbbend(3) = hslider( kb3bend ,1,0,10,0.01); kbfreq(4) = hslider( kb4freq ,493.9,20,10000,0.01); kbbend(4) = hslider( kb4bend ,1,0,10,0.01); kbfreq(5) = hslider( kb5freq ,659.2,20,10000,0.01); kbbend(5) = hslider( kb5bend ,1,0,10,0.01); kb6kstatus(0) = hslider( kb6k0status ,0,0,1,1) : ==(1) | ==(4) : int; kb6kstatus(1) = hslider( kb6k1status ,0,0,1,1) : ==(1) | ==(4) : int; kb6kstatus(2) = hslider( kb6k2status ,0,0,1,1) : ==(1) | ==(4) : int; kb6kstatus(3) = hslider( kb6k3status ,0,0,1,1) : ==(1) | ==(4) : int; kb6kstatus(4) = hslider( kb6k4status ,0,0,1,1) : ==(1) | ==(4) : int; kb6kstatus(5) = hslider( kb6k5status ,0,0,1,1) : ==(1) | ==(4) : int; // MODEL PARAMETERS // strings length sl(i) = kbfreq(i)*kbbend(i) : pm.f2l : si.smoo; // pluck position is controlled by the x axis of the accel pluckPosition = hslider( pluckPosition[acc: 1 0 -10 0 10] ,0.5,0,1,0.01) : si.smoo; // ASSEMBLING MODELS // number of strings nStrings = 6; guitar = par(i,nStrings, kb6kstatus(i) : ba.impulsify : // using raw impulses to drive the models pm.nylonGuitarModel(sl(i),pluckPosition)) : _; process = guitar : _,_; Try it Yourself >>","title":"acGuitar"},{"location":"examples/smartKeyboard/#bells","text":"//################################ bells.dsp ################################### // Faust instrument specifically designed for faust2smartkeyb where the // physical models of 4 different bells can be played using screen pads. The // models are taken from physmodels.lib. // // ## SmartKeyboard Use Strategy // // The SmartKeyboard interface is used to implement percussion pads where // the X/Y position of fingers is retrieved to control the strike position on // the bells. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. // However it was specifically designed to be used with faust2smartkeyb. For // best results, we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp bells.dsp // // // ## Version/Licence // // Version 0.0, Aug. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //############################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'2', 'Max Keyboard Polyphony':'0', 'Keyboard 0 - Number of Keys':'2', 'Keyboard 1 - Number of Keys':'2', 'Keyboard 0 - Send Freq':'0', 'Keyboard 1 - Send Freq':'0', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 0 - Send Key Status':'1', 'Keyboard 1 - Send Key Status':'1', 'Keyboard 0 - Send X':'1', 'Keyboard 0 - Send Y':'1', 'Keyboard 1 - Send X':'1', 'Keyboard 1 - Send Y':'1', 'Keyboard 0 - Key 0 - Label':'English Bell', 'Keyboard 0 - Key 1 - Label':'French Bell', 'Keyboard 1 - Key 0 - Label':'German Bell', 'Keyboard 1 - Key 1 - Label':'Russian Bell' } ; import( stdfaust.lib ); // SMARTKEYBOARD PARAMS kb0k0status = hslider( kb0k0status ,0,0,1,1) : min(1) : int; kb0k1status = hslider( kb0k1status ,0,0,1,1) : min(1) : int; kb1k0status = hslider( kb1k0status ,0,0,1,1) : min(1) : int; kb1k1status = hslider( kb1k1status ,0,0,1,1) : min(1) : int; x = hslider( x ,1,0,1,0.001); y = hslider( y ,1,0,1,0.001); // MODEL PARAMETERS strikeCutoff = 6500; strikeSharpness = 0.5; strikeGain = 1; // synthesize 10 modes out of 50 nModes = 10; // resonance duration is 30s t60 = 30; // number of excitation pos (retrieved from model) nExPos = 7; // computing excitation position from X and Y exPos = min((x*2-1 : abs),(y*2-1 : abs))*(nExPos-1) : int; // ASSEMBLING MODELS bells = (kb0k0status : pm.strikeModel(10,strikeCutoff,strikeSharpness,strikeGain) : pm.englishBellModel(nModes,exPos,t60,1,3)) + (kb0k1status : pm.strikeModel(10,strikeCutoff,strikeSharpness,strikeGain) : pm.frenchBellModel(nModes,exPos,t60,1,3)) + (kb1k0status : pm.strikeModel(10,strikeCutoff,strikeSharpness,strikeGain) : pm.germanBellModel(nModes,exPos,t60,1,2.5)) + (kb1k1status : pm.strikeModel(10,strikeCutoff,strikeSharpness,strikeGain) : pm.russianBellModel(nModes,exPos,t60,1,3)) : *(0.2); process = bells : _,_; Try it Yourself >>","title":"bells"},{"location":"examples/smartKeyboard/#bowed","text":"//##################################### bowed.dsp ######################################## // Faust instrument specifically designed for faust2smartkeyb implementing a // non-polyphonic synthesizer (e.g., physical model; etc.) using a combination of // different types of UI elements. // // ## SmartKeyboard Use Strategy // // 5 keyboards are declared (4 actual keyboards and 1 control surface). We want to // disable the voice allocation system and we want to activate a voice on start-up // so that all strings are constantly running so we set Max Keyboard Polyphony to // 0. Since we don't want the first 4 keyboards to send the X and Y position of // fingers on the screen, we set Send X and Send Y to 0 for all these keyboards. // Similarly, we don't want the fifth keyboard to send pitch information to the synth // so we set Send Freq to 0 for that keyboard. Finally, we deactivate piano keyboard // mode for the fifth keyboard to make sure that color doesn't change when the key is // touch and that note names are not displayed. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp midiOnly.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'5', 'Max Keyboard Polyphony':'0', 'Rounding Mode':'1', 'Keyboard 0 - Number of Keys':'19', 'Keyboard 1 - Number of Keys':'19', 'Keyboard 2 - Number of Keys':'19', 'Keyboard 3 - Number of Keys':'19', 'Keyboard 4 - Number of Keys':'1', 'Keyboard 4 - Send Freq':'0', 'Keyboard 0 - Send X':'0', 'Keyboard 1 - Send X':'0', 'Keyboard 2 - Send X':'0', 'Keyboard 3 - Send X':'0', 'Keyboard 0 - Send Y':'0', 'Keyboard 1 - Send Y':'0', 'Keyboard 2 - Send Y':'0', 'Keyboard 3 - Send Y':'0', 'Keyboard 0 - Lowest Key':'55', 'Keyboard 1 - Lowest Key':'62', 'Keyboard 2 - Lowest Key':'69', 'Keyboard 3 - Lowest Key':'76', 'Keyboard 4 - Piano Keyboard':'0', 'Keyboard 4 - Key 0 - Label':'Bow' } ; import( stdfaust.lib ); // parameters f = hslider( freq ,400,50,2000,0.01); bend = hslider( bend ,1,0,10,0.01); keyboard = hslider( keyboard ,0,0,5,1) : int; key = hslider( key ,0,0,18,1) : int; x = hslider( x ,0.5,0,1,0.01) : si.smoo; y = hslider( y ,0,0,1,0.01) : si.smoo; // mapping freq = f*bend; // dirty motion tracker velocity = x-x' : abs : an.amp_follower_ar(0.1,1) : *(8000) : min(1); // 4 strings synthSet = par(i,4,synth(localFreq(i),velocity)) : _ with{ localFreq(i) = freq : ba.sAndH(keyboard == i) : si.smoo; synth(freq,velocity) = sy.fm((freq,freq + freq*modFreqRatio),index*velocity)*velocity with{ index = 1000; modFreqRatio = y*0.3; }; }; process = synthSet : _,_; Try it Yourself >>","title":"bowed"},{"location":"examples/smartKeyboard/#brass","text":"//############################### brass.dsp ################################### // Faust instrument specifically designed for faust2smartkeyb where a // trumpet physical model is controlled using some of the built-in sensors of // the device and the touchscreen. Some of these elements could be replaced by // external controllers (e.g., breath/mouth piece controller). // // ## SmartKeyboard Use Strategy // // 1 keyboard is used to implement the pistons of the trumpet (3 keys) and the // other allows to control the lips tension. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. // However it was specifically designed to be used with faust2smartkeyb. For // best results, we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp brass.dsp // // // ## Version/Licence // // Version 0.0, Aug. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //############################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'2', 'Max Keyboard Polyphony':'0', 'Keyboard 0 - Number of Keys':'1', 'Keyboard 1 - Number of Keys':'3', 'Keyboard 0 - Send Freq':'0', 'Keyboard 1 - Send Freq':'0', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 0 - Send Key X':'1', 'Keyboard 1 - Send Key Status':'1', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Key 0 - Label':'Lips Tension', 'Keyboard 1 - Key 0 - Label':'P1', 'Keyboard 1 - Key 1 - Label':'P2', 'Keyboard 1 - Key 2 - Label':'P3' } ; import( stdfaust.lib ); // SMARTKEYBOARD PARAMS kb0k0x = hslider( kb0k0x ,0,0,1,1); kb1k0status = hslider( kb1k0status ,0,0,1,1) : min(1) : int; kb1k1status = hslider( kb1k1status ,0,0,1,1) : min(1) : int; kb1k2status = hslider( kb1k2status ,0,0,1,1) : min(1) : int; // MODEL PARAMETERS // pressure is controlled by accelerometer pressure = hslider( pressure[acc: 1 1 -10 0 10] ,0,0,1,0.01) : si.smoo; breathGain = 0.005; breathCutoff = 2000; vibratoFreq = 5; vibratoGain = 0; //pitch when no pistons are pushed basePitch = 48; // C4 // calculate pitch shift in function of piston combination pitchShift = ((kb1k0status == 0) (kb1k1status == 1) (kb1k2status == 0))*(1) + ((kb1k0status == 1) (kb1k1status == 0) (kb1k2status == 0))*(2) + ((kb1k0status == 1) (kb1k1status == 1) (kb1k2status == 0))*(3) + ((kb1k0status == 0) (kb1k1status == 1) (kb1k2status == 1))*(4) + ((kb1k0status == 1) (kb1k1status == 0) (kb1k2status == 1))*(5) + ((kb1k0status == 1) (kb1k1status == 1) (kb1k2status == 1))*(6); // tube length is calculated based on piston combination tubeLength = basePitch-pitchShift : ba.midikey2hz : pm.f2l : si.smoo; // lips tension is controlled using pad on screen lipsTension = kb0k0x : si.smoo; // default mute value mute = 0.5; // ASSEMBLING MODEL model = pm.blower(pressure,breathGain,breathCutoff,vibratoFreq,vibratoGain) : pm.brassModel(tubeLength,lipsTension,mute); process = model : _,_; Try it Yourself >>","title":"brass"},{"location":"examples/smartKeyboard/#clarinet","text":"//############################### clarinet.dsp ################################# // Faust instrument specifically designed for faust2smartkeyb where a // clarinet physical model is controlled by an interface implementing // fingerings similar to that of a the real instrument. The pressure of the // breath in the mouthpiece of the clarinet is controlled by blowing on the // built-in microphone of the device. // // ## SmartKeyboard Use Strategy // // The device is meant to be held with 2 hands vertically in order to put all // fingers on the screen at the same time. Key combinations determine the // pitch of the instrument. A single voice is constantly ran. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. // However it was specifically designed to be used with faust2smartkeyb. For // best results, we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] clarinet.dsp // // // ## Version/Licence // // Version 0.0, Aug. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //############################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'2', 'Max Keyboard Polyphony':'0', 'Keyboard 0 - Number of Keys':'4', 'Keyboard 1 - Number of Keys':'5', 'Keyboard 0 - Send Freq':'0', 'Keyboard 1 - Send Freq':'0', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 0 - Send Key Status':'1', 'Keyboard 1 - Send Key Status':'1', 'Keyboard 0 - Key 3 - Label':'O+', 'Keyboard 1 - Key 4 - Label':'O-' } ; import( stdfaust.lib ); // SMARTKEYBOARD PARAMS kb0k0status = hslider( kb0k0status ,0,0,1,1) : min(1) : int; kb0k1status = hslider( kb0k1status ,0,0,1,1) : min(1) : int; kb0k2status = hslider( kb0k2status ,0,0,1,1) : min(1) : int; kb0k3status = hslider( kb0k3status ,0,0,1,1) : min(1) : int; kb1k0status = hslider( kb1k0status ,0,0,1,1) : min(1) : int; kb1k1status = hslider( kb1k1status ,0,0,1,1) : min(1) : int; kb1k2status = hslider( kb1k2status ,0,0,1,1) : min(1) : int; kb1k3status = hslider( kb1k3status ,0,0,1,1) : min(1) : int; kb1k4status = hslider( kb1k4status ,0,0,1,1) : min(1) : int; // MODEL PARAMETERS reedStiffness = hslider( reedStiffness[acc: 1 1 -10 0 10] ,0,0,1,0.01) : si.smoo; basePitch = 73; // C#4 pitchShift = // calculate pitch shfit in function of keys combination ((kb0k0status == 0) (kb0k1status == 1) (kb0k2status == 0) (kb1k0status == 0) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-1) + // C ((kb0k0status == 1) (kb0k1status == 0) (kb0k2status == 0) (kb1k0status == 0) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-2) + // B ((kb0k0status == 1) (kb0k1status == 0) (kb0k2status == 1) (kb1k0status == 0) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-3) + // Bb ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 0) (kb1k0status == 0) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-4) + // A ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 0) (kb1k0status == 1) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-5) + // G# ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 0) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-6) + // G ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 0) (kb1k1status == 1) (kb1k2status == 0) (kb1k3status == 0))*(-7) + // F# ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 1) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 0))*(-8) + // F ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 1) (kb1k1status == 1) (kb1k2status == 0) (kb1k3status == 0))*(-9) + // E ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 1) (kb1k1status == 1) (kb1k2status == 0) (kb1k3status == 1))*(-10) + // Eb ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 1) (kb1k1status == 1) (kb1k2status == 1) (kb1k3status == 0))*(-11) + // D ((kb0k0status == 0) (kb0k1status == 0) (kb0k2status == 0) (kb1k0status == 0) (kb1k1status == 0) (kb1k2status == 0) (kb1k3status == 1))*(-12) + // C# ((kb0k0status == 1) (kb0k1status == 1) (kb0k2status == 1) (kb1k0status == 1) (kb1k1status == 1) (kb1k2status == 1) (kb1k3status == 1))*(-13); // C octaveShiftUp = +(kb0k3status : ba.impulsify)~_; // counting up octaveShiftDown = +(kb1k4status : ba.impulsify)~_; // counting down octaveShift = (octaveShiftUp-octaveShiftDown)*(12); // tube length is just smoothed: could be improved tubeLength = basePitch+pitchShift+octaveShift : ba.midikey2hz : pm.f2l : si.smoo; bellOpening = 0.5; // ASSEMBLING MODEL model(pressure) = pm.clarinetModel(tubeLength,pressure,reedStiffness,bellOpening); // pressure is estimated from mic signal process = an.amp_follower_ud(0.02,0.02)*0.7 : model : _,_; Try it Yourself >>","title":"clarinet"},{"location":"examples/smartKeyboard/#crazyguiro","text":"//################################### crazyGuiro.dsp ##################################### // A simple smart phone Guiro where the touch screen is used to drive the instrument and // select its pitch and where the x and y axis of the accelerometer control the // resonance properties of the instrument. // // ## SmartKeyboard Use Strategy // // Since the sounds generated by this synth are very short, the strategy here is to take // advantage of the polyphony capabilities of the iOSKeyboard architecture by creating // a new voice every time a new key is pressed. Since the SmartKeyboard interface has a // large number of keys here (128), lots of sounds are generated when sliding a // finger across the keyboard. Also, it's interesting to notice that the freq parameter // is not used here. Instead keyboard and key are used which allows us to easily // make custom mappings. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] crazyGuiro.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## import( stdfaust.lib ); //========================= Smart Keyboard Configuration ================================= // 8 keyboards, each has 16 keys, none of them display key names. //======================================================================================== declare interface SmartKeyboard{ 'Number of Keyboards':'8', 'Keyboard 0 - Number of Keys':'16', 'Keyboard 1 - Number of Keys':'16', 'Keyboard 2 - Number of Keys':'16', 'Keyboard 3 - Number of Keys':'16', 'Keyboard 4 - Number of Keys':'16', 'Keyboard 5 - Number of Keys':'16', 'Keyboard 6 - Number of Keys':'16', 'Keyboard 7 - Number of Keys':'16', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 2 - Piano Keyboard':'0', 'Keyboard 3 - Piano Keyboard':'0', 'Keyboard 4 - Piano Keyboard':'0', 'Keyboard 5 - Piano Keyboard':'0', 'Keyboard 6 - Piano Keyboard':'0', 'Keyboard 7 - Piano Keyboard':'0' } ; //================================ Instrument Parameters ================================= // Creates the connection between the synth and the mobile device //======================================================================================== // the current keyboard keyboard = hslider( keyboard ,0,0,2,1); // the current key of the current keyboard key = hslider( key ,0,0,2,1); // the wet factor of the reverb wet = hslider( wet[acc: 0 0 -10 0 10] ,0,0,1,0.01); // the resonance factor of the reverb res = hslider( res[acc: 1 0 -10 0 10] ,0.5,0,1,0.01); // smart keyboard gate parameter gate = button( gate ); //=================================== Parameters Mapping ================================= //======================================================================================== // the resonance frequency of each click of the Guiro changes in function of // the selected keyboard and key on it minKey = 50; // min key of lowest keyboard keySkipKeyboard = 8; // key skip per keyboard drumResFreq = (key+minKey)+(keyboard*keySkipKeyboard) : ba.midikey2hz; reverbWet = wet : si.smoo; reverbRes = wet : si.smoo; // filter q q = 8; //============================================ DSP ======================================= //======================================================================================== reverb(wet,res) = _ : *(1-wet),(*(wet) : re.mono_freeverb(res, 0.5, 0.5, 0)) : _; process = sy.popFilterDrum(drumResFreq,q,gate) : reverb(wet,res) : _,_; Try it Yourself >>","title":"crazyGuiro"},{"location":"examples/smartKeyboard/#drums","text":"//##################################### drums.dsp ######################################## // Faust instrument specifically designed for faust2smartkeyb where 3 drums can // be controlled using pads. The X/Y postion of fingers is detected on each key // and use to control the strike postion on the virtual membrane. // // ## SmartKeyboard Use Strategy // // The drum physical model used here is implemented to be generic so that its // fundamental frequency can be changed for each voice. SmartKeyboard is used // in polyphonic mode so each new strike on the interface corresponds to a new // new voice. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp drums.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## // Interface with 2 keyboards of 2 and 1 keys (3 pads) // Static mode is used so that keys don't change color when touched // Note labels are hidden // Piano Keyboard mode is deactivated so all the keys look the same declare interface SmartKeyboard{ 'Number of Keyboards':'2', 'Keyboard 0 - Number of Keys':'2', 'Keyboard 1 - Number of Keys':'1', 'Keyboard 0 - Static Mode':'1', 'Keyboard 1 - Static Mode':'1', 'Keyboard 0 - Send X':'1', 'Keyboard 0 - Send Y':'1', 'Keyboard 1 - Send X':'1', 'Keyboard 1 - Send Y':'1', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 0 - Key 0 - Label':'High', 'Keyboard 0 - Key 1 - Label':'Mid', 'Keyboard 1 - Key 0 - Label':'Low' } ; import( stdfaust.lib ); // standard parameters gate = button( gate ); x = hslider( x ,1,0,1,0.001); y = hslider( y ,1,0,1,0.001); keyboard = hslider( keyboard ,0,0,1,1) : int; key = hslider( key ,0,0,1,1) : int; drumModel = pm.djembe(rootFreq,exPos,strikeSharpness,gain,gate) with{ // frequency of the lowest drum bFreq = 60; // retrieving pad ID (0-2) padID = 2-(keyboard*2+key); // drum root freq is computed in function of pad number rootFreq = bFreq*(padID+1); // excitation position exPos = min((x*2-1 : abs),(y*2-1 : abs)); strikeSharpness = 0.5; gain = 2; }; process = drumModel : _,_; Try it Yourself >>","title":"drums"},{"location":"examples/smartKeyboard/#dubdub","text":"//################################### dubDub.dsp ##################################### // A simple smartphone abstract instrument than can be controlled using the touch // screen and the accelerometers of the device. // // ## SmartKeyboard Use Strategy // // The idea here is to use the SmartKeyboard interface as an X/Y control pad by just // creating one keyboard with on key and by retrieving the X and Y position on that single // key using the x and y standard parameters. Keyboard mode is deactivated so that // the color of the pad doesn't change when it is pressed. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] dubDub.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## declare name dubDub ; import( stdfaust.lib ); //========================= Smart Keyboard Configuration ================================= // (1 keyboards with 1 key configured as a pad. //======================================================================================== declare interface SmartKeyboard{ 'Number of Keyboards':'1', 'Keyboard 0 - Number of Keys':'1', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Send X':'1', 'Keyboard 0 - Send Y':'1' } ; //================================ Instrument Parameters ================================= // Creates the connection between the synth and the mobile device //======================================================================================== // SmartKeyboard X parameter x = hslider( x ,0,0,1,0.01); // SmartKeyboard Y parameter y = hslider( y ,0,0,1,0.01); // SmartKeyboard gate parameter gate = button( gate ); // modulation frequency is controlled with the x axis of the accelerometer modFreq = hslider( modFeq[acc: 0 0 -10 0 10] ,9,0.5,18,0.01); // general gain is controlled with the y axis of the accelerometer gain = hslider( gain[acc: 1 0 -10 0 10] ,0.5,0,1,0.01); //=================================== Parameters Mapping ================================= //======================================================================================== // sawtooth frequency minFreq = 80; maxFreq = 500; freq = x*(maxFreq-minFreq) + minFreq : si.polySmooth(gate,0.999,1); // filter q q = 8; // filter cutoff frequency is modulate with a triangle wave minFilterCutoff = 50; maxFilterCutoff = 5000; filterModFreq = modFreq : si.smoo; filterCutoff = (1-os.lf_trianglepos(modFreq)*(1-y))*(maxFilterCutoff-minFilterCutoff)+minFilterCutoff; // general gain of the synth generalGain = gain : ba.lin2LogGain : si.smoo; //============================================ DSP ======================================= //======================================================================================== process = sy.dubDub(freq,filterCutoff,q,gate)*generalGain : _,_; Try it Yourself >>","title":"dubDub"},{"location":"examples/smartKeyboard/#elecguitar","text":"//################################### elecGuitar.dsp ##################################### // Faust instruments specifically designed for faust2smartkeyb where an electric // guitar physical model is controlled using an isomorphic keyboard. Rock on! // // ## SmartKeyboard Use Strategy // // we want to create an isomorphic keyboard where each keyboard is monophonic and // implements a string . Keyboards should be one fourth apart from each other // (more or less like on a guitar). We want to be able to slide between keyboards // (strum) to trigger a new note (voice) and we want new fingers on a keyboard to // steal the pitch from the previous finger (sort of hammer on). // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect elecGuitarEffecr.dsp elecGuitar.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017: // https://ccrma.stanford.edu/~rmichon // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## // Interface with 6 monophonic keyboards one fourth apart from each other declare interface SmartKeyboard{ 'Number of Keyboards':'6', 'Max Keyboard Polyphony':'1', 'Keyboard 0 - Number of Keys':'13', 'Keyboard 1 - Number of Keys':'13', 'Keyboard 2 - Number of Keys':'13', 'Keyboard 3 - Number of Keys':'13', 'Keyboard 4 - Number of Keys':'13', 'Keyboard 5 - Number of Keys':'13', 'Keyboard 0 - Lowest Key':'72', 'Keyboard 1 - Lowest Key':'67', 'Keyboard 2 - Lowest Key':'62', 'Keyboard 3 - Lowest Key':'57', 'Keyboard 4 - Lowest Key':'52', 'Keyboard 5 - Lowest Key':'47', 'Rounding Mode':'2' } ; import( stdfaust.lib ); // standard parameters f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01) : si.polySmooth(gate,0.999,1); gain = hslider( gain ,1,0,1,0.01); s = hslider( sustain[midi:ctrl 64] ,0,0,1,1); // for sustain pedal t = button( gate ); // mapping params gate = t+s : min(1); freq = f*bend : max(60); // min freq is 60 Hz stringLength = freq : pm.f2l; pluckPosition = 0.8; mute = gate : si.polySmooth(gate,0.999,1); process = pm.elecGuitar(stringLength,pluckPosition,mute,gain,gate) : _,_; Try it Yourself >>","title":"elecGuitar"},{"location":"examples/smartKeyboard/#fm","text":"//###################################### fm.dsp ########################################## // A simple smart phone percussion abstract sound toy based on an FM synth. // // ## SmartKeyboard Use Strategy // // The idea here is to use the SmartKeyboard interface as an X/Y control pad by just // creating one keyboard with on key and by retrieving the X and Y position on that single // key using the x and y standard parameters. Keyboard mode is deactivated so that // the color of the pad doesn't change when it is pressed. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] crazyGuiro.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## declare name fm ; import( stdfaust.lib ); //========================= Smart Keyboard Configuration ================================= // (1 keyboards with 1 key configured as a pad. //======================================================================================== declare interface SmartKeyboard{ 'Number of Keyboards':'1', 'Keyboard 0 - Number of Keys':'1', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Send X':'1', 'Keyboard 0 - Send Y':'1' } ; //================================ Instrument Parameters ================================= // Creates the connection between the synth and the mobile device //======================================================================================== // SmartKeyboard X parameter x = hslider( x ,0,0,1,0.01); // SmartKeyboard Y parameter y = hslider( y ,0,0,1,0.01); // SmartKeyboard gate parameter gate = button( gate ) ; // mode resonance duration is controlled with the x axis of the accelerometer modFreqRatio = hslider( res[acc: 0 0 -10 0 10] ,1,0,2,0.01) : si.smoo; //=================================== Parameters Mapping ================================= //======================================================================================== // carrier frequency minFreq = 80; maxFreq = 500; cFreq = x*(maxFreq-minFreq) + minFreq : si.polySmooth(gate,0.999,1); // modulator frequency modFreq = cFreq*modFreqRatio; // modulation index modIndex = y*1000 : si.smoo; //============================================ DSP ======================================= //======================================================================================== // since the generated sound is pretty chaotic, there is no need for an envelope generator fmSynth = sy.fm((cFreq,modFreq),(modIndex))*(gate : si.smoo)*0.5; process = fmSynth; Try it Yourself >>","title":"fm"},{"location":"examples/smartKeyboard/#frog","text":"//################################### frog.dsp ##################################### // A simple smart phone abstract instrument than can be controlled using the touch // screen and the accelerometers of the device. // // ## SmartKeyboard Use Strategy // // The idea here is to use the SmartKeyboard interface as an X/Y control pad by just // creating one keyboard with on key and by retrieving the X and Y position on that single // key using the x and y standard parameters. Keyboard mode is deactivated so that // the color of the pad doesn't change when it is pressed. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] frog.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## declare name frog ; import( stdfaust.lib ); //========================= Smart Keyboard Configuration ================================= // (1 keyboards with 1 key configured as a pad. //======================================================================================== declare interface SmartKeyboard{ 'Number of Keyboards':'1', 'Keyboard 0 - Number of Keys':'1', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Send X':'1', 'Keyboard 0 - Send Y':'1' } ; //================================ Instrument Parameters ================================= // Creates the connection between the synth and the mobile device //======================================================================================== // SmartKeyboard X parameter x = hslider( x ,0,0,1,0.01); // SmartKeyboard Y parameter y = hslider( y ,0,0,1,0.01); // SmartKeyboard gate parameter gate = button( gate ); // the cutoff frequency of the filter is controlled with the x axis of the accelerometer cutoff = hslider( cutoff[acc: 0 0 -10 0 10] ,2500,50,5000,0.01); //=================================== Parameters Mapping ================================= //======================================================================================== maxFreq = 100; minFreq = 1; freq = x*(maxFreq-minFreq) + minFreq : si.polySmooth(gate,0.999,1); maxQ = 40; minQ = 1; q = (1-y)*(maxQ-minQ) + minQ : si.smoo; filterCutoff = cutoff : si.smoo; //============================================ DSP ======================================= //======================================================================================== process = sy.dubDub(freq,filterCutoff,q,gate) : _,_; Try it Yourself >>","title":"frog"},{"location":"examples/smartKeyboard/#harp","text":"//######################################## harp.dsp ###################################### // A simple smart phone based harp (if we dare to call it like that). // // ## SmartKeyboard Use Strategy // // Since the sounds generated by this synth are very short, the strategy here is to take // advantage of the polyphony capabilities of the iOSKeyboard architecture by creating // a new voice every time a new key is pressed. Since the SmartKeyboard interface has a // large number of keys here (128), lots of sounds are generated when sliding a // finger across the keyboard. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] harp.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## declare name harp ; import( stdfaust.lib ); //========================= Smart Keyboard Configuration ================================= // (8 keyboards with 16 keys configured as a pitch matrix. //======================================================================================== declare interface SmartKeyboard{ 'Number of Keyboards':'8', 'Keyboard 0 - Number of Keys':'16', 'Keyboard 1 - Number of Keys':'16', 'Keyboard 2 - Number of Keys':'16', 'Keyboard 3 - Number of Keys':'16', 'Keyboard 4 - Number of Keys':'16', 'Keyboard 5 - Number of Keys':'16', 'Keyboard 6 - Number of Keys':'16', 'Keyboard 7 - Number of Keys':'16', 'Keyboard 0 - Lowest Key':'40', 'Keyboard 1 - Lowest Key':'45', 'Keyboard 2 - Lowest Key':'50', 'Keyboard 3 - Lowest Key':'55', 'Keyboard 4 - Lowest Key':'60', 'Keyboard 5 - Lowest Key':'65', 'Keyboard 6 - Lowest Key':'70', 'Keyboard 7 - Lowest Key':'75', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 2 - Piano Keyboard':'0', 'Keyboard 3 - Piano Keyboard':'0', 'Keyboard 4 - Piano Keyboard':'0', 'Keyboard 5 - Piano Keyboard':'0', 'Keyboard 6 - Piano Keyboard':'0', 'Keyboard 7 - Piano Keyboard':'0' } ; //================================ Instrument Parameters ================================= // Creates the connection between the synth and the mobile device //======================================================================================== // the string resonance in second is controlled by the x axis of the accelerometer res = hslider( res[acc: 0 0 -10 0 10] ,2,0.1,4,0.01); // Smart Keyboard frequency parameter freq = hslider( freq ,400,50,2000,0.01); // Smart Keyboard gate parameter gate = button( gate ); //=================================== Parameters Mapping ================================= //======================================================================================== stringFreq = freq; //============================================ DSP ======================================= //======================================================================================== process = sy.combString(freq,res,gate); Try it Yourself >>","title":"harp"},{"location":"examples/smartKeyboard/#midionly","text":"//################################### midiOnly.dsp ###################################### // Faust instrument specifically designed for faust2smartkeyb implementing a MIDI // controllable app where the mobile device's touch screen is used to control // specific parameters of the synth continuously using two separate X/Y control surfaces. // // ## SmartKeyboard Use Strategy // // The SmartKeyboard configuration for this instrument consists in a single keyboard // with two keys. Each key implements a control surface. Piano Keyboard mode is // disabled so that key names are not displayed and that keys don't change color when // touched. Finally, Send Freq is set to 0 so that new voices are not allocated by // the touch screen and that the freq and bend parameters are not computed. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp midiOnly.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## // Interface with 4 polyphnic keyboards of 13 keys with the same config declare interface SmartKeyboard{ 'Number of Keyboards':'1', 'Keyboard 0 - Number of Keys':'2', 'Keyboard 0 - Send Freq':'0', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Send Key X':'1', 'Keyboard 0 - Key 0 - Label':'Mod Index', 'Keyboard 0 - Key 1 - Label':'Mod Freq' } ; import( stdfaust.lib ); f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01) : si.polySmooth(gate,0.999,1); gain = hslider( gain ,1,0,1,0.01); key = hslider( key ,0,0,1,1) : int; kb0k0x = hslider( kb0k0x[midi:ctrl 1] ,0.5,0,1,0.01) : si.smoo; kb0k1x = hslider( kb0k1x[midi:ctrl 1] ,0.5,0,1,0.01) : si.smoo; s = hslider( sustain[midi:ctrl 64] ,0,0,1,1); t = button( gate ); // fomating parameters gate = t+s : min(1); freq = f*bend; index = kb0k0x*1000; modFreqRatio = kb0k1x; envelope = gain*gate : si.smoo; process = sy.fm((freq,freq + freq*modFreqRatio),index*envelope)*envelope : _,_; Try it Yourself >>","title":"midiOnly"},{"location":"examples/smartKeyboard/#multisynth","text":"//################################### multiSynth.dsp ###################################### // Faust instrument specifically designed for faust2smartkeyb where 4 keyboards // are used to control 4 independent synths. // // ## SmartKeyboard Use Strategy // // The SmartKeyboard configuration is relatively simple for this example and // only consists in four polyphonic keyboards in parallel. The keyboard standard // parameter is used to activate specific elements of the synthesizer. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp multiSynth.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## // Interface with 4 polyphnic keyboards of 13 keys with the same config declare interface SmartKeyboard{ 'Number of Keyboards':'4', 'Rounding Mode':'2', 'Inter-Keyboard Slide':'0', 'Keyboard 0 - Number of Keys':'13', 'Keyboard 1 - Number of Keys':'13', 'Keyboard 2 - Number of Keys':'13', 'Keyboard 3 - Number of Keys':'13', 'Keyboard 0 - Lowest Key':'60', 'Keyboard 1 - Lowest Key':'60', 'Keyboard 2 - Lowest Key':'60', 'Keyboard 3 - Lowest Key':'60', 'Keyboard 0 - Send Y':'1', 'Keyboard 1 - Send Y':'1', 'Keyboard 2 - Send Y':'1', 'Keyboard 3 - Send Y':'1' } ; import( stdfaust.lib ); // standard parameters f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01) : si.polySmooth(gate,0.999,1); gain = hslider( gain ,1,0,1,0.01); s = hslider( sustain[midi:ctrl 64] ,0,0,1,1); // for sustain pedal t = button( gate ); y = hslider( y[midi:ctrl 1] ,1,0,1,0.001) : si.smoo; keyboard = hslider( keyboard ,0,0,3,1) : int; // fomating parameters gate = t+s : min(1); freq = f*bend; cutoff = y*4000+50; // oscillators oscilators(0) = os.sawtooth(freq); oscilators(1) = os.triangle(freq); oscilators(2) = os.square(freq); oscilators(3) = os.osc(freq); // oscs are selected in function of the current keyboard synths = par(i,4,select2(keyboard == i,0,oscilators(i))) : fi.lowpass(3,cutoff) : *(envelope) with{ envelope = gate*gain : si.smoo; }; process = synths : _,_; Try it Yourself >>","title":"multiSynth"},{"location":"examples/smartKeyboard/#toy","text":"//##################################### toy.dsp ####################################### // Faust sound toy specifically designed for faust2smartkeyb where a funny // synth can be controlled using several fingers on the screen and the built-in // accelerometer. // // ## SmartKeyboard Use Strategy // // We just want a blank screen where the position of the different fingers on // the screen can be tracked and retrieved in the Faust object. For that, we // create one keyboard with one key, that should fill the screen. We ask the // interface to not compute the freq and bend parameters to save // computation by setting 'Keyboard 0 - Send Freq':'0'. We don't want the // color of the key to change when it is touched so we deactivate the // Piano Keyboard mode. Fingers should be numbered to be able to use the // numbered x and y parameters (x0, y0, x1, etc.), so Count Fingers // is enabled. Finally, by setting Max Keyboard Polyphony to 0, we deactivate // the voice allocation system and we automatically start a voice when the app // is launched. This means that fingers are no longer associated to specific voices. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] toy.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017: // https://ccrma.stanford.edu/~rmichon // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## // X/Y interface: one keyboard with one key // freq and bend are not computed // fingers are counted // voice is launched on startup declare interface SmartKeyboard{ 'Number of Keyboards':'1', 'Max Keyboard Polyphony':'0', 'Keyboard 0 - Number of Keys':'1', 'Keyboard 0 - Send Freq':'0', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 0 - Send Numbered X':'1', 'Keyboard 0 - Send Numbered Y':'1' } ; import( stdfaust.lib ); // parameters x0 = hslider( x0 ,0.5,0,1,0.01) : si.smoo; y0 = hslider( y0 ,0.5,0,1,0.01) : si.smoo; y1 = hslider( y1 ,0,0,1,0.01) : si.smoo; q = hslider( q[acc: 0 0 -10 0 10] ,30,10,50,0.01) : si.smoo; del = hslider( del[acc: 0 0 -10 0 10] ,0.5,0.01,1,0.01) : si.smoo; fb = hslider( fb[acc: 1 0 -10 0 10] ,0.5,0,1,0.01) : si.smoo; // mapping impFreq = 2 + x0*20; resFreq = y0*3000+300; // simple echo effect echo = +~(de.delay(65536,del*ma.SR)*fb); // putting it together process = os.lf_imptrain(impFreq) : fi.resonlp(resFreq,q,1) : echo : ef.cubicnl(y1,0)*0.95 : _,_; Try it Yourself >>","title":"toy"},{"location":"examples/smartKeyboard/#trumpet","text":"//################################### trumpet.dsp ##################################### // A simple trumpet app... (for large screens). // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp trumpet.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## import( stdfaust.lib ); declare interface SmartKeyboard{ 'Number of Keyboards':'5', 'Max Keyboard Polyphony':'1', 'Mono Mode':'1', 'Keyboard 0 - Number of Keys':'13', 'Keyboard 1 - Number of Keys':'13', 'Keyboard 2 - Number of Keys':'13', 'Keyboard 3 - Number of Keys':'13', 'Keyboard 4 - Number of Keys':'13', 'Keyboard 0 - Lowest Key':'77', 'Keyboard 1 - Lowest Key':'72', 'Keyboard 2 - Lowest Key':'67', 'Keyboard 3 - Lowest Key':'62', 'Keyboard 4 - Lowest Key':'57', 'Rounding Mode':'2', 'Keyboard 0 - Send Y':'1', 'Keyboard 1 - Send Y':'1', 'Keyboard 2 - Send Y':'1', 'Keyboard 3 - Send Y':'1', 'Keyboard 4 - Send Y':'1', } ; // standard parameters f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01) : si.polySmooth(gate,0.999,1); gain = hslider( gain ,1,0,1,0.01); s = hslider( sustain[midi:ctrl 64] ,0,0,1,1); // for sustain pedal t = button( gate ); y = hslider( y[midi:ctrl 1] ,1,0,1,0.001) : si.smoo; // fomating parameters gate = t+s : min(1); freq = f*bend; cutoff = y*4000+50; envelope = gate*gain : si.smoo; process = os.sawtooth(freq)*envelope : fi.lowpass(3,cutoff) : _,_; Try it Yourself >>","title":"trumpet"},{"location":"examples/smartKeyboard/#turenas","text":"//################################### turenas.dsp ######################################## // A simple smart phone percussion based on an additive synthesizer. // // ## SmartKeyboard Use Strategy // // Since the sounds generated by this synth are very short, the strategy here is to take // advantage of the polyphony capabilities of the iOSKeyboard architecture by creating // a new voice every time a new key is pressed. Since the SmartKeyboard interface has a // large number of keys here (180), lots of sounds are generated when sliding a // finger across the keyboard. // // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] turenas.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## declare name turenas ; import( stdfaust.lib ); //========================= Smart Keyboard Configuration ================================= // (10 keyboards with 18 keys each configured as a pitch matrix. //======================================================================================== declare interface SmartKeyboard{ 'Number of Keyboards':'10', 'Keyboard 0 - Number of Keys':'18', 'Keyboard 1 - Number of Keys':'18', 'Keyboard 2 - Number of Keys':'18', 'Keyboard 3 - Number of Keys':'18', 'Keyboard 4 - Number of Keys':'18', 'Keyboard 5 - Number of Keys':'18', 'Keyboard 6 - Number of Keys':'18', 'Keyboard 7 - Number of Keys':'18', 'Keyboard 8 - Number of Keys':'18', 'Keyboard 9 - Number of Keys':'18', 'Keyboard 0 - Lowest Key':'50', 'Keyboard 1 - Lowest Key':'55', 'Keyboard 2 - Lowest Key':'60', 'Keyboard 3 - Lowest Key':'65', 'Keyboard 4 - Lowest Key':'70', 'Keyboard 5 - Lowest Key':'75', 'Keyboard 6 - Lowest Key':'80', 'Keyboard 7 - Lowest Key':'85', 'Keyboard 8 - Lowest Key':'90', 'Keyboard 9 - Lowest Key':'95', 'Keyboard 0 - Piano Keyboard':'0', 'Keyboard 1 - Piano Keyboard':'0', 'Keyboard 2 - Piano Keyboard':'0', 'Keyboard 3 - Piano Keyboard':'0', 'Keyboard 4 - Piano Keyboard':'0', 'Keyboard 5 - Piano Keyboard':'0', 'Keyboard 6 - Piano Keyboard':'0', 'Keyboard 7 - Piano Keyboard':'0', 'Keyboard 8 - Piano Keyboard':'0', 'Keyboard 9 - Piano Keyboard':'0', 'Keyboard 0 - Send X':'0', 'Keyboard 1 - Send X':'0', 'Keyboard 2 - Send X':'0', 'Keyboard 3 - Send X':'0', 'Keyboard 4 - Send X':'0', 'Keyboard 5 - Send X':'0', 'Keyboard 6 - Send X':'0', 'Keyboard 7 - Send X':'0', 'Keyboard 8 - Send X':'0', 'Keyboard 9 - Send X':'0' } ; //================================ Instrument Parameters ================================= // Creates the connection between the synth and the mobile device //======================================================================================== // SmartKeyboard Y parameter y = hslider( y ,0,0,1,0.01); // Smart Keyboard frequency parameter freq = hslider( freq ,400,50,2000,0.01); // SmartKeyboard gate parameter gate = button( gate ); // mode resonance duration is controlled with the x axis of the accelerometer res = hslider( res[acc: 0 0 -10 0 10] ,2.5,0.01,5,0.01); //=================================== Parameters Mapping ================================= //======================================================================================== // number of modes nModes = 6; // distance between each mode maxModeSpread = 5; modeSpread = y*maxModeSpread; // computing modes frequency ratio modeFreqRatios = par(i,nModes,1+(i+1)/nModes*modeSpread); // computing modes gain minModeGain = 0.3; modeGains = par(i,nModes,1-(i+1)/(nModes*minModeGain)); // smoothed mode resonance modeRes = res : si.smoo; //============================================ DSP ======================================= //======================================================================================== process = sy.additiveDrum(freq,modeFreqRatios,modeGains,0.8,0.001,modeRes,gate)*0.05; Try it Yourself >>","title":"turenas"},{"location":"examples/smartKeyboard/#violin2","text":"//############################### violin2.dsp ################################## // Faust instrument specifically designed for faust2smartkeyb where a // complete violin physical model can be played using the touch sceen // interface. Bowing is carried out by constantly moving a finger on the // y axis of a key. // // ## SmartKeyboard Use Strategy // // 4 keyboards are used to control the pitch of the 4 bowed strings. Strings // are connected to the virtual bow when they are touched. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. // However it was specifically designed to be used with faust2smartkeyb. For // best results, we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp violin.dsp // // // ## Version/Licence // // Version 0.0, Aug. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //############################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'4', 'Max Keyboard Polyphony':'0', 'Rounding Mode':'2', 'Send Fingers Count':'1', 'Keyboard 0 - Number of Keys':'12', 'Keyboard 1 - Number of Keys':'12', 'Keyboard 2 - Number of Keys':'12', 'Keyboard 3 - Number of Keys':'12', 'Keyboard 0 - Lowest Key':'55', 'Keyboard 1 - Lowest Key':'62', 'Keyboard 2 - Lowest Key':'69', 'Keyboard 3 - Lowest Key':'76', 'Keyboard 0 - Send Keyboard Freq':'1', 'Keyboard 1 - Send Keyboard Freq':'1', 'Keyboard 2 - Send Keyboard Freq':'1', 'Keyboard 3 - Send Keyboard Freq':'1', 'Keyboard 0 - Send Y':'1', 'Keyboard 1 - Send Y':'1', 'Keyboard 2 - Send Y':'1', 'Keyboard 3 - Send Y':'1' } ; import( stdfaust.lib ); // SMARTKEYBOARD PARAMS kbfreq(0) = hslider( kb0freq ,220,20,10000,0.01); kbbend(0) = hslider( kb0bend ,1,0,10,0.01); kbfreq(1) = hslider( kb1freq ,330,20,10000,0.01); kbbend(1) = hslider( kb1bend ,1,0,10,0.01); kbfreq(2) = hslider( kb2freq ,440,20,10000,0.01); kbbend(2) = hslider( kb2bend ,1,0,10,0.01); kbfreq(3) = hslider( kb3freq ,550,20,10000,0.01); kbbend(3) = hslider( kb3bend ,1,0,10,0.01); kbfingers(0) = hslider( kb0fingers ,0,0,10,1) : int; kbfingers(1) = hslider( kb1fingers ,0,0,10,1) : int; kbfingers(2) = hslider( kb2fingers ,0,0,10,1) : int; kbfingers(3) = hslider( kb3fingers ,0,0,10,1) : int; y = hslider( y ,0,0,1,1) : si.smoo; // MODEL PARAMETERS // strings lengths sl(i) = kbfreq(i)*kbbend(i) : pm.f2l : si.smoo; // string active only if fingers are touching the keyboard as(i) = kbfingers(i) 0; // retrieving finger displacement on screen (dirt simple) bowVel = y-y' : abs : *(3000) : min(1) : si.smoo; // bow position is constant but could be ontrolled by an external interface bowPos = 0.7; bowPress = 0.5; // ASSEMBLING MODELS // essentially 4 parallel violin strings model = par(i,4,pm.violinModel(sl(i),bowPress,bowVel*as(i),bowPos)) : _; process = model : _,_; Try it Yourself >>","title":"violin2"},{"location":"examples/smartKeyboard/#violin","text":"//############################### violin.dsp ################################### // Faust instrument specifically designed for faust2smartkeyb where a // complete violin physical model can be played using the touch sceen // interface. While the 4 virtual strings can be bowed using a control // surface on the screen, it could be easily substituted with an external // interface. // // ## SmartKeyboard Use Strategy // // 4 keyboards are used to control the pitch of the 4 bowed strings. Strings // are connected to the virtual bow when they are touched. A pad created from // a keybaord with a single key can be used to control the bow velocity and // pressure on the selected strings. // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. // However it was specifically designed to be used with faust2smartkeyb. For // best results, we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] -effect reverb.dsp violin.dsp // // // ## Version/Licence // // Version 0.0, Aug. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //############################################################################## declare interface SmartKeyboard{ 'Number of Keyboards':'5', 'Max Keyboard Polyphony':'0', 'Rounding Mode':'2', 'Send Fingers Count':'1', 'Keyboard 0 - Number of Keys':'19', 'Keyboard 1 - Number of Keys':'19', 'Keyboard 2 - Number of Keys':'19', 'Keyboard 3 - Number of Keys':'19', 'Keyboard 4 - Number of Keys':'1', 'Keyboard 0 - Lowest Key':'55', 'Keyboard 1 - Lowest Key':'62', 'Keyboard 2 - Lowest Key':'69', 'Keyboard 3 - Lowest Key':'76', 'Keyboard 0 - Send Keyboard Freq':'1', 'Keyboard 1 - Send Keyboard Freq':'1', 'Keyboard 2 - Send Keyboard Freq':'1', 'Keyboard 3 - Send Keyboard Freq':'1', 'Keyboard 4 - Send Freq':'0', 'Keyboard 4 - Send Key X':'1', 'Keyboard 4 - Send Key Y':'1', 'Keyboard 4 - Key 0 - Label':'Bow', 'Keyboard 4 - Static Mode':'1' } ; import( stdfaust.lib ); // SMARTKEYBOARD PARAMS kbfreq(0) = hslider( kb0freq ,220,20,10000,0.01); kbbend(0) = hslider( kb0bend ,1,0,10,0.01); kbfreq(1) = hslider( kb1freq ,330,20,10000,0.01); kbbend(1) = hslider( kb1bend ,1,0,10,0.01); kbfreq(2) = hslider( kb2freq ,440,20,10000,0.01); kbbend(2) = hslider( kb2bend ,1,0,10,0.01); kbfreq(3) = hslider( kb3freq ,550,20,10000,0.01); kbbend(3) = hslider( kb3bend ,1,0,10,0.01); kb4k0x = hslider( kb4k0x ,0,0,1,1) : si.smoo; kb4k0y = hslider( kb4k0y ,0,0,1,1) : si.smoo; kbfingers(0) = hslider( kb0fingers ,0,0,10,1) : int; kbfingers(1) = hslider( kb1fingers ,0,0,10,1) : int; kbfingers(2) = hslider( kb2fingers ,0,0,10,1) : int; kbfingers(3) = hslider( kb3fingers ,0,0,10,1) : int; // MODEL PARAMETERS // strings lengths sl(i) = kbfreq(i)*kbbend(i) : pm.f2l : si.smoo; // string active only if fingers are touching the keyboard as(i) = kbfingers(i) 0; // bow pressure could also be controlled by an external parameter bowPress = kb4k0y; // retrieving finger displacement on screen (dirt simple) bowVel = kb4k0x-kb4k0x' : abs : *(8000) : min(1) : si.smoo; // bow position is constant but could be ontrolled by an external interface bowPos = 0.7; // ASSEMBLING MODELS // essentially 4 parallel violin strings model = par(i,4,pm.violinModel(sl(i),bowPress,bowVel*as(i),bowPos)) : _; process = model : _,_; Try it Yourself >>","title":"violin"},{"location":"examples/smartKeyboard/#vocal","text":"//######################################## vocal.dsp ##################################### // A funny vocal synth app... // // ## Compilation Instructions // // This Faust code will compile fine with any of the standard Faust targets. However // it was specifically designed to be used with faust2smartkeyb. For best results, // we recommend to use the following parameters to compile it: // // // faust2smartkeyb [-ios/-android] vocal.dsp // // // ## Version/Licence // // Version 0.0, Feb. 2017 // Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017 // MIT Licence: https://opensource.org/licenses/MIT //######################################################################################## import( stdfaust.lib ); declare interface SmartKeyboard{ 'Number of Keyboards':'1', 'Max Keyboard Polyphony':'0', 'Keyboard 0 - Number of Keys':'1', 'Keyboard 0 - Send Freq':'0', 'Keyboard 0 - Static Mode':'1', 'Keyboard 0 - Send X':'1', 'Keyboard 0 - Piano Keyboard':'0' } ; // standard parameters vowel = hslider( vowel[acc: 0 0 -10 0 10] ,2,0,4,0.01) : si.smoo; x = hslider( x ,0.5,0,1,0.01) : si.smoo; vibrato = hslider( vibrato[acc: 1 0 -10 0 10] ,0.05,0,0.1,0.01); gain = hslider( gain ,0.25,0,1,0.01); // fomating parameters freq = x*200 + 50; voiceFreq = freq*(os.osc(6)*vibrato+1); process = pm.SFFormantModelBP(1,vowel,0,voiceFreq,gain) : _,_; Try it Yourself >>","title":"vocal"},{"location":"examples/spat/","text":"spat panpot declare name panpot ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------- // Stereo panpot //------------------------------------------------- panpot(x) = sqrt(c)*x, sqrt(1-c)*x with { c=(nentry( [1]pan[style:knob] ,0,-90,90,1)-90.0)/-180.0; }; process = panpot; Try it Yourself >> spat declare name spat ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //========================================================== // // GMEM SPAT // implementation of L. Pottier Spatializer // //========================================================== import( stdfaust.lib ); //------------------------------------------------------ // EXEMPLE : une entree mono spatialisee sur 8 sorties //------------------------------------------------------ angle = hslider( angle , 0.0, 0, 1, 0.01); distance = hslider( distance , 0.5, 0, 1, 0.01); process = vgroup( Spatializer 1x8 , sp.spat(8, angle, distance)); Try it Yourself >>","title":" spat "},{"location":"examples/spat/#spat","text":"","title":"spat"},{"location":"examples/spat/#panpot","text":"declare name panpot ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //------------------------------------------------- // Stereo panpot //------------------------------------------------- panpot(x) = sqrt(c)*x, sqrt(1-c)*x with { c=(nentry( [1]pan[style:knob] ,0,-90,90,1)-90.0)/-180.0; }; process = panpot; Try it Yourself >>","title":"panpot"},{"location":"examples/spat/#spat_1","text":"declare name spat ; declare version 1.0 ; declare author Grame ; declare license BSD ; declare copyright (c)GRAME 2006 ; //========================================================== // // GMEM SPAT // implementation of L. Pottier Spatializer // //========================================================== import( stdfaust.lib ); //------------------------------------------------------ // EXEMPLE : une entree mono spatialisee sur 8 sorties //------------------------------------------------------ angle = hslider( angle , 0.0, 0, 1, 0.01); distance = hslider( distance , 0.5, 0, 1, 0.01); process = vgroup( Spatializer 1x8 , sp.spat(8, angle, distance)); Try it Yourself >>","title":"spat"},{"location":"guide/embedding/","text":"Embedding the Faust Compiler Using libfaust The combination of the awesome LLVM technology and libfaust (the library version of the Faust compiler) allows developers to compile and execute Faust DSP programs on the fly at full speed and without making compromises. In this section, we demonstrate how the Faust dynamic compilation chain can be used to embed the Faust compiler technology directly in applications or plug-ins. Dynamic Compilation Chain The Faust compiler uses an intermediate FIR representation (Faust Imperative Representation), which can be translated to several output languages. The FIR language describes the computation performed on the samples in a generic manner. It contains primitives to read and write variables and arrays, do arithmetic operations, and define the necessary control structures ( for and while loops, if structure, etc.). To generate various output languages, several backends have been developed: for C, C++, Java, JavaScript, asm.js, LLVM IR, webassemble, etc. The native LLVM based compilation chain is particularly interesting: it provides direct compilation of a DSP source into executable code in memory, bypassing the external compiler requirement. LLVM LLVM (formerly Low Level Virtual Machine) is a compiler infrastructure, designed for compile-time, link-time, and run-time optimization of programs written in arbitrary programming languages. Executable code is produced dynamically using a Just In Time compiler from a specific code representation, called LLVM IR. Clang, the LLVM native C/C++/Objective-C compiler is a front-end for the LLVM Compiler. It can, for instance, convert a C or C++ source file into LLVM IR code. Domain-specific languages like Faust can easily target the LLVM IR. This has been done by developing an LLVM IR backend in the Faust compiler. Compiling in Memory The complete chain goes from the Faust DSP source code, compiled in LLVM IR using the LLVM backend, to finally produce the executable code using the LLVM JIT. All steps take place in memory, getting rid of the classical file-based approaches. Pointers to executable functions can be retrieved from the resulting LLVM module and the code directly called with the appropriate parameters. The Faust compiler has been packaged as an embeddable library called libfaust , published with an associated API. Given a Faust source code (as a file or a string), calling the createDSPFactoryXXX function runs the compilation chain (Faust + LLVM JIT) and generates the prototype of the class, as a llvm_dsp_factory pointer. Note that the library keeps an internal cache of all allocated factories so that the compilation of the same DSP code -- that is the same source code and the same set of normalized (sorted in a canonical order) compilation options -- will return the same (reference counted) factory pointer. deleteDSPFactory has to be explicitly used to properly decrement the reference counter when the factory is not needed anymore. You can get a unique SHA1 key of the created factory using its getSHAKey method. Next, the createDSPInstance function (corresponding to the new className of C++) instantiates a llvm_dsp pointer to be used through its interface, connected to the audio chain and controller interfaces. When finished, delete can be used to destroy the dsp instance. Since llvm_dsp is a subclass of the dsp base class, an object of this type can be used with all the available audio and UI classes. In essence, this is like reusing all architecture files already developed for the static C++ class compilation scheme like OSCUI , httpdUI interfaces, etc. (see TODO pointer to arch section). Saving/Restoring the Factory After the DSP factory has been compiled, the application or the plug-in running it might need to save it and then restore it. To get the internal factory compiled code, several functions are available: writeDSPFactoryToIR : get the DSP factory LLVM IR (in textual format) as a string, writeDSPFactoryToIRFile : get the DSP factory LLVM IR (in textual format) and write it to a file, writeDSPFactoryToBitcode : get the DSP factory LLVM IR (in binary format) as a string writeDSPFactoryToBitcodeFile : save the DSP factory LLVM IR (in binary format) in a file, writeDSPFactoryToMachine : get the DSP factory executable machine code as a string, writeDSPFactoryToMachineFile : save the DSP factory executable machine code in a file. To re-create a DSP factory from a previously saved code, several functions are available: readDSPFactoryFromIR : create a DSP factory from a string containing the LLVM IR (in textual format), readDSPFactoryFromIRFile : create a DSP factory from a file containing the LLVM IR (in textual format), readDSPFactoryFromBitcode : create a DSP factory from a string containing the LLVM IR (in binary format), readDSPFactoryFromBitcodeFile : create a DSP factory from a file containing the LLVM IR (in binary format), readDSPFactoryFromMachine : create a DSP factory from a string containing the executable machine code, readDSPFactoryFromMachineFile : create a DSP factory from a file containing the executable machine code. Additional Functions Some additional functions are available in the libfaust API: expandDSPFromString / expandDSPFromFile : creates a self-contained DSP source string where all needed librairies have been included. All compilations options are normalized and included as a comment in the expanded string, generateAuxFilesFromString / generateAuxFilesFromFile : from a DSP source string or file, generates auxiliary files: SVG, XML, ps, etc. depending of the argv parameters. Using the libfaust Library The libfaust library is fully integrated to the Faust distribution. You'll have to compile and install it in order to use it. For an exhaustive documentation/description of the API, we advise you to have a look at the code in the faust/dsp/llvm-dsp.h header file. Note that faust/dsp/llvm-c-dsp.h is a pure C version of the same API. Additional functions are available in faust/dsp/libfaust.h and their C version can be found in faust/dsp/libfaust-c.h . More generally, a \"typical\" use of libfaust could look like: // the Faust code to compile (could be in a file too) string theCode = import( stdfaust.lib );process = no.noise; ; // compiling in memory (createDSPFactoryFromFile could be used alternatively) llvm_dsp_factory *m_factory = createDSPFactoryFromString( faust , theCode, argc, argv, , m_errorString, optimize ); // creating the DSP instance for interfacing dsp *m_dsp = m_factory- createDSPInstance(); // creating a generic UI to interact with the DSP my_ui m_ui = new MyUI(); // linking the interface to the DSP instance m_dsp- buildUserInterface( m_ui ); // initializing the DSP instance m_dsp- init( 44100 ); // hypothetical audio callback while(...){ m_dsp- compute( 1, m_input, m_output ); } // cleaning delete m_dsp; deleteDSPFactory( m_factory ); m_factory = NULL; Thus, very few code is needed to embed Faust to your project! Use Case Examples The dynamic compilation chain has been used in several projects: FaustLive : an integrated IDE for Faust development offering on-the-fly compilation and execution features Faustgen : a generic Faust Max/MSP object Faust for CSOUND : a CSOUND opcode running the Faust compiler internally LibAudioStream : a framework to manipulate audio ressources through the concept of streams Faust for JUCE : a tool integrating the Faust compiler to JUCE developed by Oliver Larkin and available as part of the pMix2 project An experimental integration of Faust in Antescofo FaucK: the combination of the ChucK Programming Language and Faust","title":"Embedding"},{"location":"guide/embedding/#embedding-the-faust-compiler-using-libfaust","text":"The combination of the awesome LLVM technology and libfaust (the library version of the Faust compiler) allows developers to compile and execute Faust DSP programs on the fly at full speed and without making compromises. In this section, we demonstrate how the Faust dynamic compilation chain can be used to embed the Faust compiler technology directly in applications or plug-ins.","title":"Embedding the Faust Compiler Using libfaust"},{"location":"guide/embedding/#dynamic-compilation-chain","text":"The Faust compiler uses an intermediate FIR representation (Faust Imperative Representation), which can be translated to several output languages. The FIR language describes the computation performed on the samples in a generic manner. It contains primitives to read and write variables and arrays, do arithmetic operations, and define the necessary control structures ( for and while loops, if structure, etc.). To generate various output languages, several backends have been developed: for C, C++, Java, JavaScript, asm.js, LLVM IR, webassemble, etc. The native LLVM based compilation chain is particularly interesting: it provides direct compilation of a DSP source into executable code in memory, bypassing the external compiler requirement.","title":"Dynamic Compilation Chain"},{"location":"guide/embedding/#llvm","text":"LLVM (formerly Low Level Virtual Machine) is a compiler infrastructure, designed for compile-time, link-time, and run-time optimization of programs written in arbitrary programming languages. Executable code is produced dynamically using a Just In Time compiler from a specific code representation, called LLVM IR. Clang, the LLVM native C/C++/Objective-C compiler is a front-end for the LLVM Compiler. It can, for instance, convert a C or C++ source file into LLVM IR code. Domain-specific languages like Faust can easily target the LLVM IR. This has been done by developing an LLVM IR backend in the Faust compiler.","title":"LLVM"},{"location":"guide/embedding/#compiling-in-memory","text":"The complete chain goes from the Faust DSP source code, compiled in LLVM IR using the LLVM backend, to finally produce the executable code using the LLVM JIT. All steps take place in memory, getting rid of the classical file-based approaches. Pointers to executable functions can be retrieved from the resulting LLVM module and the code directly called with the appropriate parameters. The Faust compiler has been packaged as an embeddable library called libfaust , published with an associated API. Given a Faust source code (as a file or a string), calling the createDSPFactoryXXX function runs the compilation chain (Faust + LLVM JIT) and generates the prototype of the class, as a llvm_dsp_factory pointer. Note that the library keeps an internal cache of all allocated factories so that the compilation of the same DSP code -- that is the same source code and the same set of normalized (sorted in a canonical order) compilation options -- will return the same (reference counted) factory pointer. deleteDSPFactory has to be explicitly used to properly decrement the reference counter when the factory is not needed anymore. You can get a unique SHA1 key of the created factory using its getSHAKey method. Next, the createDSPInstance function (corresponding to the new className of C++) instantiates a llvm_dsp pointer to be used through its interface, connected to the audio chain and controller interfaces. When finished, delete can be used to destroy the dsp instance. Since llvm_dsp is a subclass of the dsp base class, an object of this type can be used with all the available audio and UI classes. In essence, this is like reusing all architecture files already developed for the static C++ class compilation scheme like OSCUI , httpdUI interfaces, etc. (see TODO pointer to arch section).","title":"Compiling in Memory"},{"location":"guide/embedding/#savingrestoring-the-factory","text":"After the DSP factory has been compiled, the application or the plug-in running it might need to save it and then restore it. To get the internal factory compiled code, several functions are available: writeDSPFactoryToIR : get the DSP factory LLVM IR (in textual format) as a string, writeDSPFactoryToIRFile : get the DSP factory LLVM IR (in textual format) and write it to a file, writeDSPFactoryToBitcode : get the DSP factory LLVM IR (in binary format) as a string writeDSPFactoryToBitcodeFile : save the DSP factory LLVM IR (in binary format) in a file, writeDSPFactoryToMachine : get the DSP factory executable machine code as a string, writeDSPFactoryToMachineFile : save the DSP factory executable machine code in a file. To re-create a DSP factory from a previously saved code, several functions are available: readDSPFactoryFromIR : create a DSP factory from a string containing the LLVM IR (in textual format), readDSPFactoryFromIRFile : create a DSP factory from a file containing the LLVM IR (in textual format), readDSPFactoryFromBitcode : create a DSP factory from a string containing the LLVM IR (in binary format), readDSPFactoryFromBitcodeFile : create a DSP factory from a file containing the LLVM IR (in binary format), readDSPFactoryFromMachine : create a DSP factory from a string containing the executable machine code, readDSPFactoryFromMachineFile : create a DSP factory from a file containing the executable machine code.","title":"Saving/Restoring the Factory"},{"location":"guide/embedding/#additional-functions","text":"Some additional functions are available in the libfaust API: expandDSPFromString / expandDSPFromFile : creates a self-contained DSP source string where all needed librairies have been included. All compilations options are normalized and included as a comment in the expanded string, generateAuxFilesFromString / generateAuxFilesFromFile : from a DSP source string or file, generates auxiliary files: SVG, XML, ps, etc. depending of the argv parameters.","title":"Additional Functions"},{"location":"guide/embedding/#using-the-libfaust-library","text":"The libfaust library is fully integrated to the Faust distribution. You'll have to compile and install it in order to use it. For an exhaustive documentation/description of the API, we advise you to have a look at the code in the faust/dsp/llvm-dsp.h header file. Note that faust/dsp/llvm-c-dsp.h is a pure C version of the same API. Additional functions are available in faust/dsp/libfaust.h and their C version can be found in faust/dsp/libfaust-c.h . More generally, a \"typical\" use of libfaust could look like: // the Faust code to compile (could be in a file too) string theCode = import( stdfaust.lib );process = no.noise; ; // compiling in memory (createDSPFactoryFromFile could be used alternatively) llvm_dsp_factory *m_factory = createDSPFactoryFromString( faust , theCode, argc, argv, , m_errorString, optimize ); // creating the DSP instance for interfacing dsp *m_dsp = m_factory- createDSPInstance(); // creating a generic UI to interact with the DSP my_ui m_ui = new MyUI(); // linking the interface to the DSP instance m_dsp- buildUserInterface( m_ui ); // initializing the DSP instance m_dsp- init( 44100 ); // hypothetical audio callback while(...){ m_dsp- compute( 1, m_input, m_output ); } // cleaning delete m_dsp; deleteDSPFactory( m_factory ); m_factory = NULL; Thus, very few code is needed to embed Faust to your project!","title":"Using the libfaust Library"},{"location":"guide/embedding/#use-case-examples","text":"The dynamic compilation chain has been used in several projects: FaustLive : an integrated IDE for Faust development offering on-the-fly compilation and execution features Faustgen : a generic Faust Max/MSP object Faust for CSOUND : a CSOUND opcode running the Faust compiler internally LibAudioStream : a framework to manipulate audio ressources through the concept of streams Faust for JUCE : a tool integrating the Faust compiler to JUCE developed by Oliver Larkin and available as part of the pMix2 project An experimental integration of Faust in Antescofo FaucK: the combination of the ChucK Programming Language and Faust","title":"Use Case Examples"},{"location":"guide/http/","text":"HTTP Support Similarly to OSC, several Faust architectures also provide HTTP support. This allows Faust applications to be remotely controlled from any Web browser using specific URLs. Moreover OSC and HTTPD can be freely combined. While OSC support is installed by default when Faust is built, this is not the case for HTTP. That's because it depends on the GNU libmicrohttpd library which is usually not installed by default on the system. An additional make httpd step is therefore required when compiling and installing Faust: make httpd make sudo make install Note that make httpd will fail if libmicrohttpd is not available on the system. HTTP support can be added to any Faust program (as long as the target architecture supports it: see tables below) simply by adding the [http:on] metadata to the standard option metadata : declare options [http:on] ; The following tables lists Faust's architectures providing HTTP support: Audio System Environment Alsa GTK, Qt, Console Jack GTK, Qt, Console Netjack GTK, Qt, Console PortAudio GTK, Qt **_Linux Faust Architectures with HTTP Support_** Audio System Environment CoreAudio Qt Jack Qt, Console Netjack Qt, Console PortAudio Qt **_OSX Faust Architectures with HTTP Support_** Audio System Environment Jack Qt, Console PortAudio Qt **_Windows Faust Architectures with HTTP Support_** A Simple Example To illustrate how HTTP support works, let's reuse our previous [ mix4.dsp ]mix4.dsp) example, a simple monophonic audio mixer with 4 inputs and one output. For each input we have a mute button and a level slider: input(v) = vgroup( input %v , *(1-checkbox( mute )) : *(vslider( level , 0, 0, 1, 0.01))); process = hgroup( mixer , par(i, 4, input(i)) : _); Try it Yourself >> This example can be compiled as a standalone Jack QT application with HTTP support using the command: faust2jaqt -httpd mix4.dsp The -httpd option embeds a small Web server into the generated application. Its purpose is to serve an HTML page implementing the interface of the app. This page makes use of JavaScript and SVG, and is quite similar to the native QT interface. When the application is started from the command line: ./mix4 various information are printed on the standard output, including: Faust httpd server version 0.73 is running on TCP port 5510 As we can see, the embedded Web server is running by default on TCP port 5510. The entry point is http://localhost:5510 . It can be open from any recent browser and it produces the page presented in the figure below: JSON Description of the User Interface The communication between the application and the Web browser is based on several underlying URLs. The first one is http://localhost:5510/JSON that returns a JSON description of the user interface of the application. This JSON description is used internally by the JavaScript code to build the graphical user interface. Here is (part of) the json returned by mix4 : { name : mix4 , address : YannAir.local , port : 5511 , ui : [ { type : hgroup , label : mixer , items : [ { type : vgroup , label : input_0 , items : [ { type : vslider , label : level , address : /mixer/input_0/level , init : 0 , min : 0 , max : 1 , step : 0.01 }, { type : checkbox , label : mute , address : /mixer/input_0/mute , init : 0 , min : 0 , max : 0 , step : 0 } ] }, ... ] } ] } Querying the State of the Application Each widget has a unique \"address\" field that can be used to query its value. In our example here the level of the input 0 has the address /mixer/input_0/level . The address can be used to forge a URL to get the value of the widget: http://localhost:5510/mixer/input_0/level , resulting in: /mixer/input_0/level 0.00000 Multiple widgets can be queried at once by using an address higher in the hierarchy. For example to get the values of the level and the mute state of input 0 we use http://localhost:5510/mixer/input_0 , resulting in: /mixer/input_0/level 0.00000 /mixer/input_0/mute 0.00000 To get the all the values at once we simply use http://localhost:5510/mixer , resulting in: /mixer/input_0/level 0.00000 /mixer/input_0/mute 0.00000 /mixer/input_1/level 0.00000 /mixer/input_1/mute 0.00000 /mixer/input_2/level 0.00000 /mixer/input_2/mute 0.00000 /mixer/input_3/level 0.00000 /mixer/input_3/mute 0.00000 Changing the Value of a Widget Let's say that we want to mute input 1 of our mixer. For that purpose, we can use the URL http://localhost:5510/mixer/input_1/mute?value=1 obtained by concatenating ?value=1 at the end of the widget URL. All widgets can be controlled in a similar way. For example http://localhost:5510/mixer/input_3/level?value=0.7 will set the input 3 level to 0.7. Proxy Control Access to the Web Server A control application may want to access and control the running DSP using its Web server, but without using the delivered HTML page in a browser. Since the complete JSON can be retrieved, control applications can be purely developed in C/C++. A proxy version of the user interface can then be built, and parameters can be \"set and get\" using HTTP requests. This mode can be started dynamically using the -server URL parameter. Assuming an application with HTTP support is running remotely at the given URL, the control application will fetch its JSON description, use it to dynamically build the user interface, and allow for the access of the remote parameters. HTTP Cheat Sheet Here is a summary of the various URLs used to interact with the application's Web server. Default Ports Port Description 5510 default TCP port used by the application's Web server 5511... alternative TCP ports Command Line Options Option Description -port n set the TCP port number used by the application's Web server -server URL start a proxy control application accessing the remote application running on the given URL URLs URL Description http://host:port the base URL to be used in proxy control access mode http://host:port/JSON get a json description of the user interface http://host:port/address get the value of a widget or a group of widgets http://host:port/address?value=v set the value of a widget to v JSON Top Level The JSON describes the name, host, and port of the application and a hierarchy of user interface items: { name : name , address : host , port : port , ui : [ item ] } An item is either a group (of items) or a widget. Groups A group is essentially a list of items with a specific layout: { type : type , label : label , items : [ item , item ,...] } The type defines the layout. It can be either \"vgroup\" , \"hgroup\" or \"tgroup\" Widgets { type : type , label : label , address : address , meta : [ { key : value },... ], init : num , min : num , max : num , step : num }, Widgets are the basic items of the user interface. They can be of different type : \"button\" , \"checkbox\" , \"nentry\" , \"vslider\" , \"hslider\" , \"vbargraph\" or \"hbargraph\" .","title":"HTTP Support"},{"location":"guide/http/#http-support","text":"Similarly to OSC, several Faust architectures also provide HTTP support. This allows Faust applications to be remotely controlled from any Web browser using specific URLs. Moreover OSC and HTTPD can be freely combined. While OSC support is installed by default when Faust is built, this is not the case for HTTP. That's because it depends on the GNU libmicrohttpd library which is usually not installed by default on the system. An additional make httpd step is therefore required when compiling and installing Faust: make httpd make sudo make install Note that make httpd will fail if libmicrohttpd is not available on the system. HTTP support can be added to any Faust program (as long as the target architecture supports it: see tables below) simply by adding the [http:on] metadata to the standard option metadata : declare options [http:on] ; The following tables lists Faust's architectures providing HTTP support: Audio System Environment Alsa GTK, Qt, Console Jack GTK, Qt, Console Netjack GTK, Qt, Console PortAudio GTK, Qt **_Linux Faust Architectures with HTTP Support_** Audio System Environment CoreAudio Qt Jack Qt, Console Netjack Qt, Console PortAudio Qt **_OSX Faust Architectures with HTTP Support_** Audio System Environment Jack Qt, Console PortAudio Qt **_Windows Faust Architectures with HTTP Support_**","title":"HTTP Support"},{"location":"guide/http/#a-simple-example","text":"To illustrate how HTTP support works, let's reuse our previous [ mix4.dsp ]mix4.dsp) example, a simple monophonic audio mixer with 4 inputs and one output. For each input we have a mute button and a level slider: input(v) = vgroup( input %v , *(1-checkbox( mute )) : *(vslider( level , 0, 0, 1, 0.01))); process = hgroup( mixer , par(i, 4, input(i)) : _); Try it Yourself >> This example can be compiled as a standalone Jack QT application with HTTP support using the command: faust2jaqt -httpd mix4.dsp The -httpd option embeds a small Web server into the generated application. Its purpose is to serve an HTML page implementing the interface of the app. This page makes use of JavaScript and SVG, and is quite similar to the native QT interface. When the application is started from the command line: ./mix4 various information are printed on the standard output, including: Faust httpd server version 0.73 is running on TCP port 5510 As we can see, the embedded Web server is running by default on TCP port 5510. The entry point is http://localhost:5510 . It can be open from any recent browser and it produces the page presented in the figure below:","title":"A Simple Example"},{"location":"guide/http/#json-description-of-the-user-interface","text":"The communication between the application and the Web browser is based on several underlying URLs. The first one is http://localhost:5510/JSON that returns a JSON description of the user interface of the application. This JSON description is used internally by the JavaScript code to build the graphical user interface. Here is (part of) the json returned by mix4 : { name : mix4 , address : YannAir.local , port : 5511 , ui : [ { type : hgroup , label : mixer , items : [ { type : vgroup , label : input_0 , items : [ { type : vslider , label : level , address : /mixer/input_0/level , init : 0 , min : 0 , max : 1 , step : 0.01 }, { type : checkbox , label : mute , address : /mixer/input_0/mute , init : 0 , min : 0 , max : 0 , step : 0 } ] }, ... ] } ] }","title":"JSON Description of the User Interface"},{"location":"guide/http/#querying-the-state-of-the-application","text":"Each widget has a unique \"address\" field that can be used to query its value. In our example here the level of the input 0 has the address /mixer/input_0/level . The address can be used to forge a URL to get the value of the widget: http://localhost:5510/mixer/input_0/level , resulting in: /mixer/input_0/level 0.00000 Multiple widgets can be queried at once by using an address higher in the hierarchy. For example to get the values of the level and the mute state of input 0 we use http://localhost:5510/mixer/input_0 , resulting in: /mixer/input_0/level 0.00000 /mixer/input_0/mute 0.00000 To get the all the values at once we simply use http://localhost:5510/mixer , resulting in: /mixer/input_0/level 0.00000 /mixer/input_0/mute 0.00000 /mixer/input_1/level 0.00000 /mixer/input_1/mute 0.00000 /mixer/input_2/level 0.00000 /mixer/input_2/mute 0.00000 /mixer/input_3/level 0.00000 /mixer/input_3/mute 0.00000","title":"Querying the State of the Application"},{"location":"guide/http/#changing-the-value-of-a-widget","text":"Let's say that we want to mute input 1 of our mixer. For that purpose, we can use the URL http://localhost:5510/mixer/input_1/mute?value=1 obtained by concatenating ?value=1 at the end of the widget URL. All widgets can be controlled in a similar way. For example http://localhost:5510/mixer/input_3/level?value=0.7 will set the input 3 level to 0.7.","title":"Changing the Value of a Widget"},{"location":"guide/http/#proxy-control-access-to-the-web-server","text":"A control application may want to access and control the running DSP using its Web server, but without using the delivered HTML page in a browser. Since the complete JSON can be retrieved, control applications can be purely developed in C/C++. A proxy version of the user interface can then be built, and parameters can be \"set and get\" using HTTP requests. This mode can be started dynamically using the -server URL parameter. Assuming an application with HTTP support is running remotely at the given URL, the control application will fetch its JSON description, use it to dynamically build the user interface, and allow for the access of the remote parameters.","title":"Proxy Control Access to the Web Server"},{"location":"guide/http/#http-cheat-sheet","text":"Here is a summary of the various URLs used to interact with the application's Web server.","title":"HTTP Cheat Sheet"},{"location":"guide/http/#default-ports","text":"Port Description 5510 default TCP port used by the application's Web server 5511... alternative TCP ports","title":"Default Ports"},{"location":"guide/http/#command-line-options","text":"Option Description -port n set the TCP port number used by the application's Web server -server URL start a proxy control application accessing the remote application running on the given URL","title":"Command Line Options"},{"location":"guide/http/#urls","text":"URL Description http://host:port the base URL to be used in proxy control access mode http://host:port/JSON get a json description of the user interface http://host:port/address get the value of a widget or a group of widgets http://host:port/address?value=v set the value of a widget to v","title":"URLs"},{"location":"guide/http/#json","text":"Top Level The JSON describes the name, host, and port of the application and a hierarchy of user interface items: { name : name , address : host , port : port , ui : [ item ] } An item is either a group (of items) or a widget. Groups A group is essentially a list of items with a specific layout: { type : type , label : label , items : [ item , item ,...] } The type defines the layout. It can be either \"vgroup\" , \"hgroup\" or \"tgroup\" Widgets { type : type , label : label , address : address , meta : [ { key : value },... ], init : num , min : num , max : num , step : num }, Widgets are the basic items of the user interface. They can be of different type : \"button\" , \"checkbox\" , \"nentry\" , \"vslider\" , \"hslider\" , \"vbargraph\" or \"hbargraph\" .","title":"JSON"},{"location":"guide/introduction/","text":"Introduction What is Faust? Faust (Functional Audio Stream) is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. Faust targets high-performance signal processing applications and audio plug-ins for a variety of platforms and standards. It is used on stage for concerts and artistic productions, in education and research, in open source projects as well as in commercial applications. The core component of Faust is its compiler. It allows to \"translate\" any Faust digital signal processing (DSP) specification to a wide range of non-domain specific languages such as C++, C, JAVA, JavaScript, LLVM bit code, WebAssembly, etc. In this regard, Faust can be seen as an alternative to C++ but is much simpler and intuitive to learn. Thanks to a wrapping system called \"architectures,\" codes generated by Faust can be easily compiled into a wide variety of objects ranging from audio plug-ins to standalone applications or smartphone and web apps , etc. (check the Quick Tour of the Faust Targets section for an exhaustive list. This manual gives an overview of the Faust programming language and of its features through various interactive examples. What is Faust Good For? Faust's syntax allows to express any DSP algorithm as a block diagram. For example, + is considered as a valid function (and block) taking two arguments (signals) and returning one: process = +; Try it Yourself >> Blocks can be easily connected together using the : \"connection\" composition: process = + : *(0.5); Try it Yourself >> In that case, we add two signals together and then scale the result of this operation. Thus, Faust is perfect to implement time-domain algorithms that can be easily represented as block diagrams such as filters, waveguide physical models, virtual analog elements, etc. Faust is very concise , for example, here's the implementation of a one pole filter/integrator equivalent to \\(y(n) = x(n) + a_{1}y(n-1)\\) (where a_{1}\\) is the pole): a1 = 0.9; process = +~*(a1); Try it Yourself >> Codes generated by Faust are extremely optimized and usually more efficient that handwritten codes (at least for C and C++). The Faust compiler tries to optimize each element of an algorithm. For example, you shouldn't have to worry about using divides instead of multiplies as they get automatically replaced by multiplies by the compiler when possible, etc. Faust is very generic and allows to write code that will run on dozens of platforms. What is Faust Not (So) Good For? Despite all this, Faust does have some limitations. For instance, it doesn't allow for the efficient implementation of algorithms requiring multi-rates such as the FFT, convolution, etc. While there are tricks to go around this issue, we're fully aware that it is a big one and we're working as hard as possible on it. Faust's conciseness can sometimes become a problem too, especially for complex algorithms with lots of recursive signals. It is usually crucial in Faust to have the \"mental global picture\" of the algorithm to be implemented which in some cases can be hard. While the Faust compiler is relatively bug-free, it does have some limitations and might get stuck in some extreme cases that you will probably never encounter. If you do, shoot us an e-mail ! From here, you can jump to ... if you wanna get your hands dirty, etc. TODO. Design Principles Since the beginning of its development in 2002, Faust has been guided by various design principles: Faust is a specification language . It aims at providing an adequate notation to describe signal processors from a mathematical point of view. Faust is, as much as possible, free from implementation details. Faust programs are fully compiled (i.e., not interpreted). The compiler translates Faust programs into equivalent programs in other languages (e.g., JAVA, JavaScript, LLVM bit code, WebAssembly, etc.) taking care of generating the most efficient code. The result can generally compete with, and sometimes even outperform, C++ code written by seasoned programmers. The generated code works at the sample level. It is therefore suited to implement low-level DSP functions like recursive filters. Moreover the code can be easily embedded. It is self-contained and doesn't depend of any DSP library or runtime system. It has a very deterministic behavior and a constant memory footprint. The semantic of Faust is simple and well defined. This is not just of academic interest. It allows the Faust compiler to be semantically driven . Instead of compiling a program literally, it compiles the mathematical function it denotes. This feature is useful for example to promote components reuse while preserving optimal performance. Faust is a textual language but nevertheless block-diagram oriented. It actually combines two approaches: functional programming and algebraic block-diagrams . The key idea is to view block-diagram construction as function composition. For that purpose, Faust relies on a block-diagram algebra of five composition operations: : , ~ : : (see the section on Diagram Composition Operations for more details). Thanks to the concept of architecture , Faust programs can be easily deployed on a large variety of audio platforms and plug-in formats without any change to the Faust code. Signal Processor Semantic A Faust program describes a signal processor . The role of a signal processor is to transforms a (possibly empty) group of input signals in order to produce a (possibly empty) group of output signals . Most audio equipments can be modeled as signal processors . They have audio inputs, audio outputs as well as control signals interfaced with sliders, knobs, vu-meters, etc. More precisely : A signal \\(s\\) is a discrete function of time \\(s:\\mathbb{Z}\\rightarrow\\mathbb{R}\\) . The value of a signal \\(s\\) at time \\(t\\) is written \\(s(t)\\) . The values of signals are usually needed starting from time \\(0\\) . But to take into account delay operations , negative times are possible and are always mapped to zeros. Therefore for any Faust signal \\(s\\) we have \\(\\forall t 0, s(t)=0\\) . In operational terms this corresponds to assuming that all delay lines are signals initialized with \\(0\\) s. Faust considers two type of signals: integer signals ( \\(s:\\mathbb{Z}\\rightarrow\\mathbb{Z}\\) ) and floating point signals ( \\(s:\\mathbb{Z}\\rightarrow\\mathbb{Q}\\) ). Exchanges with the outside world are, by convention, made using floating point signals. The full range is represented by sample values between \\(-1.0\\) and \\(+1.0\\) . The set of all possible signals is \\(\\mathbb{S}=\\mathbb{Z}\\rightarrow\\mathbb{R}\\) . A group of \\(n\\) signals (a n -tuple of signals) is written \\((s_{1},\\ldots,s_{n})\\in \\mathbb{S}^{n}\\) . The empty tuple , single element of \\(\\mathbb{S}^{0}\\) is notated \\(()\\) . A signal processors \\(p\\) , is a function from n -tuples of signals to m -tuples of signals \\(p:\\mathbb{S}^{n}\\rightarrow\\mathbb{S}^{m}\\) . The set \\(\\mathbb{P}=\\bigcup_{n,m}\\mathbb{S}^{n}\\rightarrow\\mathbb{S}^{m}\\) is the set of all possible signal processors. As an example, let's express the semantic of the Faust primitive + . Like any Faust expression, it is a signal processor. Its signature is \\(\\mathbb{S}^{2}\\rightarrow\\mathbb{S}\\) . It takes two input signals \\(X_0\\) and \\(X_1\\) and produces an output signal \\(Y\\) such that \\(Y(t) = X_0(t)+X_1(t)\\) . Numbers are signal processors too. For example the number \\(3\\) has signature \\(\\mathbb{S}^{0}\\rightarrow\\mathbb{S}\\) . It takes no input signals and produce an output signal \\(Y\\) such that \\(Y(t) = 3\\) .","title":"Introduction"},{"location":"guide/introduction/#introduction","text":"","title":"Introduction"},{"location":"guide/introduction/#what-is-faust","text":"Faust (Functional Audio Stream) is a functional programming language for sound synthesis and audio processing with a strong focus on the design of synthesizers, musical instruments, audio effects, etc. Faust targets high-performance signal processing applications and audio plug-ins for a variety of platforms and standards. It is used on stage for concerts and artistic productions, in education and research, in open source projects as well as in commercial applications. The core component of Faust is its compiler. It allows to \"translate\" any Faust digital signal processing (DSP) specification to a wide range of non-domain specific languages such as C++, C, JAVA, JavaScript, LLVM bit code, WebAssembly, etc. In this regard, Faust can be seen as an alternative to C++ but is much simpler and intuitive to learn. Thanks to a wrapping system called \"architectures,\" codes generated by Faust can be easily compiled into a wide variety of objects ranging from audio plug-ins to standalone applications or smartphone and web apps , etc. (check the Quick Tour of the Faust Targets section for an exhaustive list. This manual gives an overview of the Faust programming language and of its features through various interactive examples.","title":"What is Faust?"},{"location":"guide/introduction/#what-is-faust-good-for","text":"Faust's syntax allows to express any DSP algorithm as a block diagram. For example, + is considered as a valid function (and block) taking two arguments (signals) and returning one: process = +; Try it Yourself >> Blocks can be easily connected together using the : \"connection\" composition: process = + : *(0.5); Try it Yourself >> In that case, we add two signals together and then scale the result of this operation. Thus, Faust is perfect to implement time-domain algorithms that can be easily represented as block diagrams such as filters, waveguide physical models, virtual analog elements, etc. Faust is very concise , for example, here's the implementation of a one pole filter/integrator equivalent to \\(y(n) = x(n) + a_{1}y(n-1)\\) (where a_{1}\\) is the pole): a1 = 0.9; process = +~*(a1); Try it Yourself >> Codes generated by Faust are extremely optimized and usually more efficient that handwritten codes (at least for C and C++). The Faust compiler tries to optimize each element of an algorithm. For example, you shouldn't have to worry about using divides instead of multiplies as they get automatically replaced by multiplies by the compiler when possible, etc. Faust is very generic and allows to write code that will run on dozens of platforms.","title":"What is Faust Good For?"},{"location":"guide/introduction/#what-is-faust-not-so-good-for","text":"Despite all this, Faust does have some limitations. For instance, it doesn't allow for the efficient implementation of algorithms requiring multi-rates such as the FFT, convolution, etc. While there are tricks to go around this issue, we're fully aware that it is a big one and we're working as hard as possible on it. Faust's conciseness can sometimes become a problem too, especially for complex algorithms with lots of recursive signals. It is usually crucial in Faust to have the \"mental global picture\" of the algorithm to be implemented which in some cases can be hard. While the Faust compiler is relatively bug-free, it does have some limitations and might get stuck in some extreme cases that you will probably never encounter. If you do, shoot us an e-mail ! From here, you can jump to ... if you wanna get your hands dirty, etc. TODO.","title":"What is Faust Not (So) Good For?"},{"location":"guide/introduction/#design-principles","text":"Since the beginning of its development in 2002, Faust has been guided by various design principles: Faust is a specification language . It aims at providing an adequate notation to describe signal processors from a mathematical point of view. Faust is, as much as possible, free from implementation details. Faust programs are fully compiled (i.e., not interpreted). The compiler translates Faust programs into equivalent programs in other languages (e.g., JAVA, JavaScript, LLVM bit code, WebAssembly, etc.) taking care of generating the most efficient code. The result can generally compete with, and sometimes even outperform, C++ code written by seasoned programmers. The generated code works at the sample level. It is therefore suited to implement low-level DSP functions like recursive filters. Moreover the code can be easily embedded. It is self-contained and doesn't depend of any DSP library or runtime system. It has a very deterministic behavior and a constant memory footprint. The semantic of Faust is simple and well defined. This is not just of academic interest. It allows the Faust compiler to be semantically driven . Instead of compiling a program literally, it compiles the mathematical function it denotes. This feature is useful for example to promote components reuse while preserving optimal performance. Faust is a textual language but nevertheless block-diagram oriented. It actually combines two approaches: functional programming and algebraic block-diagrams . The key idea is to view block-diagram construction as function composition. For that purpose, Faust relies on a block-diagram algebra of five composition operations: : , ~ : : (see the section on Diagram Composition Operations for more details). Thanks to the concept of architecture , Faust programs can be easily deployed on a large variety of audio platforms and plug-in formats without any change to the Faust code.","title":"Design Principles"},{"location":"guide/introduction/#signal-processor-semantic","text":"A Faust program describes a signal processor . The role of a signal processor is to transforms a (possibly empty) group of input signals in order to produce a (possibly empty) group of output signals . Most audio equipments can be modeled as signal processors . They have audio inputs, audio outputs as well as control signals interfaced with sliders, knobs, vu-meters, etc. More precisely : A signal \\(s\\) is a discrete function of time \\(s:\\mathbb{Z}\\rightarrow\\mathbb{R}\\) . The value of a signal \\(s\\) at time \\(t\\) is written \\(s(t)\\) . The values of signals are usually needed starting from time \\(0\\) . But to take into account delay operations , negative times are possible and are always mapped to zeros. Therefore for any Faust signal \\(s\\) we have \\(\\forall t 0, s(t)=0\\) . In operational terms this corresponds to assuming that all delay lines are signals initialized with \\(0\\) s. Faust considers two type of signals: integer signals ( \\(s:\\mathbb{Z}\\rightarrow\\mathbb{Z}\\) ) and floating point signals ( \\(s:\\mathbb{Z}\\rightarrow\\mathbb{Q}\\) ). Exchanges with the outside world are, by convention, made using floating point signals. The full range is represented by sample values between \\(-1.0\\) and \\(+1.0\\) . The set of all possible signals is \\(\\mathbb{S}=\\mathbb{Z}\\rightarrow\\mathbb{R}\\) . A group of \\(n\\) signals (a n -tuple of signals) is written \\((s_{1},\\ldots,s_{n})\\in \\mathbb{S}^{n}\\) . The empty tuple , single element of \\(\\mathbb{S}^{0}\\) is notated \\(()\\) . A signal processors \\(p\\) , is a function from n -tuples of signals to m -tuples of signals \\(p:\\mathbb{S}^{n}\\rightarrow\\mathbb{S}^{m}\\) . The set \\(\\mathbb{P}=\\bigcup_{n,m}\\mathbb{S}^{n}\\rightarrow\\mathbb{S}^{m}\\) is the set of all possible signal processors. As an example, let's express the semantic of the Faust primitive + . Like any Faust expression, it is a signal processor. Its signature is \\(\\mathbb{S}^{2}\\rightarrow\\mathbb{S}\\) . It takes two input signals \\(X_0\\) and \\(X_1\\) and produces an output signal \\(Y\\) such that \\(Y(t) = X_0(t)+X_1(t)\\) . Numbers are signal processors too. For example the number \\(3\\) has signature \\(\\mathbb{S}^{0}\\rightarrow\\mathbb{S}\\) . It takes no input signals and produce an output signal \\(Y\\) such that \\(Y(t) = 3\\) .","title":"Signal Processor Semantic"},{"location":"guide/mathdoc/","text":"Mathematical Documentation The Faust compiler provides a mechanism to produce a self-describing documentation of the mathematical semantic of a Faust program, essentially as a pdf file. The corresponding options are -mdoc (short) or --mathdoc (long). Goals of the Mathdoc There are three main goals, or uses, of the Faust mathematical documentation generator: to preserve signal processors, independently from any computer language but only under a mathematical form; to bring some help for debugging tasks, by showing the formulas as they are really computed after the compilation stage; to give a new teaching support, as a bridge between code and formulas for signal processing. Installation Requirements faust , of course! svg2pdf (from the Cairo 2D graphics library), to convert block-diagrams, as Latex doesn't embed SVG directly, breqn , a Latex package to handle automatic breaking of long equations, pdflatex , to compile the Latex output file. Generating the Mathdoc The easiest way to generate the complete mathematical documentation is to call the faust2mathdoc script on a Faust file, as the -mdoc option leaves the process of generating the documentation unfinished (only the source is produced). Invoking the -mdoc Option Calling directly faust -mdoc does only the first part of the work, generating: a top-level directory, suffixed with -mdoc , 5 subdirectories ( cpp/ , pdf/ , src/ , svg/ , tex/ ), a Latex file containing the formulas, SVG files for block-diagrams. At this stage: cpp/ remains empty, pdf/ remains empty, src/ contains all the used Faust sources (even libraries), svg/ contains SVG block-diagram files, tex/ contains the generated Latex file. Invoking faust2mathdoc The faust2mathdoc script calls faust --mathdoc first, then it finishes the work: moving the output C++ file into cpp/ , converting all SVG files into pdf files (you must have svg2pdf installed, from the Cairo 2D graphics library), launching pdflatex on the Latex file (you must have both pdflatex and the breqn package installed), moving the resulting pdf file into pdf/ . Online Examples To get an idea of the results of this mathematical documentation, which captures the mathematical semantic of Faust programs, you can look at two pdf files online: http://faust.grame.fr/pdf/karplus.pdf (automatic documentation), http://faust.grame.fr/pdf/noise.pdf (manual documentation). You can also generate all mdoc pdfs at once, simply invoking the make mathdoc command inside the examples/ directory: for each %.dsp file, a complete %-mdoc directory will be generated, a single allmathpdfs/ directory will gather all the generated pdf files. Automatic Documentation By default, when no mdoc tag can be found in the input Faust file, the -mdoc option automatically generates a Latex file with four sections: Equations of process , gathering all formulas needed for process , Block-diagram schema of process , showing the top-level block-diagram of process , Notice of this documentation , summing up generation and conventions information, Complete listing of the input code , listing all needed input files (including libraries). Manual Documentation You can specify yourself the documentation instead of using the automatic mode, with five xml-like tags. That allows you to modify the presentation and to add your own comments, not only on process , but also about any expression you'd like to. Note that as soon as you declare an mdoc tag inside your Faust file, the default structure of the automatic mode is ignored, and all the Latex stuff becomes up to you! Six Tags Here are the six specific tags: mdoc /mdoc , to open a documentation field in the Faust code, equation /equation , to get equations of a Faust expression, diagram /diagram , to get the top-level block-diagram of a Faust expression, metadata /metadata , to reference Faust metadatas (cf. declarations), calling the corresponding keyword, notice / , to insert the \"adaptive\" notice all formulas actually printed, listing [attributes] / , to insert the listing of Faust files called. The listing / tag can have up to three boolean attributes (set to true by default): mdoctags for mdoc tags; dependencies for other files dependencies; distributed for the distribution of interleaved Faust code between mdoc sections. The mdoc Top-Level Tags The mdoc /mdoc tags are the top-level delimiters for Faust mathematical documentation sections. This means that the four other documentation tags can't be used outside these pairs. In addition of the four inner tags, mdoc /mdoc tags accept free Latex text, including its standard macros (like \\section , \\emph , etc.). This allows to manage the presentation of resulting tex file directly from within the input Faust file. The complete list of the Latex packages included by Faust can be found in the file architecture/latexheader.tex . An Example of Manual Mathdoc mdoc \\title{ metadata name /metadata } \\author{ metadata author /metadata } \\date{\\today} \\maketitle \\begin{tabular}{ll} \\hline \\textbf{name} metadata name /metadata \\\\ \\textbf{version} metadata version /metadata \\\\ \\textbf{author} metadata author /metadata \\\\ \\textbf{license} metadata license /metadata \\\\ \\textbf{copyright} metadata copyright /metadata \\\\ \\hline \\end{tabular} \\bigskip /mdoc //----------------------------------------------------------------- // Noise generator and demo file for the Faust math documentation //----------------------------------------------------------------- declare name Noise ; declare version 1.1 ; declare author Grame ; declare author Yghe ; declare license BSD ; declare copyright (c)GRAME 2009 ; mdoc \\section{Presentation of the noise.dsp Faust program} This program describes a white noise generator with an interactive volume, using a random function. \\subsection{The random function} /mdoc random = +(12345)~*(1103515245); mdoc The \\texttt{random} function describes a generator of random numbers, which equation follows. You should notice hereby the use of an integer arithmetic on 32 bits, relying on integer wrapping for big numbers. equation random /equation \\subsection{The noise function} /mdoc noise = random/2147483647.0; mdoc The white noise then corresponds to: equation noise /equation \\subsection{Just add a user interface element to play volume!} /mdoc process = noise * vslider( Volume[style:knob] , 0, 0, 1, 0.1); mdoc Endly, the sound level of this program is controlled by a user slider, which gives the following equation: equation process /equation \\section{Block-diagram schema of process} This process is illustrated on figure 1. diagram process /diagram \\section{Notice of this documentation} You might be careful of certain information and naming conventions used in this documentation: notice / \\section{Listing of the input code} The following listing shows the input Faust code, parsed to compile this mathematical documentation. listing mdoctags= false dependencies= false distributed= true / /mdoc The -stripmdoc Option The listing of the input code contains all the mathdoc text. As it may be useless in certain cases, we provide an option to strip mathdoc contents directly at compilation stage: -stripmdoc (short) or --strip-mdoc-tags (long). Localization of Mathdoc Files By default, texts used by the documentator are in English, but you can specify another language (French, German and Italian at the moment), using the -mdlang (or --mathdoc-lang ) option with a two-letters argument ( en , fr , it , etc.). The faust2mathdoc script also supports this option, plus a third short form with -l : faust2mathdoc -l fr myfaustfile.dsp If you would like to contribute to the localization effort, feel free to translate the mathdoc texts from any of the mathdoctexts-*.txt files, that are in the architecture directory ( mathdoctexts-fr.txt , mathdoctexts-it.txt , etc.). As these files are dynamically loaded, just adding a new file with an appropriate name should work. Summary of the Mathdoc Generation Steps First, to get the full mathematical documentation done on your Faust file, call faust2mathdoc myfaustfile.dsp . Then, open the pdf file myfaustfile-mdoc/pdf/myfaustfile.pdf . That's all !","title":"Math. Doc"},{"location":"guide/mathdoc/#mathematical-documentation","text":"The Faust compiler provides a mechanism to produce a self-describing documentation of the mathematical semantic of a Faust program, essentially as a pdf file. The corresponding options are -mdoc (short) or --mathdoc (long).","title":"Mathematical Documentation"},{"location":"guide/mathdoc/#goals-of-the-mathdoc","text":"There are three main goals, or uses, of the Faust mathematical documentation generator: to preserve signal processors, independently from any computer language but only under a mathematical form; to bring some help for debugging tasks, by showing the formulas as they are really computed after the compilation stage; to give a new teaching support, as a bridge between code and formulas for signal processing.","title":"Goals of the Mathdoc"},{"location":"guide/mathdoc/#installation-requirements","text":"faust , of course! svg2pdf (from the Cairo 2D graphics library), to convert block-diagrams, as Latex doesn't embed SVG directly, breqn , a Latex package to handle automatic breaking of long equations, pdflatex , to compile the Latex output file.","title":"Installation Requirements"},{"location":"guide/mathdoc/#generating-the-mathdoc","text":"The easiest way to generate the complete mathematical documentation is to call the faust2mathdoc script on a Faust file, as the -mdoc option leaves the process of generating the documentation unfinished (only the source is produced).","title":"Generating the Mathdoc"},{"location":"guide/mathdoc/#invoking-the-mdoc-option","text":"Calling directly faust -mdoc does only the first part of the work, generating: a top-level directory, suffixed with -mdoc , 5 subdirectories ( cpp/ , pdf/ , src/ , svg/ , tex/ ), a Latex file containing the formulas, SVG files for block-diagrams. At this stage: cpp/ remains empty, pdf/ remains empty, src/ contains all the used Faust sources (even libraries), svg/ contains SVG block-diagram files, tex/ contains the generated Latex file.","title":"Invoking the -mdoc Option"},{"location":"guide/mathdoc/#invoking-faust2mathdoc","text":"The faust2mathdoc script calls faust --mathdoc first, then it finishes the work: moving the output C++ file into cpp/ , converting all SVG files into pdf files (you must have svg2pdf installed, from the Cairo 2D graphics library), launching pdflatex on the Latex file (you must have both pdflatex and the breqn package installed), moving the resulting pdf file into pdf/ .","title":"Invoking faust2mathdoc"},{"location":"guide/mathdoc/#online-examples","text":"To get an idea of the results of this mathematical documentation, which captures the mathematical semantic of Faust programs, you can look at two pdf files online: http://faust.grame.fr/pdf/karplus.pdf (automatic documentation), http://faust.grame.fr/pdf/noise.pdf (manual documentation). You can also generate all mdoc pdfs at once, simply invoking the make mathdoc command inside the examples/ directory: for each %.dsp file, a complete %-mdoc directory will be generated, a single allmathpdfs/ directory will gather all the generated pdf files.","title":"Online Examples"},{"location":"guide/mathdoc/#automatic-documentation","text":"By default, when no mdoc tag can be found in the input Faust file, the -mdoc option automatically generates a Latex file with four sections: Equations of process , gathering all formulas needed for process , Block-diagram schema of process , showing the top-level block-diagram of process , Notice of this documentation , summing up generation and conventions information, Complete listing of the input code , listing all needed input files (including libraries).","title":"Automatic Documentation"},{"location":"guide/mathdoc/#manual-documentation","text":"You can specify yourself the documentation instead of using the automatic mode, with five xml-like tags. That allows you to modify the presentation and to add your own comments, not only on process , but also about any expression you'd like to. Note that as soon as you declare an mdoc tag inside your Faust file, the default structure of the automatic mode is ignored, and all the Latex stuff becomes up to you!","title":"Manual Documentation"},{"location":"guide/mathdoc/#six-tags","text":"Here are the six specific tags: mdoc /mdoc , to open a documentation field in the Faust code, equation /equation , to get equations of a Faust expression, diagram /diagram , to get the top-level block-diagram of a Faust expression, metadata /metadata , to reference Faust metadatas (cf. declarations), calling the corresponding keyword, notice / , to insert the \"adaptive\" notice all formulas actually printed, listing [attributes] / , to insert the listing of Faust files called. The listing / tag can have up to three boolean attributes (set to true by default): mdoctags for mdoc tags; dependencies for other files dependencies; distributed for the distribution of interleaved Faust code between mdoc sections.","title":"Six Tags"},{"location":"guide/mathdoc/#the-mdoc-top-level-tags","text":"The mdoc /mdoc tags are the top-level delimiters for Faust mathematical documentation sections. This means that the four other documentation tags can't be used outside these pairs. In addition of the four inner tags, mdoc /mdoc tags accept free Latex text, including its standard macros (like \\section , \\emph , etc.). This allows to manage the presentation of resulting tex file directly from within the input Faust file. The complete list of the Latex packages included by Faust can be found in the file architecture/latexheader.tex .","title":"The mdoc Top-Level Tags"},{"location":"guide/mathdoc/#an-example-of-manual-mathdoc","text":"mdoc \\title{ metadata name /metadata } \\author{ metadata author /metadata } \\date{\\today} \\maketitle \\begin{tabular}{ll} \\hline \\textbf{name} metadata name /metadata \\\\ \\textbf{version} metadata version /metadata \\\\ \\textbf{author} metadata author /metadata \\\\ \\textbf{license} metadata license /metadata \\\\ \\textbf{copyright} metadata copyright /metadata \\\\ \\hline \\end{tabular} \\bigskip /mdoc //----------------------------------------------------------------- // Noise generator and demo file for the Faust math documentation //----------------------------------------------------------------- declare name Noise ; declare version 1.1 ; declare author Grame ; declare author Yghe ; declare license BSD ; declare copyright (c)GRAME 2009 ; mdoc \\section{Presentation of the noise.dsp Faust program} This program describes a white noise generator with an interactive volume, using a random function. \\subsection{The random function} /mdoc random = +(12345)~*(1103515245); mdoc The \\texttt{random} function describes a generator of random numbers, which equation follows. You should notice hereby the use of an integer arithmetic on 32 bits, relying on integer wrapping for big numbers. equation random /equation \\subsection{The noise function} /mdoc noise = random/2147483647.0; mdoc The white noise then corresponds to: equation noise /equation \\subsection{Just add a user interface element to play volume!} /mdoc process = noise * vslider( Volume[style:knob] , 0, 0, 1, 0.1); mdoc Endly, the sound level of this program is controlled by a user slider, which gives the following equation: equation process /equation \\section{Block-diagram schema of process} This process is illustrated on figure 1. diagram process /diagram \\section{Notice of this documentation} You might be careful of certain information and naming conventions used in this documentation: notice / \\section{Listing of the input code} The following listing shows the input Faust code, parsed to compile this mathematical documentation. listing mdoctags= false dependencies= false distributed= true / /mdoc","title":"An Example of Manual Mathdoc"},{"location":"guide/mathdoc/#the-stripmdoc-option","text":"The listing of the input code contains all the mathdoc text. As it may be useless in certain cases, we provide an option to strip mathdoc contents directly at compilation stage: -stripmdoc (short) or --strip-mdoc-tags (long).","title":"The -stripmdoc Option"},{"location":"guide/mathdoc/#localization-of-mathdoc-files","text":"By default, texts used by the documentator are in English, but you can specify another language (French, German and Italian at the moment), using the -mdlang (or --mathdoc-lang ) option with a two-letters argument ( en , fr , it , etc.). The faust2mathdoc script also supports this option, plus a third short form with -l : faust2mathdoc -l fr myfaustfile.dsp If you would like to contribute to the localization effort, feel free to translate the mathdoc texts from any of the mathdoctexts-*.txt files, that are in the architecture directory ( mathdoctexts-fr.txt , mathdoctexts-it.txt , etc.). As these files are dynamically loaded, just adding a new file with an appropriate name should work.","title":"Localization of Mathdoc Files"},{"location":"guide/mathdoc/#summary-of-the-mathdoc-generation-steps","text":"First, to get the full mathematical documentation done on your Faust file, call faust2mathdoc myfaustfile.dsp . Then, open the pdf file myfaustfile-mdoc/pdf/myfaustfile.pdf . That's all !","title":"Summary of the Mathdoc Generation Steps"},{"location":"guide/midi/","text":"MIDI and Polyphony Support Similarly to OSC , several Faust architectures also provide MIDI support. This allows Faust applications to be controlled from any MIDI device (or to control MIDI devices). MIDI is also the preferable way to control Polyphonic instruments. Configuring MIDI in Faust MIDI support can be added to any Faust program (as long as the target architecture supports it: see tables below) simply by adding the [midi:on] metadata to the standard option metadata : declare options [midi:on] ; MIDI control is configured in Faust using metadata in UI elements . They are decoded by a special architecture that parses incoming MIDI messages and updates the appropriate control parameters, or send MIDI messages when the UI elements (i.e., sliders, buttons, etc.) are moved. All MIDI configuration metadata in Faust follow the following format: [midi:xxx yyy...] This section provides a list of the most common metadata that can be used to configure of the MIDI behavior of a Faust program. Below, when a 7-bit MIDI parameter is used to drive a button or a checkbox , its maximum value (127) maps to 1 (\"on\") while its minimum value (0) maps to 0 (\"off\"). [midi:ctrl num] Metadata The [midi:ctrl num] metadata assigns MIDI CC (control) to a specific UI element. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0. Usage toto = hslider( toto[midi:ctrl num] ,...); Where: num : the MIDI CC number Example In the following example, the frequency of a sawtooth wave oscillator is controlled by MIDI CC 11. When CC11=0, then the frequency is 200Hz, when CC11=127, then the frequency is 1000Hz. import( stdfaust.lib ); freq = hslider( frequency[midi:ctrl 11] ,200,50,1000,0.01) : si.smoo; process = os.sawtooth(freq); Try it Yourself >> [midi:keyon midikey] Metadata The [midi:keyon midikey] metadata assigns the velocity value of a key-on MIDI message received on a specific midikey to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0. Usage toto = hslider( toto[midi:keyon midikey] ,...); Where: midikey : the MIDI key number Example In the following example, the frequency of a sawtooth wave oscillator is controlled by the velocity value received on key 62 when a key-on message is sent. Therefore, the frequency will only be updated when MIDI key 62 is pressed. import( stdfaust.lib ); freq = hslider( frequency[midi:keyon 62] ,200,50,1000,0.01) : si.smoo; process = os.sawtooth(freq); Try it Yourself >> [midi:keyoff midikey] Metadata The [midi:keyoff midikey] metadata assigns the velocity value of a key-off MIDI message received on a specific midikey to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0. Usage toto = hslider( toto[midi:keyoff midikey] ,...); Where: midikey : the MIDI key number Example In the following example, the frequency of a sawtooth wave oscillator is controlled by the velocity value received on key 62 when a key-off message is sent. Therefore, the frequency will only be updated when MIDI key 62 is released. import( stdfaust.lib ); freq = hslider( frequency[midi:keyon 62] ,200,50,1000,0.01) : si.smoo; process = os.sawtooth(freq); Try it Yourself >> [midi:key midikey] Metadata The [midi:key midikey] metadata assigns the velocity value of key-on and key-off MIDI messages received on a specific midikey to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0. Usage toto = hslider( toto[midi:key midikey] ,...); Where: midikey : the MIDI key number Example In the following example, the frequency of a sawtooth wave oscillator is controlled by the velocity value received on key 62 when key-on and key-off messages are sent. Therefore, the frequency will only be updated when MIDI key 62 is pressed and released. import( stdfaust.lib ); freq = hslider( frequency[midi:key 62] ,200,50,1000,0.01) : si.smoo; process = os.sawtooth(freq); Try it Yourself >> [midi:keypress midikey] Metadata The [midi:keypress midikey] metadata assigns the pressure (after-touch) value of a specific midikey to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0. Usage toto = hslider( toto[midi:keypress midikey] ,...); Where: midikey : the MIDI key number Example In the following example, the frequency of a sawtooth wave oscillator is controlled by the pressure (after-touch) values received on key 62. import( stdfaust.lib ); freq = hslider( frequency[midi:keypress 62] ,200,50,1000,0.01) : si.smoo; process = os.sawtooth(freq); Try it Yourself >> [midi:pitchwheel] Metadata The [midi:pitchwheel] metadata assigns the pitch-wheel value to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 16383} range. When used with a button or a checkbox, 1 will be mapped to 16383, 0 will be mapped to 0. Usage toto = hslider( toto[midi:pitchwheel] ,...); Example In the following example, the frequency of a sawtooth wave oscillator is controlled by the pitch-wheel. import( stdfaust.lib ); freq = hslider( frequency[midi:pitchwheel] ,200,50,1000,0.01) : si.smoo; process = os.sawtooth(freq); Try it Yourself >> [midi:start] Metadata When used with a button or a checkbox, [midi:start] will trigger a value of 1 when a start MIDI message is received. Usage toto = checkbox( toto[midi:start] ); [midi:stop] Metadata When used with a button or a checkbox, [midi:stop] will trigger a value of 0 when a stop MIDI message is received. Usage toto = checkbox( toto[midi:stop] ); [midi:clock] Metadata When used with a button or a checkbox, [midi:clock] will deliver a sequence of successive 1 and 0 values each time a clock MIDI message is received (seen by Faust code as a square command signal, to be used to compute higher level information). Usage toto = checkbox( toto[midi:clock] ); MIDI Sync MIDI clock-based synchronization can be used to slave a given Faust program using the metadata presented in the 3 past sections. A typical Faust program will then use the MIDI clock stream to possibly compute the BPM information, or for any synchronization need it may have. Here is a simple example of a sinus generated which a frequency controlled by the MIDI clock stream, and starting/stopping when receiving the MIDI start/stop messages: import( stdfaust.lib ); // square signal (1/0), changing state at each received clock clocker = checkbox( MIDI clock[midi:clock] ); // ON/OFF button controlled with MIDI start/stop messages play = checkbox( ON/OFF [midi:start] [midi:stop] ); // detect front front(x) = (x-x') != 0.0; // count number of peaks during one second freq(x) = (x-x@ma.SR) : + ~ _; process = os.osc(8*freq(front(clocker))) * play; Try it Yourself >> MIDI Polyphony Support Polyphony is conveniently handled in Faust directly by Faust Architectures . Note that programming polyphonic instrument completely from scratch in Faust and without relying on architectures is also possible. In fact, this feature is indispensable if complex signal interactions between the different voices have to be described (like sympathetic strings resonance in a physical model, etc.). However, since all voices would always be computed, this approach could be too CPU costly for simpler or more limited needs. In this case describing a single voice in a Faust DSP program and externally combining several of them with a special polyphonic instrument aware architecture file is a better solution. Moreover, this special architecture file takes care of dynamic voice allocation and control MIDI messages decoding and mapping. Polyphony support can be added to any Faust program (as long as the target architecture supports it) simply by adding the [nvoices:n] metadata to the standard option metadata where n is the maximum number of voices of polyphony to be allocated: declare options [nvoices:12] ; Standard Polyphony Parameters Most Faust architectures allow for the implementation of polyphonic instruments simply by using a set of \"standard user interface names.\" Hence, any Faust program declaring the freq , gain , and gate parameter is polyphony-compatible. These 3 parameters are directly associated to key-on and key-off events and have the following behavior: When a key-on event is received, gate will be set to 1. Inversely, when a key-off event is received, gate will be set to 0. Therefore, gate is typically used to trigger an envelope, etc. freq is a frequency in Hz computed automatically in function of the value of the pitch contained in a key-on or a key-off message. gain is a linear gain (value between 0-1) computed in function of the velocity value contained in a key-on or a key-off message. Example: Simple Polyphonic Synthesizer In the following example, the standard freq , gain , and gate parameters are used to implement a simple polyphonic synth. import( stdfaust.lib ); freq = hslider( freq ,200,50,1000,0.01); gain = hslider( gain ,0.5,0,1,0.01); gate = button( gate ); process = os.sawtooth(freq)*gain*gate; Try it Yourself >> Note that if you execute this code in the Faust online editor with polyphony mode activated, you should be able to control this simple synth with any MIDI keyboard connected to your computer. This will only work if you're using Google Chrome (most other browsers are not MIDI-compatible). The previous example can be slightly improved by adding an envelope generator and controlling it with gain and gate : import( stdfaust.lib ); freq = hslider( freq ,200,50,1000,0.01); gain = hslider( gain ,0.5,0,1,0.01); gate = button( gate ); envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain; process = os.sawtooth(freq)*envelope; Try it Yourself >> Warning: Note that all the active voices of polyphony are added together without scaling! This means that the previous example will likely click if several voices are played at the same time. It is the Faust programmer's responsibility to take this into account in his code. For example, assuming that the number of active voices will always be smaller or equal to 4, the following safeguard could be added to the previous example: process = os.sawtooth(freq)*envelope : /(4); Configuring and Activating Polyphony Polyphony can be activated \"manually\" in some Faust architectures using an option/flag during compilation (e.g., typically -poly or -nvoices in the faust2... scripts). That's also how the Faust online editor works where a button can be used to turn polyphony on or off. However, the most standard way to activate polyphony in Faust is to declare the [nvoices:n] metadata which allows us to specify the maximum number of voices of polyphony ( n ) that will be allocated in the generated program. For example, the Faust program from the previous section could be modified such that: declare options [midi:on][nvoices:12] ; import( stdfaust.lib ); freq = hslider( freq ,200,50,1000,0.01); gain = hslider( gain ,0.5,0,1,0.01); gate = button( gate ); envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain; process = os.sawtooth(freq)*envelope; Try it Yourself >> which when compiled running (for example): faust2jaqt faustProgram.dsp will generate a MIDI-controllable polyphonic synthesizer. Audio Effects and Polyphonic Synthesizer While audio audio effects can be added directly to the process line of a Faust synthesizer, for example: process = os.sawtooth(freq)*envelope : reverb; it is not a good practice since a new instance of that effect will be created for each active voice of polyphony. The main consequence of this would be an increased CPU cost. Similarly to process , Faust allows for the declaration of an effect line, which identifies an audio effect to be connected to the output of the polyphonic synthesizer. For example, a simple reverb can be added to the previous example simply by writing: declare options [midi:on][nvoices:12] ; import( stdfaust.lib ); freq = hslider( freq ,200,50,1000,0.01); gain = hslider( gain ,0.5,0,1,0.01); gate = button( gate ); envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain; process = os.sawtooth(freq)*envelope : _,_; effect = dm.zita_light; Try it Yourself >> In this case, the polyphonic part is based on process and a single instance of the effect defined in effect will be created and shared by all voices. Note that since dm.zita_light is a stereo effect, the output of process must be split into 2 signals. Also, be aware that this type of construction wont be visible in the corresponding block diagram that will only show what's implemented in the process line. Polyphony and Continuous Pitch Key-on and key-off MIDI messages only send the \"base pitch\" of the instance of a note. Hence, if only the freq standard parameter is used to control the frequency of the synthesizer, its pitch will always be \"quantized\" to the nearest semitone. In order to be able to do glissandi, vibrato, etc., a variable associated to the pitch-wheel needs to be declared and must interact with the \"base frequency\" value retrieved from freq as such: f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01); freq = f*bend; // the final freq parameter to be used The bend variable is controlled by the pitch-wheel thanks to [midi:pitchwheel] metadata . bend is used as a factor multiplied to the base frequency retrieved from freq . Therefore, the default value of bend should always be 1 which corresponds to the central position of the pitch wheel (MIDI value 64). A value smaller than 1 will decrease the pitch and a value greater than 1 will increase it. While the above example will have the expected behavior, it is likely that clicking will happen when changing the value of bend since this parameter is not smoothed. Unfortunately, regular smoothing (through the use of si.smoo , for example) is not a good option here. This is due to the fact that instances of polyphonic voices are frozen when a voice is not being used. Since the value of bend might jump from one value to another when a voice is being reactivated/reused, continuous smoothing would probably create an \"ugly sweep\" in that case. Hence, si.polySmooth should be used in this context instead of si.smoo . This function shuts down smoothing for a given number of samples when a trigger is activated. Reusing the example from the previous section, we can implement a click-free polyphonic synthesizer with continuous pitch control: declare options [midi:on][nvoices:12] ; import( stdfaust.lib ); f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01) : si.polySmooth(gate,0.999,1); gain = hslider( gain ,0.5,0,1,0.01); gate = button( gate ); freq = f*bend; envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain; process = os.sawtooth(freq)*envelope : _,_; effect = dm.zita_light; Try it Yourself >> Observe the usage of si.polySmooth here: when gate=0 the signal is not smoothed, when gate=1 the signal is smoothed with a factor of 0.999 after one sample. Complete Example: Sustain Pedal and Additional Parameters Just for fun ;), we improve in this section the example from the previous one by implementing sustain pedal control as well as some modulation controlled by the modulation wheel of the MIDI keyboard. Sustain pedal control can be easily added simply by declaring a sustain parameter controlled by MIDI CC 64 (which is directly linked to the sustain pedal) and interacting with the standard gate parameter: s = hslider( sustain[midi:ctrl 64] ,0,0,1,1); t = button( gate ); gate = t+s : min(1); Hence, gate will remain equal to 1 as long as the sustain pedal is pressed. The simple synthesizer from the previous section (which is literally just a sawtooth oscillator) can be slightly improved by processing it with a dynamically-controlled lowpass filter: declare options [midi:on][nvoices:12] ; import( stdfaust.lib ); f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01) : si.polySmooth(gate,0.999,1); gain = hslider( gain ,0.5,0,1,0.01); s = hslider( sustain[midi:ctrl 64] ,0,0,1,1); cutoff = hslider( cutoff[midi:ctrl 1] ,1000,50,4000,0.01) : si.smoo; t = button( gate ); freq = f*bend; gate = t+s : min(1); envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain; process = os.sawtooth(freq)*envelope : fi.lowpass(3,cutoff) : _,_; effect = dm.zita_light; Try it Yourself >> MIDI CC 1 corresponds to the modulation wheel which is used here to control the cut-off frequency of the lowpass filter.","title":"MIDI Support"},{"location":"guide/midi/#midi-and-polyphony-support","text":"Similarly to OSC , several Faust architectures also provide MIDI support. This allows Faust applications to be controlled from any MIDI device (or to control MIDI devices). MIDI is also the preferable way to control Polyphonic instruments.","title":"MIDI and Polyphony Support"},{"location":"guide/midi/#configuring-midi-in-faust","text":"MIDI support can be added to any Faust program (as long as the target architecture supports it: see tables below) simply by adding the [midi:on] metadata to the standard option metadata : declare options [midi:on] ; MIDI control is configured in Faust using metadata in UI elements . They are decoded by a special architecture that parses incoming MIDI messages and updates the appropriate control parameters, or send MIDI messages when the UI elements (i.e., sliders, buttons, etc.) are moved. All MIDI configuration metadata in Faust follow the following format: [midi:xxx yyy...] This section provides a list of the most common metadata that can be used to configure of the MIDI behavior of a Faust program. Below, when a 7-bit MIDI parameter is used to drive a button or a checkbox , its maximum value (127) maps to 1 (\"on\") while its minimum value (0) maps to 0 (\"off\").","title":"Configuring MIDI in Faust"},{"location":"guide/midi/#midictrl-num-metadata","text":"The [midi:ctrl num] metadata assigns MIDI CC (control) to a specific UI element. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0. Usage toto = hslider( toto[midi:ctrl num] ,...); Where: num : the MIDI CC number Example In the following example, the frequency of a sawtooth wave oscillator is controlled by MIDI CC 11. When CC11=0, then the frequency is 200Hz, when CC11=127, then the frequency is 1000Hz. import( stdfaust.lib ); freq = hslider( frequency[midi:ctrl 11] ,200,50,1000,0.01) : si.smoo; process = os.sawtooth(freq); Try it Yourself >>","title":"[midi:ctrl num] Metadata"},{"location":"guide/midi/#midikeyon-midikey-metadata","text":"The [midi:keyon midikey] metadata assigns the velocity value of a key-on MIDI message received on a specific midikey to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0. Usage toto = hslider( toto[midi:keyon midikey] ,...); Where: midikey : the MIDI key number Example In the following example, the frequency of a sawtooth wave oscillator is controlled by the velocity value received on key 62 when a key-on message is sent. Therefore, the frequency will only be updated when MIDI key 62 is pressed. import( stdfaust.lib ); freq = hslider( frequency[midi:keyon 62] ,200,50,1000,0.01) : si.smoo; process = os.sawtooth(freq); Try it Yourself >>","title":"[midi:keyon midikey] Metadata"},{"location":"guide/midi/#midikeyoff-midikey-metadata","text":"The [midi:keyoff midikey] metadata assigns the velocity value of a key-off MIDI message received on a specific midikey to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0. Usage toto = hslider( toto[midi:keyoff midikey] ,...); Where: midikey : the MIDI key number Example In the following example, the frequency of a sawtooth wave oscillator is controlled by the velocity value received on key 62 when a key-off message is sent. Therefore, the frequency will only be updated when MIDI key 62 is released. import( stdfaust.lib ); freq = hslider( frequency[midi:keyon 62] ,200,50,1000,0.01) : si.smoo; process = os.sawtooth(freq); Try it Yourself >>","title":"[midi:keyoff midikey] Metadata"},{"location":"guide/midi/#midikey-midikey-metadata","text":"The [midi:key midikey] metadata assigns the velocity value of key-on and key-off MIDI messages received on a specific midikey to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0. Usage toto = hslider( toto[midi:key midikey] ,...); Where: midikey : the MIDI key number Example In the following example, the frequency of a sawtooth wave oscillator is controlled by the velocity value received on key 62 when key-on and key-off messages are sent. Therefore, the frequency will only be updated when MIDI key 62 is pressed and released. import( stdfaust.lib ); freq = hslider( frequency[midi:key 62] ,200,50,1000,0.01) : si.smoo; process = os.sawtooth(freq); Try it Yourself >>","title":"[midi:key midikey] Metadata"},{"location":"guide/midi/#midikeypress-midikey-metadata","text":"The [midi:keypress midikey] metadata assigns the pressure (after-touch) value of a specific midikey to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 127} range. When used with a button or a checkbox, 1 will be mapped to 127, 0 will be mapped to 0. Usage toto = hslider( toto[midi:keypress midikey] ,...); Where: midikey : the MIDI key number Example In the following example, the frequency of a sawtooth wave oscillator is controlled by the pressure (after-touch) values received on key 62. import( stdfaust.lib ); freq = hslider( frequency[midi:keypress 62] ,200,50,1000,0.01) : si.smoo; process = os.sawtooth(freq); Try it Yourself >>","title":"[midi:keypress midikey] Metadata"},{"location":"guide/midi/#midipitchwheel-metadata","text":"The [midi:pitchwheel] metadata assigns the pitch-wheel value to a Faust parameter. When used in a slider or a bargraph, this metadata will map the UI element value to the {0, 16383} range. When used with a button or a checkbox, 1 will be mapped to 16383, 0 will be mapped to 0. Usage toto = hslider( toto[midi:pitchwheel] ,...); Example In the following example, the frequency of a sawtooth wave oscillator is controlled by the pitch-wheel. import( stdfaust.lib ); freq = hslider( frequency[midi:pitchwheel] ,200,50,1000,0.01) : si.smoo; process = os.sawtooth(freq); Try it Yourself >>","title":"[midi:pitchwheel] Metadata"},{"location":"guide/midi/#midistart-metadata","text":"When used with a button or a checkbox, [midi:start] will trigger a value of 1 when a start MIDI message is received. Usage toto = checkbox( toto[midi:start] );","title":"[midi:start] Metadata"},{"location":"guide/midi/#midistop-metadata","text":"When used with a button or a checkbox, [midi:stop] will trigger a value of 0 when a stop MIDI message is received. Usage toto = checkbox( toto[midi:stop] );","title":"[midi:stop] Metadata"},{"location":"guide/midi/#midiclock-metadata","text":"When used with a button or a checkbox, [midi:clock] will deliver a sequence of successive 1 and 0 values each time a clock MIDI message is received (seen by Faust code as a square command signal, to be used to compute higher level information). Usage toto = checkbox( toto[midi:clock] );","title":"[midi:clock] Metadata"},{"location":"guide/midi/#midi-sync","text":"MIDI clock-based synchronization can be used to slave a given Faust program using the metadata presented in the 3 past sections. A typical Faust program will then use the MIDI clock stream to possibly compute the BPM information, or for any synchronization need it may have. Here is a simple example of a sinus generated which a frequency controlled by the MIDI clock stream, and starting/stopping when receiving the MIDI start/stop messages: import( stdfaust.lib ); // square signal (1/0), changing state at each received clock clocker = checkbox( MIDI clock[midi:clock] ); // ON/OFF button controlled with MIDI start/stop messages play = checkbox( ON/OFF [midi:start] [midi:stop] ); // detect front front(x) = (x-x') != 0.0; // count number of peaks during one second freq(x) = (x-x@ma.SR) : + ~ _; process = os.osc(8*freq(front(clocker))) * play; Try it Yourself >>","title":"MIDI Sync"},{"location":"guide/midi/#midi-polyphony-support","text":"Polyphony is conveniently handled in Faust directly by Faust Architectures . Note that programming polyphonic instrument completely from scratch in Faust and without relying on architectures is also possible. In fact, this feature is indispensable if complex signal interactions between the different voices have to be described (like sympathetic strings resonance in a physical model, etc.). However, since all voices would always be computed, this approach could be too CPU costly for simpler or more limited needs. In this case describing a single voice in a Faust DSP program and externally combining several of them with a special polyphonic instrument aware architecture file is a better solution. Moreover, this special architecture file takes care of dynamic voice allocation and control MIDI messages decoding and mapping. Polyphony support can be added to any Faust program (as long as the target architecture supports it) simply by adding the [nvoices:n] metadata to the standard option metadata where n is the maximum number of voices of polyphony to be allocated: declare options [nvoices:12] ;","title":"MIDI Polyphony Support"},{"location":"guide/midi/#standard-polyphony-parameters","text":"Most Faust architectures allow for the implementation of polyphonic instruments simply by using a set of \"standard user interface names.\" Hence, any Faust program declaring the freq , gain , and gate parameter is polyphony-compatible. These 3 parameters are directly associated to key-on and key-off events and have the following behavior: When a key-on event is received, gate will be set to 1. Inversely, when a key-off event is received, gate will be set to 0. Therefore, gate is typically used to trigger an envelope, etc. freq is a frequency in Hz computed automatically in function of the value of the pitch contained in a key-on or a key-off message. gain is a linear gain (value between 0-1) computed in function of the velocity value contained in a key-on or a key-off message. Example: Simple Polyphonic Synthesizer In the following example, the standard freq , gain , and gate parameters are used to implement a simple polyphonic synth. import( stdfaust.lib ); freq = hslider( freq ,200,50,1000,0.01); gain = hslider( gain ,0.5,0,1,0.01); gate = button( gate ); process = os.sawtooth(freq)*gain*gate; Try it Yourself >> Note that if you execute this code in the Faust online editor with polyphony mode activated, you should be able to control this simple synth with any MIDI keyboard connected to your computer. This will only work if you're using Google Chrome (most other browsers are not MIDI-compatible). The previous example can be slightly improved by adding an envelope generator and controlling it with gain and gate : import( stdfaust.lib ); freq = hslider( freq ,200,50,1000,0.01); gain = hslider( gain ,0.5,0,1,0.01); gate = button( gate ); envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain; process = os.sawtooth(freq)*envelope; Try it Yourself >> Warning: Note that all the active voices of polyphony are added together without scaling! This means that the previous example will likely click if several voices are played at the same time. It is the Faust programmer's responsibility to take this into account in his code. For example, assuming that the number of active voices will always be smaller or equal to 4, the following safeguard could be added to the previous example: process = os.sawtooth(freq)*envelope : /(4);","title":"Standard Polyphony Parameters"},{"location":"guide/midi/#configuring-and-activating-polyphony","text":"Polyphony can be activated \"manually\" in some Faust architectures using an option/flag during compilation (e.g., typically -poly or -nvoices in the faust2... scripts). That's also how the Faust online editor works where a button can be used to turn polyphony on or off. However, the most standard way to activate polyphony in Faust is to declare the [nvoices:n] metadata which allows us to specify the maximum number of voices of polyphony ( n ) that will be allocated in the generated program. For example, the Faust program from the previous section could be modified such that: declare options [midi:on][nvoices:12] ; import( stdfaust.lib ); freq = hslider( freq ,200,50,1000,0.01); gain = hslider( gain ,0.5,0,1,0.01); gate = button( gate ); envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain; process = os.sawtooth(freq)*envelope; Try it Yourself >> which when compiled running (for example): faust2jaqt faustProgram.dsp will generate a MIDI-controllable polyphonic synthesizer.","title":"Configuring and Activating Polyphony"},{"location":"guide/midi/#audio-effects-and-polyphonic-synthesizer","text":"While audio audio effects can be added directly to the process line of a Faust synthesizer, for example: process = os.sawtooth(freq)*envelope : reverb; it is not a good practice since a new instance of that effect will be created for each active voice of polyphony. The main consequence of this would be an increased CPU cost. Similarly to process , Faust allows for the declaration of an effect line, which identifies an audio effect to be connected to the output of the polyphonic synthesizer. For example, a simple reverb can be added to the previous example simply by writing: declare options [midi:on][nvoices:12] ; import( stdfaust.lib ); freq = hslider( freq ,200,50,1000,0.01); gain = hslider( gain ,0.5,0,1,0.01); gate = button( gate ); envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain; process = os.sawtooth(freq)*envelope : _,_; effect = dm.zita_light; Try it Yourself >> In this case, the polyphonic part is based on process and a single instance of the effect defined in effect will be created and shared by all voices. Note that since dm.zita_light is a stereo effect, the output of process must be split into 2 signals. Also, be aware that this type of construction wont be visible in the corresponding block diagram that will only show what's implemented in the process line.","title":"Audio Effects and Polyphonic Synthesizer"},{"location":"guide/midi/#polyphony-and-continuous-pitch","text":"Key-on and key-off MIDI messages only send the \"base pitch\" of the instance of a note. Hence, if only the freq standard parameter is used to control the frequency of the synthesizer, its pitch will always be \"quantized\" to the nearest semitone. In order to be able to do glissandi, vibrato, etc., a variable associated to the pitch-wheel needs to be declared and must interact with the \"base frequency\" value retrieved from freq as such: f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01); freq = f*bend; // the final freq parameter to be used The bend variable is controlled by the pitch-wheel thanks to [midi:pitchwheel] metadata . bend is used as a factor multiplied to the base frequency retrieved from freq . Therefore, the default value of bend should always be 1 which corresponds to the central position of the pitch wheel (MIDI value 64). A value smaller than 1 will decrease the pitch and a value greater than 1 will increase it. While the above example will have the expected behavior, it is likely that clicking will happen when changing the value of bend since this parameter is not smoothed. Unfortunately, regular smoothing (through the use of si.smoo , for example) is not a good option here. This is due to the fact that instances of polyphonic voices are frozen when a voice is not being used. Since the value of bend might jump from one value to another when a voice is being reactivated/reused, continuous smoothing would probably create an \"ugly sweep\" in that case. Hence, si.polySmooth should be used in this context instead of si.smoo . This function shuts down smoothing for a given number of samples when a trigger is activated. Reusing the example from the previous section, we can implement a click-free polyphonic synthesizer with continuous pitch control: declare options [midi:on][nvoices:12] ; import( stdfaust.lib ); f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01) : si.polySmooth(gate,0.999,1); gain = hslider( gain ,0.5,0,1,0.01); gate = button( gate ); freq = f*bend; envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain; process = os.sawtooth(freq)*envelope : _,_; effect = dm.zita_light; Try it Yourself >> Observe the usage of si.polySmooth here: when gate=0 the signal is not smoothed, when gate=1 the signal is smoothed with a factor of 0.999 after one sample.","title":"Polyphony and Continuous Pitch"},{"location":"guide/midi/#complete-example-sustain-pedal-and-additional-parameters","text":"Just for fun ;), we improve in this section the example from the previous one by implementing sustain pedal control as well as some modulation controlled by the modulation wheel of the MIDI keyboard. Sustain pedal control can be easily added simply by declaring a sustain parameter controlled by MIDI CC 64 (which is directly linked to the sustain pedal) and interacting with the standard gate parameter: s = hslider( sustain[midi:ctrl 64] ,0,0,1,1); t = button( gate ); gate = t+s : min(1); Hence, gate will remain equal to 1 as long as the sustain pedal is pressed. The simple synthesizer from the previous section (which is literally just a sawtooth oscillator) can be slightly improved by processing it with a dynamically-controlled lowpass filter: declare options [midi:on][nvoices:12] ; import( stdfaust.lib ); f = hslider( freq ,300,50,2000,0.01); bend = hslider( bend[midi:pitchwheel] ,1,0,10,0.01) : si.polySmooth(gate,0.999,1); gain = hslider( gain ,0.5,0,1,0.01); s = hslider( sustain[midi:ctrl 64] ,0,0,1,1); cutoff = hslider( cutoff[midi:ctrl 1] ,1000,50,4000,0.01) : si.smoo; t = button( gate ); freq = f*bend; gate = t+s : min(1); envelope = en.adsr(0.01,0.01,0.8,0.1,gate)*gain; process = os.sawtooth(freq)*envelope : fi.lowpass(3,cutoff) : _,_; effect = dm.zita_light; Try it Yourself >> MIDI CC 1 corresponds to the modulation wheel which is used here to control the cut-off frequency of the lowpass filter.","title":"Complete Example: Sustain Pedal and Additional Parameters"},{"location":"guide/osc/","text":"OSC Support Overview Most Faust architectures provide Open Sound Control (OSC) support (the implementation is based internally on the oscpack library by Ross Bencina). This allows applications to be remotely controlled from any OSC-capable application, programming language, or hardware device. OSC support can be added to any Faust program (as long as the target architecture supports it: see tables below) simply by adding the [osc:on] metadata to the standard option metadata : declare options [osc:on] ; The following tables provides a list of Faust architectures providing OSC support. Audio System Environment Alsa GTK, Qt, Console Jack GTK, Qt, Console Netjack GTK, Qt, Console PortAudio GTK, Qt **_Linux Faust Architectures with OSC Support_** Audio System Environment CoreAudio Qt Jack Qt, Console Netjack Qt, Console PortAudio Qt **_OSX Faust Architectures with OSC Support_** Audio System Environment Jack Qt, Console PortAudio Qt **_Windows Faust Architectures with OSC Support_** Environment Android iOS JUCE Bela **_Other Faust Architectures with OSC Support_** Simple Example To illustrate how OSC support works let's define a very simple noise generator with a level control (we'll call it noise.dsp ): import( stdfaust.lib ); process = no.noise*hslider( level ,0,0,1,0.01); Try it Yourself >> This example can be compiled as a standalone Jack Qt application with OSC support simply by running the following command: faust2jaqt -osc noise.dsp When the generated application is ran from the command line: ./noise various information is printed in the standard output, including: Faust OSC version 0.93 application 'noise' is running on UDP ports 5510, 5511, 5512 Hence, the OSC module makes use of three different UDP ports: 5510 is the listening port number: control messages should be addressed to this port. 5511 is the output port number: control messages sent by the application and answers to query messages are sent to this port. 5512 is the error port number: used for asynchronous error notifications. These OSC parameters can be changed from the command line using one of the following options: -port number sets the port number used by the application to receive messages. -outport number sets the port number used by the application to transmit messages. -errport number sets the port number used by the application to transmit error messages. -desthost host sets the destination host for the messages sent by the application. -xmit 0|1|2 turns transmission OFF, ALL, or ALIAS (default OFF). When transmission is OFF, input elements can be controlled using their addresses or aliases (if present). When transmission is ALL, input elements can be controlled using their addresses or aliases (if present), user's actions and output elements (i.e., bargraph , etc.) are transmitted as OSC messages as well as aliases (if present). When transmission is ALIAS, input elements can only be controlled using their aliases, user's actions and output elements are transmitted as aliases only. -xmitfilter path allows to filter output messages. Note that path can be a regular expression (like /freeverb/Reverb1/* ). For example: ./noise -xmit 1 -desthost 192.168.1.104 -outport 6000 will run noise with transmission mode ON, using 192.168.1.104 on port 6000 as destination. Automatic Port Allocation In order to address each application individually, only one application can be listening on a single port at one time. Therefore when the default incoming port 5510 is already opened by some other application, an application will automatically try increasing port numbers until it finds an available port. Let say that we start noise and mixer (two Faust-generated applications with OSC support) on the same machine, we'll get the following: $ ./noise ... Faust OSC version 0.93 application 'noise' is running on UDP ports 5510, 5511, 5512 $ ./mixer ... Faust OSC version 0.93 application 'mixer' is running on UDP ports 5513, 5511, 5512 The mixer application fails to open the default incoming port 5510 because it is already opened by noise . Therefore it tries to find an available port starting from 5513 and opens it. Please note that the two outcoming ports 5511 and 5512 are shared by all running applications. Discovering OSC Applications The commands oscsend and oscdump from the liblo package provide a convenient mean to experiment with OSC control and potentially debug applications with OSC support. oscsend [hostname] [port] [address] [types] [values] : sends OSC messages via UDP. [types] is a string, the letters indicates the type of the following values: i=integer , f=float , s=string , etc. oscdump [port] : receives OSC messages via UDP and dump to standard output Note that OSC messages can be sent from any OSC-compatible applications (e.g., PureData, Max/MSP, etc.). In the following examples, we'll use two separate terminal windows. The first one will be used to send OSC messages to the noise application using oscsend . The second terminal will be used to monitor the messages sent by the application using oscdump . Commands executed on terminal 1 will be preceded by T1$ . Messages received on terminal 2 will be preceded by T2: . To monitor on terminal T2 the OSC messages received on UDP port 5511, oscdump will be used: T2$ oscdump 5511 Once set we can use the hello message to scan UDP ports for Faust applications. For example: T1$ oscsend localhost 5510 /* s hello gives us the root message address, the network and the UDP ports used by the noise application: T2: /noise siii 192.168.1.102 5510 5511 5512 Discovering the OSC Interface of an Application The OSC interface of an application (the set of OSC messages we can use to control it) can be discovered by sending the get message to the root: T1$ oscsend localhost 5510 /noise s get As an answer to this OSC message, a full description is printed in terminal T2: T2: /noise sF xmit #F T2: /noise ss desthost 127.0.0.1 T2: /noise si outport 5511 T2: /noise si errport 5512 T2: /noise/level fff 0.000000 0.000000 1.000000 The root of the OSC interface is /noise . Transmission is OFF, xmit is set to false. The destination host for sending messages is 127.0.0.1 , the output port is 5511 and the error port is 5512 . The application has only one user interface element: /noise/level with current value 0.0 , minimal value 0.0 and maximal value 1.0 . Widget's OSC Address Each widget of an application has a unique OSC address obtained by concatenating the labels of it's surrounding groups with its own label. There are potential conflicts between widget's labels and the OSC address space. An OSC symbolic name is an ASCII string consisting of a restricted set of printable characters. Therefore to ensure compatibility spaces are replaced by underscores and some other characters (asterisk, comma, forward, question mark, open bracket, close bracket, open curly brace, close curly brace) are replaced by hyphens. Here is as an example mix4.dsp , a very simplified monophonic audio mixer with 4 inputs and one output. For each input we have a mute button and a level slider: input(v) = vgroup( input %v , *(1-checkbox( mute )) : *(vslider( level , 0, 0, 1, 0.01))); process = hgroup( mixer , par(i, 4, input(i)) : _); Try it Yourself >> If we query this application: T1$ oscsend localhost 5510 /* s get We get a full description of its OSC interface on terminal T2: T2: /mixer sF xmit #F T2: /mixer ss desthost 127.0.0.1 T2: /mixer si outport 5511 T2: /mixer si errport 5512 T2: /mixer/input_0/level fff 0.0000 0.0000 1.0000 T2: /mixer/input_0/mute fff 0.0000 0.0000 1.0000 T2: /mixer/input_1/level fff 0.0000 0.0000 1.0000 T2: /mixer/input_1/mute fff 0.0000 0.0000 1.0000 T2: /mixer/input_2/level fff 0.0000 0.0000 1.0000 T2: /mixer/input_2/mute fff 0.0000 0.0000 1.0000 T2: /mixer/input_3/level fff 0.0000 0.0000 1.0000 T2: /mixer/input_3/mute fff 0.0000 0.0000 1.0000 As we can see, each widget has a unique OSC address obtained by concatenating the top level group label \"mixer,\" with the \"input\" group label and the widget label (see the Labels as Pathnames Section ). Please, note that blank spaces are replaced by underscores and metadata are removed during this operation. All addresses must have a common root. This is the case in our example because there is a unique horizontal group mixer containing all widgets. If a common root is missing as in the following code: input(v) = vgroup( input %v , *(1-checkbox( mute )) : *(vslider( level , 0, 0, 1, 0.01))); process = par(i, 4, input(i)) : _; then a default vertical group is automatically create by the Faust compiler using the name of the file mix4 as label: T2: /mix4 sF xmit #F T2: /mix4 ss desthost 127.0.0.1 T2: /mix4 si outport 5511 T2: /mix4 si errport 5512 T2: /mix4/input_0/level fff 0.0000 0.0000 1.0000 T2: /mix4/input_0/mute fff 0.0000 0.0000 1.0000 T2: /mix4/input_1/level fff 0.0000 0.0000 1.0000 T2: /mix4/input_1/mute fff 0.0000 0.0000 1.0000 T2: /mix4/input_2/level fff 0.0000 0.0000 1.0000 T2: /mix4/input_2/mute fff 0.0000 0.0000 1.0000 T2: /mix4/input_3/level fff 0.0000 0.0000 1.0000 T2: /mix4/input_3/mute fff 0.0000 0.0000 1.0000 Controlling the Application Via OSC Any user interface element of the application can be controlled by sending one of the previously discovered messages/addresses. For example, to set the noise level of the application to 0.2 the following message can be sent: T1$ oscsend localhost 5510 /noise/level f 0.2 If we now query /noise/level we get, as expected, the value 0.2 : T1$ oscsend localhost 5510 /noise/level s get T2: /noise/level fff 0.2000 0.0000 1.0000 Turning Transmission ON The xmit message at the root level is used to control the realtime transmission of OSC messages corresponding to user interface's actions. For example: T1$ oscsend localhost 5510 /noise si xmit 1 turns transmission in ALL mode. Now if we move the level slider we get a bunch of messages: T2: /noise/level f 0.024000 T2: /noise/level f 0.032000 T2: /noise/level f 0.105000 T2: /noise/level f 0.250000 T2: /noise/level f 0.258000 T2: /noise/level f 0.185000 T2: /noise/level f 0.145000 T2: /noise/level f 0.121000 T2: /noise/level f 0.105000 T2: /noise/level f 0.008000 T2: /noise/level f 0.000000 This feature can be typically used for automation to record and replay actions on the user interface, or to remote control from one application to another. It can be turned OFF any time using: T1$ oscsend localhost 5510 /noise si xmit 0 Use the ALIAS ( xmit = 2 ) mode if you need to restrict the access to your program: when the ALIAS mode is used, only aliases of input elements (sliders, buttons...) can be used to control them, and output elements (bargraph) will only emit on their aliases. Filtering OSC Messages When the transmission of OSC messages is ON, all the user interface elements are sent through the OSC connection. T2: /harpe/level f 0.024000 T2: /harpe/hand f 0.1 T2: /harpe/level f 0.024000 T2: /harpe/hand f 0.25 T2: /harpe/level f 0.024000 T2: /harpe/hand f 0.44 T2: /noise/level f 0.145000 T2: /harpe/hand f 0.78 T2: /noise/level f 0.145000 T2: /harpe/hand f 0.99 We can choose to filter unwanted parameters (or group of parameters). For example: T1$ oscsend localhost 5510 /harpe si xmit 1 xmitfilter /harpe/level As a result, we will receive: T2: /harpe/hand f 0.1 T2: /harpe/hand f 0.25 T2: /harpe/hand f 0.44 T2: /harpe/hand f 0.78 To reset the filter, send: T1$ oscsend localhost 5510 /harpe si xmit 1 xmitfilter Using OSC Aliases Aliases are a convenient mechanism to control a Faust application from a preexisting set of OSC messages. Let's say we want to control our previous noise example with TouchOSC on Android. The first step is to configure the TouchOSC host to 192.168.1.102 (the host running our noise application) and outgoing port to 5510 . Then we can use oscdump 5510 (after quitting the noise application in order to free port 5510 ) to visualize the OSC messages sent by TouchOSC. Let's use for that the left slider of \"simple layout\". Here is what we get: T2: /1/fader1 f 0.000000 T2: /1/fader1 f 0.004975 T2: /1/fader1 f 0.004975 T2: /1/fader1 f 0.008125 T2: /1/fader1 f 0.017473 T2: /1/fader1 f 0.032499 T2: /1/fader1 f 0.051032 T2: ... T2: /1/fader1 f 0.993289 T2: /1/fader1 f 1.000000 We can associate this OSC message to the noise level slider by inserting the metadata [osc:/1/fader1 0 1] into the slider's label: Several osc aliases can be inserted into a single label allowing the same widget to be controlled by several OSC messages import( stdfaust.lib ); process = no.noise*hslider( level[osc:/1/fader1 0 1] ,0,0,1,0.01); Because the range of /1/fader1 is 0 to 1 (like the level slider), we can remove the range mapping information and write simply : import( stdfaust.lib ); process = no.noise*hslider( level[osc:/1/fader1] ,0,0,1,0.01); TouchOSC can also send accelerometer data by enabling Settings/Options/Accelerometer . Using again oscdump 5510 we can visualize the messages sent by TouchOSC: T2: ... T2: /accxyz fff -0.147842 0.019752 9.694721 T2: /accxyz fff -0.157419 0.016161 9.686341 T2: /accxyz fff -0.167594 0.012570 9.683948 T2: ... As we can see, TouchOSC sends the x, y and z accelerometers in a single message, as a triplet of values ranging approximately from -9.81 to 9.81. In order to select the appropriate accelerometer, we need to concatenate to /accxyz a suffix /0 , /1 or /2 . For example /accxyz/0 will correspond to x, /accxyz/1 to y, etc. We also need to define a mapping because the ranges are different: import( stdfaust.lib ); process = no.noise * hslider( level[osc:/accxyz/0 0 9.81] ,0,0,1,0.01); alias description [osc:/1/rotary1 0 1] top left rotary knob [osc:/1/rotary2 0 1] middle left rotary knob [osc:/1/rotary3 0 1] bottom left rotary knob [osc:/1/push1 0 1] bottom left push button [osc:/1/push2 0 1] bottom center left push button [osc:/1/toggle1 0 1] top center left toggle button [osc:/1/toggle2 0 1] middle center left toggle button [osc:/1/fader1 0 1] center left vertical fader [osc:/1/toggle3 0 1] top center right toggle button [osc:/1/toggle4 0 1] middle center right toggle button [osc:/1/fader2 0 1] center right vertical toggle button [osc:/1/rotary4 0 1] top right rotary knob [osc:/1/rotary5 0 1] middle right rotary knob [osc:/1/rotary6 0 1] bottom right rotary knob [osc:/1/push3 0 1] bottom center right push button [osc:/1/push4 0 1] bottom right push button [osc:/1/fader3 0 1] bottom horizontal fader [osc:/accxyz/0 -10 10] \\(x\\) accelerometer [osc:/accxyz/1 -10 10] \\(y\\) accelerometer [osc:/accxyz/2 -10 10] \\(z\\) accelerometer **_Examples of OSC Message Aliases for TouchOSC (Layout Mix2)._** OSC Cheat Sheet Default Ports Port Description 5510 default listening port 5511 default transmission port 5512 default error port 5513 alternative listening ports Command Line Options Option Description -port n set the port number used by the application to receive messages -outport n set the port number used by the application to transmit messages -errport n set the port number used by the application to transmit error messages -desthost h set the destination host for the messages sent by the application -xmit 0|1|2 turn transmission OFF, ALL or ALIAS (default OFF) -xmitfilter s filter the Faust paths at emission time Discovery Messages Message Description oscsend host port \"/*\" s hello discover if any OSC application is listening on port p oscsend host port \"/*\" s get query OSC interface of application listening on port p Control Messages Message Description oscsend host port \"/*\" si xmit 0|1|2 set transmission mode oscsend host port widget s get get widget's value oscsend host port widget f v set widget's value Alias Alias Description \"...[osc: address lo hi ]...\" alias with \\(lo \\rightarrow min\\) , \\(hi \\rightarrow max\\) mapping \"...[osc:' address]...\" alias with min , max clipping","title":"OSC Support"},{"location":"guide/osc/#osc-support","text":"","title":"OSC Support"},{"location":"guide/osc/#overview","text":"Most Faust architectures provide Open Sound Control (OSC) support (the implementation is based internally on the oscpack library by Ross Bencina). This allows applications to be remotely controlled from any OSC-capable application, programming language, or hardware device. OSC support can be added to any Faust program (as long as the target architecture supports it: see tables below) simply by adding the [osc:on] metadata to the standard option metadata : declare options [osc:on] ; The following tables provides a list of Faust architectures providing OSC support. Audio System Environment Alsa GTK, Qt, Console Jack GTK, Qt, Console Netjack GTK, Qt, Console PortAudio GTK, Qt **_Linux Faust Architectures with OSC Support_** Audio System Environment CoreAudio Qt Jack Qt, Console Netjack Qt, Console PortAudio Qt **_OSX Faust Architectures with OSC Support_** Audio System Environment Jack Qt, Console PortAudio Qt **_Windows Faust Architectures with OSC Support_** Environment Android iOS JUCE Bela **_Other Faust Architectures with OSC Support_**","title":"Overview"},{"location":"guide/osc/#simple-example","text":"To illustrate how OSC support works let's define a very simple noise generator with a level control (we'll call it noise.dsp ): import( stdfaust.lib ); process = no.noise*hslider( level ,0,0,1,0.01); Try it Yourself >> This example can be compiled as a standalone Jack Qt application with OSC support simply by running the following command: faust2jaqt -osc noise.dsp When the generated application is ran from the command line: ./noise various information is printed in the standard output, including: Faust OSC version 0.93 application 'noise' is running on UDP ports 5510, 5511, 5512 Hence, the OSC module makes use of three different UDP ports: 5510 is the listening port number: control messages should be addressed to this port. 5511 is the output port number: control messages sent by the application and answers to query messages are sent to this port. 5512 is the error port number: used for asynchronous error notifications. These OSC parameters can be changed from the command line using one of the following options: -port number sets the port number used by the application to receive messages. -outport number sets the port number used by the application to transmit messages. -errport number sets the port number used by the application to transmit error messages. -desthost host sets the destination host for the messages sent by the application. -xmit 0|1|2 turns transmission OFF, ALL, or ALIAS (default OFF). When transmission is OFF, input elements can be controlled using their addresses or aliases (if present). When transmission is ALL, input elements can be controlled using their addresses or aliases (if present), user's actions and output elements (i.e., bargraph , etc.) are transmitted as OSC messages as well as aliases (if present). When transmission is ALIAS, input elements can only be controlled using their aliases, user's actions and output elements are transmitted as aliases only. -xmitfilter path allows to filter output messages. Note that path can be a regular expression (like /freeverb/Reverb1/* ). For example: ./noise -xmit 1 -desthost 192.168.1.104 -outport 6000 will run noise with transmission mode ON, using 192.168.1.104 on port 6000 as destination.","title":"Simple Example"},{"location":"guide/osc/#automatic-port-allocation","text":"In order to address each application individually, only one application can be listening on a single port at one time. Therefore when the default incoming port 5510 is already opened by some other application, an application will automatically try increasing port numbers until it finds an available port. Let say that we start noise and mixer (two Faust-generated applications with OSC support) on the same machine, we'll get the following: $ ./noise ... Faust OSC version 0.93 application 'noise' is running on UDP ports 5510, 5511, 5512 $ ./mixer ... Faust OSC version 0.93 application 'mixer' is running on UDP ports 5513, 5511, 5512 The mixer application fails to open the default incoming port 5510 because it is already opened by noise . Therefore it tries to find an available port starting from 5513 and opens it. Please note that the two outcoming ports 5511 and 5512 are shared by all running applications.","title":"Automatic Port Allocation"},{"location":"guide/osc/#discovering-osc-applications","text":"The commands oscsend and oscdump from the liblo package provide a convenient mean to experiment with OSC control and potentially debug applications with OSC support. oscsend [hostname] [port] [address] [types] [values] : sends OSC messages via UDP. [types] is a string, the letters indicates the type of the following values: i=integer , f=float , s=string , etc. oscdump [port] : receives OSC messages via UDP and dump to standard output Note that OSC messages can be sent from any OSC-compatible applications (e.g., PureData, Max/MSP, etc.). In the following examples, we'll use two separate terminal windows. The first one will be used to send OSC messages to the noise application using oscsend . The second terminal will be used to monitor the messages sent by the application using oscdump . Commands executed on terminal 1 will be preceded by T1$ . Messages received on terminal 2 will be preceded by T2: . To monitor on terminal T2 the OSC messages received on UDP port 5511, oscdump will be used: T2$ oscdump 5511 Once set we can use the hello message to scan UDP ports for Faust applications. For example: T1$ oscsend localhost 5510 /* s hello gives us the root message address, the network and the UDP ports used by the noise application: T2: /noise siii 192.168.1.102 5510 5511 5512","title":"Discovering OSC Applications"},{"location":"guide/osc/#discovering-the-osc-interface-of-an-application","text":"The OSC interface of an application (the set of OSC messages we can use to control it) can be discovered by sending the get message to the root: T1$ oscsend localhost 5510 /noise s get As an answer to this OSC message, a full description is printed in terminal T2: T2: /noise sF xmit #F T2: /noise ss desthost 127.0.0.1 T2: /noise si outport 5511 T2: /noise si errport 5512 T2: /noise/level fff 0.000000 0.000000 1.000000 The root of the OSC interface is /noise . Transmission is OFF, xmit is set to false. The destination host for sending messages is 127.0.0.1 , the output port is 5511 and the error port is 5512 . The application has only one user interface element: /noise/level with current value 0.0 , minimal value 0.0 and maximal value 1.0 .","title":"Discovering the OSC Interface of an Application"},{"location":"guide/osc/#widgets-osc-address","text":"Each widget of an application has a unique OSC address obtained by concatenating the labels of it's surrounding groups with its own label. There are potential conflicts between widget's labels and the OSC address space. An OSC symbolic name is an ASCII string consisting of a restricted set of printable characters. Therefore to ensure compatibility spaces are replaced by underscores and some other characters (asterisk, comma, forward, question mark, open bracket, close bracket, open curly brace, close curly brace) are replaced by hyphens. Here is as an example mix4.dsp , a very simplified monophonic audio mixer with 4 inputs and one output. For each input we have a mute button and a level slider: input(v) = vgroup( input %v , *(1-checkbox( mute )) : *(vslider( level , 0, 0, 1, 0.01))); process = hgroup( mixer , par(i, 4, input(i)) : _); Try it Yourself >> If we query this application: T1$ oscsend localhost 5510 /* s get We get a full description of its OSC interface on terminal T2: T2: /mixer sF xmit #F T2: /mixer ss desthost 127.0.0.1 T2: /mixer si outport 5511 T2: /mixer si errport 5512 T2: /mixer/input_0/level fff 0.0000 0.0000 1.0000 T2: /mixer/input_0/mute fff 0.0000 0.0000 1.0000 T2: /mixer/input_1/level fff 0.0000 0.0000 1.0000 T2: /mixer/input_1/mute fff 0.0000 0.0000 1.0000 T2: /mixer/input_2/level fff 0.0000 0.0000 1.0000 T2: /mixer/input_2/mute fff 0.0000 0.0000 1.0000 T2: /mixer/input_3/level fff 0.0000 0.0000 1.0000 T2: /mixer/input_3/mute fff 0.0000 0.0000 1.0000 As we can see, each widget has a unique OSC address obtained by concatenating the top level group label \"mixer,\" with the \"input\" group label and the widget label (see the Labels as Pathnames Section ). Please, note that blank spaces are replaced by underscores and metadata are removed during this operation. All addresses must have a common root. This is the case in our example because there is a unique horizontal group mixer containing all widgets. If a common root is missing as in the following code: input(v) = vgroup( input %v , *(1-checkbox( mute )) : *(vslider( level , 0, 0, 1, 0.01))); process = par(i, 4, input(i)) : _; then a default vertical group is automatically create by the Faust compiler using the name of the file mix4 as label: T2: /mix4 sF xmit #F T2: /mix4 ss desthost 127.0.0.1 T2: /mix4 si outport 5511 T2: /mix4 si errport 5512 T2: /mix4/input_0/level fff 0.0000 0.0000 1.0000 T2: /mix4/input_0/mute fff 0.0000 0.0000 1.0000 T2: /mix4/input_1/level fff 0.0000 0.0000 1.0000 T2: /mix4/input_1/mute fff 0.0000 0.0000 1.0000 T2: /mix4/input_2/level fff 0.0000 0.0000 1.0000 T2: /mix4/input_2/mute fff 0.0000 0.0000 1.0000 T2: /mix4/input_3/level fff 0.0000 0.0000 1.0000 T2: /mix4/input_3/mute fff 0.0000 0.0000 1.0000","title":"Widget's OSC Address"},{"location":"guide/osc/#controlling-the-application-via-osc","text":"Any user interface element of the application can be controlled by sending one of the previously discovered messages/addresses. For example, to set the noise level of the application to 0.2 the following message can be sent: T1$ oscsend localhost 5510 /noise/level f 0.2 If we now query /noise/level we get, as expected, the value 0.2 : T1$ oscsend localhost 5510 /noise/level s get T2: /noise/level fff 0.2000 0.0000 1.0000","title":"Controlling the Application Via OSC"},{"location":"guide/osc/#turning-transmission-on","text":"The xmit message at the root level is used to control the realtime transmission of OSC messages corresponding to user interface's actions. For example: T1$ oscsend localhost 5510 /noise si xmit 1 turns transmission in ALL mode. Now if we move the level slider we get a bunch of messages: T2: /noise/level f 0.024000 T2: /noise/level f 0.032000 T2: /noise/level f 0.105000 T2: /noise/level f 0.250000 T2: /noise/level f 0.258000 T2: /noise/level f 0.185000 T2: /noise/level f 0.145000 T2: /noise/level f 0.121000 T2: /noise/level f 0.105000 T2: /noise/level f 0.008000 T2: /noise/level f 0.000000 This feature can be typically used for automation to record and replay actions on the user interface, or to remote control from one application to another. It can be turned OFF any time using: T1$ oscsend localhost 5510 /noise si xmit 0 Use the ALIAS ( xmit = 2 ) mode if you need to restrict the access to your program: when the ALIAS mode is used, only aliases of input elements (sliders, buttons...) can be used to control them, and output elements (bargraph) will only emit on their aliases.","title":"Turning Transmission ON"},{"location":"guide/osc/#filtering-osc-messages","text":"When the transmission of OSC messages is ON, all the user interface elements are sent through the OSC connection. T2: /harpe/level f 0.024000 T2: /harpe/hand f 0.1 T2: /harpe/level f 0.024000 T2: /harpe/hand f 0.25 T2: /harpe/level f 0.024000 T2: /harpe/hand f 0.44 T2: /noise/level f 0.145000 T2: /harpe/hand f 0.78 T2: /noise/level f 0.145000 T2: /harpe/hand f 0.99 We can choose to filter unwanted parameters (or group of parameters). For example: T1$ oscsend localhost 5510 /harpe si xmit 1 xmitfilter /harpe/level As a result, we will receive: T2: /harpe/hand f 0.1 T2: /harpe/hand f 0.25 T2: /harpe/hand f 0.44 T2: /harpe/hand f 0.78 To reset the filter, send: T1$ oscsend localhost 5510 /harpe si xmit 1 xmitfilter","title":"Filtering OSC Messages"},{"location":"guide/osc/#using-osc-aliases","text":"Aliases are a convenient mechanism to control a Faust application from a preexisting set of OSC messages. Let's say we want to control our previous noise example with TouchOSC on Android. The first step is to configure the TouchOSC host to 192.168.1.102 (the host running our noise application) and outgoing port to 5510 . Then we can use oscdump 5510 (after quitting the noise application in order to free port 5510 ) to visualize the OSC messages sent by TouchOSC. Let's use for that the left slider of \"simple layout\". Here is what we get: T2: /1/fader1 f 0.000000 T2: /1/fader1 f 0.004975 T2: /1/fader1 f 0.004975 T2: /1/fader1 f 0.008125 T2: /1/fader1 f 0.017473 T2: /1/fader1 f 0.032499 T2: /1/fader1 f 0.051032 T2: ... T2: /1/fader1 f 0.993289 T2: /1/fader1 f 1.000000 We can associate this OSC message to the noise level slider by inserting the metadata [osc:/1/fader1 0 1] into the slider's label: Several osc aliases can be inserted into a single label allowing the same widget to be controlled by several OSC messages import( stdfaust.lib ); process = no.noise*hslider( level[osc:/1/fader1 0 1] ,0,0,1,0.01); Because the range of /1/fader1 is 0 to 1 (like the level slider), we can remove the range mapping information and write simply : import( stdfaust.lib ); process = no.noise*hslider( level[osc:/1/fader1] ,0,0,1,0.01); TouchOSC can also send accelerometer data by enabling Settings/Options/Accelerometer . Using again oscdump 5510 we can visualize the messages sent by TouchOSC: T2: ... T2: /accxyz fff -0.147842 0.019752 9.694721 T2: /accxyz fff -0.157419 0.016161 9.686341 T2: /accxyz fff -0.167594 0.012570 9.683948 T2: ... As we can see, TouchOSC sends the x, y and z accelerometers in a single message, as a triplet of values ranging approximately from -9.81 to 9.81. In order to select the appropriate accelerometer, we need to concatenate to /accxyz a suffix /0 , /1 or /2 . For example /accxyz/0 will correspond to x, /accxyz/1 to y, etc. We also need to define a mapping because the ranges are different: import( stdfaust.lib ); process = no.noise * hslider( level[osc:/accxyz/0 0 9.81] ,0,0,1,0.01); alias description [osc:/1/rotary1 0 1] top left rotary knob [osc:/1/rotary2 0 1] middle left rotary knob [osc:/1/rotary3 0 1] bottom left rotary knob [osc:/1/push1 0 1] bottom left push button [osc:/1/push2 0 1] bottom center left push button [osc:/1/toggle1 0 1] top center left toggle button [osc:/1/toggle2 0 1] middle center left toggle button [osc:/1/fader1 0 1] center left vertical fader [osc:/1/toggle3 0 1] top center right toggle button [osc:/1/toggle4 0 1] middle center right toggle button [osc:/1/fader2 0 1] center right vertical toggle button [osc:/1/rotary4 0 1] top right rotary knob [osc:/1/rotary5 0 1] middle right rotary knob [osc:/1/rotary6 0 1] bottom right rotary knob [osc:/1/push3 0 1] bottom center right push button [osc:/1/push4 0 1] bottom right push button [osc:/1/fader3 0 1] bottom horizontal fader [osc:/accxyz/0 -10 10] \\(x\\) accelerometer [osc:/accxyz/1 -10 10] \\(y\\) accelerometer [osc:/accxyz/2 -10 10] \\(z\\) accelerometer **_Examples of OSC Message Aliases for TouchOSC (Layout Mix2)._**","title":"Using OSC Aliases"},{"location":"guide/osc/#osc-cheat-sheet","text":"","title":"OSC Cheat Sheet"},{"location":"guide/osc/#default-ports","text":"Port Description 5510 default listening port 5511 default transmission port 5512 default error port 5513 alternative listening ports","title":"Default Ports"},{"location":"guide/osc/#command-line-options","text":"Option Description -port n set the port number used by the application to receive messages -outport n set the port number used by the application to transmit messages -errport n set the port number used by the application to transmit error messages -desthost h set the destination host for the messages sent by the application -xmit 0|1|2 turn transmission OFF, ALL or ALIAS (default OFF) -xmitfilter s filter the Faust paths at emission time","title":"Command Line Options"},{"location":"guide/osc/#discovery-messages","text":"Message Description oscsend host port \"/*\" s hello discover if any OSC application is listening on port p oscsend host port \"/*\" s get query OSC interface of application listening on port p","title":"Discovery Messages"},{"location":"guide/osc/#control-messages","text":"Message Description oscsend host port \"/*\" si xmit 0|1|2 set transmission mode oscsend host port widget s get get widget's value oscsend host port widget f v set widget's value","title":"Control Messages"},{"location":"guide/osc/#alias","text":"Alias Description \"...[osc: address lo hi ]...\" alias with \\(lo \\rightarrow min\\) , \\(hi \\rightarrow max\\) mapping \"...[osc:' address]...\" alias with min , max clipping","title":"Alias"},{"location":"guide/overview/","text":"Overview of the Faust Universe While in its most primitive form, Faust is distributed as a command-line compiler, a wide range of tools have been developed around it in the course of the past few years. Their variety and their function might be hard to grab at first. This chapter provides an overview of their role and will hopefully help you decide which one is better suited for your personal use. The Faust Distribution The Faust distribution hosts the source of the Faust compiler (both in its command line and library version), the source of the Faust architectures (targets), the various Faust compilation scripts, a wide range of Faust-related-tools, the Faust DSP Libraries (which in practice are hosted a separate Git submodule), etc. The latest stable release of the Faust distribution can be found here . It is recommended for most Faust users willing to compile the Faust compiler and libfaust from scratch. To have the latest stable development version, you can use the master branch of the Faust git repository which is hosted on GitHub: For something even more bleeding edge (to be used at your own risks), you might use the master-dev branch of the Faust git repository . master-dev is the development sub-branch of master . It is used by Faust developers to commit their changes and can be considered as \"the main development branch\". The goal is to make sure that master is always functional. Merges between master-dev and master are carried out multiple times a week by the GRAME team. Also, note that pre-compiled packages of the Faust compiler and of libfaust for various platforms can be found on the of the Faust website . The Faust distribution is organized as follows: bin/ : contains the compiler and the [Faust tools](../refs/tools) include/ : contains header files required by the Faust tools lib/ : contains the Faust libraries share/ : conatins documentation, the Faust libraries and architecture files Note : you can install the Faust distribution anywhere you want, provided that the faust command is available from your PATH (requires to update your .profile if not in a standard location). The following subsections present the main tools build on top of the Faust compiler and intended to facilitate your life. FaustLive FaustLive is an advanced self-contained prototyping environment for the Faust programming language with an ultra-short edit-compile-run cycle. Thanks to its fully embedded compilation chain, FaustLive is simple to install and doesn't require any external compiler, development toolchain or SDK to run. FaustLive is the ideal tool for fast prototyping. Faust programs can be compiled and run on the fly by simple drag and drop. They can even be edited and recompiled while running, without sound interruption. It supports also native applications generation using the Faust online compiler. Faustgen Faustgen is a Max-MSP external that provides features similar to FaustLive. It's the ideal tool for fast prototyping in Max-MSP. Faustgen is part of the Faust project. It is part of the Faust releases . Online Faust Editor The Online Faust Editor is a zero-conf tool that provides all the compilation services, including binaries generation for all the supported platforms and architectures. Online Faust IDE The Online Faust IDE is a zero-conf tool that provides all the compilation services, including binaries generation for all the supported platforms and architectures, but also various utilities for signal processing development. Faust Playground Faust Playground is a graphical environment to develop Faust programs with a higher level approach. It has been initially designed for kids and for pedagogical purpose.","title":"Overview"},{"location":"guide/overview/#overview-of-the-faust-universe","text":"While in its most primitive form, Faust is distributed as a command-line compiler, a wide range of tools have been developed around it in the course of the past few years. Their variety and their function might be hard to grab at first. This chapter provides an overview of their role and will hopefully help you decide which one is better suited for your personal use.","title":"Overview of the Faust Universe"},{"location":"guide/overview/#the-faust-distribution","text":"The Faust distribution hosts the source of the Faust compiler (both in its command line and library version), the source of the Faust architectures (targets), the various Faust compilation scripts, a wide range of Faust-related-tools, the Faust DSP Libraries (which in practice are hosted a separate Git submodule), etc. The latest stable release of the Faust distribution can be found here . It is recommended for most Faust users willing to compile the Faust compiler and libfaust from scratch. To have the latest stable development version, you can use the master branch of the Faust git repository which is hosted on GitHub: For something even more bleeding edge (to be used at your own risks), you might use the master-dev branch of the Faust git repository . master-dev is the development sub-branch of master . It is used by Faust developers to commit their changes and can be considered as \"the main development branch\". The goal is to make sure that master is always functional. Merges between master-dev and master are carried out multiple times a week by the GRAME team. Also, note that pre-compiled packages of the Faust compiler and of libfaust for various platforms can be found on the of the Faust website . The Faust distribution is organized as follows: bin/ : contains the compiler and the [Faust tools](../refs/tools) include/ : contains header files required by the Faust tools lib/ : contains the Faust libraries share/ : conatins documentation, the Faust libraries and architecture files Note : you can install the Faust distribution anywhere you want, provided that the faust command is available from your PATH (requires to update your .profile if not in a standard location). The following subsections present the main tools build on top of the Faust compiler and intended to facilitate your life.","title":"The Faust Distribution"},{"location":"guide/overview/#faustlive","text":"FaustLive is an advanced self-contained prototyping environment for the Faust programming language with an ultra-short edit-compile-run cycle. Thanks to its fully embedded compilation chain, FaustLive is simple to install and doesn't require any external compiler, development toolchain or SDK to run. FaustLive is the ideal tool for fast prototyping. Faust programs can be compiled and run on the fly by simple drag and drop. They can even be edited and recompiled while running, without sound interruption. It supports also native applications generation using the Faust online compiler.","title":"FaustLive"},{"location":"guide/overview/#faustgen","text":"Faustgen is a Max-MSP external that provides features similar to FaustLive. It's the ideal tool for fast prototyping in Max-MSP. Faustgen is part of the Faust project. It is part of the Faust releases .","title":"Faustgen"},{"location":"guide/overview/#online-faust-editor","text":"The Online Faust Editor is a zero-conf tool that provides all the compilation services, including binaries generation for all the supported platforms and architectures.","title":"Online Faust Editor"},{"location":"guide/overview/#online-faust-ide","text":"The Online Faust IDE is a zero-conf tool that provides all the compilation services, including binaries generation for all the supported platforms and architectures, but also various utilities for signal processing development.","title":"Online Faust IDE"},{"location":"guide/overview/#faust-playground","text":"Faust Playground is a graphical environment to develop Faust programs with a higher level approach. It has been initially designed for kids and for pedagogical purpose.","title":"Faust Playground"},{"location":"guide/quick-start/","text":"Quick Start The goal of this section is to teach you how to use the basic elements of the Faust programming language in approximately two hours! While DSP algorithms can be easily written from scratch in Faust, we'll just show you here how to use existing elements implemented in the Faust libraries , connect them to each other, and implement basic user interfaces (UI) to control them. One of the strength of Faust lies in its libraries that implement hundreds of functions. So you should be able to go a long way after reading this section, simply by using what's already out here. This tutorial was written assuming that the reader is already familiar with basic concepts of computer music and programming. More generally, at the end of this section: your Faust development environment should be up and running, you should know enough to write basic Faust programs, you should be able to use them on different platforms. This tutorial was designed to be carried out in the Faust online editor . If you wish to do it locally, you'll have to install Faust on your system but this step is absolutely not required, Making Sound Write the following code in the Faust online editor : import( stdfaust.lib ); process = no.noise; Try it Yourself >> and then click on the \"run\" button on the top left corner. Alternatively, you can also click on the \"Try it Yourself\" button of the window above if you're reading the online version of this documentation. You should now hear white noise, of course... ;) stdfaust.lib gives access to all the Faust libraries from a single point through a series of environments. For instance, we're using here the no environment which stands for noise.lib and the noise function (which is the standard white noise generator of Faust). The Faust libraries documentation provides more details about this system. The most fundamental element of any Faust code is the process line, which gives access to the audio inputs and outputs of the target. This system is completely dynamic and since no.noise has only one output and no input, the corresponding program will have a single output. Let's statically change the gain of the output of no.noise simply by multiplying it by a number between 0 and 1: process = no.noise*0.5; Thus, standard mathematical operations can be used in Faust just like in any other language. We'll now connect the noise generator to a resonant lowpass filter ( fi.resonlp ) by using the Faust sequential composition operator : : import( stdfaust.lib ); ctFreq = 500; q = 5; gain = 1; process = no.noise : fi.resonlp(ctFreq,q,gain); Try it Yourself >> fi.resonlp has four arguments (in order): cut-off frequency , q , gain and its input . Here, we're setting the first three arguments with fixed variables. Variables don't have a type in Faust and everything is considered as a signal. The Faust compiler takes care of making the right optimizations by choosing which variable is ran at audio rate, what their types are, etc. Thus, ctFreq , q and gain could well be controlled by oscillators (i.e., signals running at audio rate) here. Since the input of the filter is not specified as an argument here (but it could, of course), it automatically becomes an \"implicit\" input/argument of fi.resonlp . The : sequential composition operator can be used to connect two elements that have the same number of outputs and inputs. Since no.noise has one output and fi.resonlp(ctFreq,q,gain) has one implicit input, we can connect them together. This is essentially the same as writing something like: import( stdfaust.lib ); ctFreq = 500; q = 5; gain = 1; process = fi.resonlp(ctFreq,q,gain,no.noise); Try it Yourself >> While this would work, it's kind of ugly and not very \"Faustian\", so we don't do it... ;) At this point, you should be able to use and plug various elements of the Faust libraries together. The Faust libraries implement hundreds of functions and some of them have a very specialized use. Fortunately, the Faust libraries documentation contains a section on Standard Faust Libraries listing all the high level \"standard\" Faust functions organized by types. We recommend you to have a look at it now . As you do this, be aware that implicit signals in Faust can be explicitly represented with the _ character. Thus, when you see something like this in the libraries documentation: _ : aFunction(a,b) : _ it means that this function has one implicit input, one implicit output and two parameters ( a and b ). On the other hand: anotherFunction(a,b,c) : _,_ is a function that has three parameters, no implicit input and two outputs. Just for \"fun,\" try to rewrite the previous example running in the Faust online editor so that the process line looks like this: import( stdfaust.lib ); ctFreq = 500; q = 5; gain = 1; process = no.noise : _ : fi.resonlp(ctFreq,q,gain) : _; Try it Yourself >> Of course, this should not affect the result. You probably noticed that we used the , Faust composition operator to express two signals in parallel . We can easily turn our filtered noise example into a stereo object using it: import( stdfaust.lib ); ctFreq = 500; q = 5; gain = 1; process = no.noise : _ : fi.resonlp(ctFreq,q,gain),fi.resonlp(ctFreq,q,gain); Try it Yourself >> or we could even write this in a cleaner way: import( stdfaust.lib ); ctFreq = 500; q = 5; gain = 1; filter = fi.resonlp(ctFreq,q,gain); process = no.noise : filter,filter; Try it Yourself >> Note that this example allows us to have 2 separate filters for each channel. Since both filters currently have the same parameters, another way of writing this could be: process = no.noise : filter : _,_; . Since filter,filter is considered here as a full expression, we cannot use the : operator to connect no.noise to the two filters in parallel because filter,filter has two inputs ( _,_ : filter,filter : _,_ ) and no.noise only has one output. The : split composition operator used here takes n signals and splits them into m signals. The only rule is that m has to be a multiple of n . The merge : composition operator can be used exactly the same way: import( stdfaust.lib ); process = no.noise : filter,filter : _; Here we split the signal of no.noise into two signals that are connected to two filters in parallel. Finally, we merge the outputs of the filters into one signal. Note, that the previous expression could have been written as such too: import( stdfaust.lib ); process = no.noise : filter+filter; Keep in mind that splitting a signal doesn't mean that its energy get spread in each copy, for example, in the expression: process = 1 : _,_; Try it Yourself >> the two _ both contain 1... All right, it's now time to add a basic user interface to our Faust program to make things a bit more interactive. Building a Simple User Interface In this section, we'll add a simple user interface to the code that we wrote in the previous section: import( stdfaust.lib ); ctFreq = 500; q = 5; gain = 1; process = no.noise : fi.resonlp(ctFreq,q,gain) ; Try it Yourself >> Faust allows us to declare basic user interface (UI) elements to control the parameters of a Faust object. Since Faust can be used to make a wide range of elements ranging from standalone applications to audio plug-ins or API, the role of UI declarations differs a little in function of the target. For example, in the Faust Online Editor, a UI is a window with various kind of controllers (sliders, buttons, etc.). On the other hand, if you're using Faust to generate an audio engine using faust2api , then UI elements declared in your Faust code will be the parameters visible to \"the rest of the world\" and controllable through the API. An exhaustive list of the standard Faust UI elements is given in the corresponding section . Be aware that they not all supported by all the Faust targets. For example, you wont be able to declare vertical sliders if you're using the Faust Playground , etc. In the current case, we'd like to control the ctFreq , q and gain parameters of the previous program with horizontal sliders. To do this, we can write something like: import( stdfaust.lib ); ctFreq = hslider( cutoffFrequency ,500,50,10000,0.01); q = hslider( q ,5,1,30,0.1); gain = hslider( gain ,1,0,1,0.01); process = no.noise : fi.resonlp(ctFreq,q,gain); Try it Yourself >> The first argument of hslider is the name of the parameter as it will be displayed in the interface or used in the API (it can be different from the name of the variable associated with the UI element), the next one is the default value , then the min and max values and finally the step . To summarize: hslider(\"paramName\",default,min,max,step) . Let's now add a \"gate\" button to start and stop the sound (where gate is just the name of the button): import( stdfaust.lib ); ctFreq = hslider( [0]cutoffFrequency ,500,50,10000,0.01); q = hslider( [1]q ,5,1,30,0.1); gain = hslider( [2]gain ,1,0,1,0.01); t = button( [3]gate ); process = no.noise : fi.resonlp(ctFreq,q,gain)*t; Try it Yourself >> Note that we were able to order parameters in the interface by numbering them in the parameter name field using squared brackets. Faust user interface elements run at control rate. Thus, you might have noticed that clicks are produced when moving sliders quickly. This problem can be easily solved by \"smoothing\" down the output of the sliders using the si.smoo function: import( stdfaust.lib ); ctFreq = hslider( [0]cutoffFrequency ,500,50,10000,0.01) : si.smoo; q = hslider( [1]q ,5,1,30,0.1) : si.smoo; gain = hslider( [2]gain ,1,0,1,0.01) : si.smoo; t = button( [3]gate ) : si.smoo; process = no.noise : fi.resonlp(ctFreq,q,gain)*t; Try it Yourself >> Note that we're also using si.smoo on the output of the gate button to apply a exponential envelope on its signal. This is a very broad introduction to making user interface elements in Faust. You can do much more like creating groups, using knobs, different types of menus, etc. but at least you should be able to make Faust programs at this point that are controllable and sound good (or not ;) ). Final Polishing Some Faust functions already contain a built-in UI and are ready-to-be-used. These functions are all placed in demo.lib and are accessible through the dm. environment. As an example, let's add a reverb to our previous code by calling dm.zita_light (high quality feedback delay network based reverb). Since this function has two implicit inputs, we also need to split the output of the filter (otherwise you will get an error because Faust wont know how to connect things): import( stdfaust.lib ); ctFreq = hslider( [0]cutoffFrequency ,500,50,10000,0.01) : si.smoo; q = hslider( [1]q ,5,1,30,0.1) : si.smoo; gain = hslider( [2]gain ,1,0,1,0.01) : si.smoo; t = button( [3]gate ) : si.smoo; process = no.noise : fi.resonlp(ctFreq,q,gain)*t : dm.zita_light; Try it Yourself >> Hopefully, you should see many more UI elements in your interface. That's it folks! At this point you should be able to use Faust standard functions , connect them together and build a simple UI at the top of them. Some Project Ideas In this section, we present a couple of project ideas that you could try to implement using Faust standard functions . Also, feel free to check the /examples folder of the Faust repository . Additive Synthesizer Make an additive synthesizer using os.osc (sine wave oscillator): import( stdfaust.lib ); // freqs and gains definitions go here process = os.osc(freq0)*gain0, os.osc(freq2)*gain2 : _ // merging signals here : dm.zita_light; // and then splitting them for stereo in FM Synthesizer Make a frequency modulation (FM) synthesizer using os.osc (sine wave oscillator): import( stdfaust.lib ); // carrierFreq, modulatorFreq and index definitions go here process = os.osc(carrierFreq+os.osc(modulatorFreq)*index) : dm.zita_light; // splitting signals for stereo in Guitar Effect Chain Make a guitar effect chain: import( stdfaust.lib ); process = dm.cubicnl_demo : // distortion dm.wah4_demo : // wah pedal dm.phaser2_demo : // stereo phaser dm.compressor_demo : // stereo compressor dm.zita_light; // stereo reverb Try it Yourself >> Since we're only using functions from demo.lib here, there's no need to define any UI since it is built-in in the functions that we're calling. Note that the mono output of dm.wah4_demo is split to fit the stereo input of dm.phaser2_demo . The last three effects have the same number of inputs and outputs (2x2) so no need to split or merge them. String Physical Model Based On a Comb Filter Make a string physical model based on a feedback comb filter: import( stdfaust.lib ); // freq, res and gate definitions go here string(frequency,resonance,trigger) = trigger : ba.impulsify : fi.fb_fcomb(1024,del,1,resonance) with { del = ma.SR/frequency; }; process = string(freq,res,gate); Sampling rate is defined in maths.lib as SR . We're using it here to compute the length of the delay of the comb filter. with{} is a Faust primitive to attach local variables to a function. So in the current case, del is a local variable of string . What to Do From Here? TODO.","title":"Quick start"},{"location":"guide/quick-start/#quick-start","text":"The goal of this section is to teach you how to use the basic elements of the Faust programming language in approximately two hours! While DSP algorithms can be easily written from scratch in Faust, we'll just show you here how to use existing elements implemented in the Faust libraries , connect them to each other, and implement basic user interfaces (UI) to control them. One of the strength of Faust lies in its libraries that implement hundreds of functions. So you should be able to go a long way after reading this section, simply by using what's already out here. This tutorial was written assuming that the reader is already familiar with basic concepts of computer music and programming. More generally, at the end of this section: your Faust development environment should be up and running, you should know enough to write basic Faust programs, you should be able to use them on different platforms. This tutorial was designed to be carried out in the Faust online editor . If you wish to do it locally, you'll have to install Faust on your system but this step is absolutely not required,","title":"Quick Start"},{"location":"guide/quick-start/#making-sound","text":"Write the following code in the Faust online editor : import( stdfaust.lib ); process = no.noise; Try it Yourself >> and then click on the \"run\" button on the top left corner. Alternatively, you can also click on the \"Try it Yourself\" button of the window above if you're reading the online version of this documentation. You should now hear white noise, of course... ;) stdfaust.lib gives access to all the Faust libraries from a single point through a series of environments. For instance, we're using here the no environment which stands for noise.lib and the noise function (which is the standard white noise generator of Faust). The Faust libraries documentation provides more details about this system. The most fundamental element of any Faust code is the process line, which gives access to the audio inputs and outputs of the target. This system is completely dynamic and since no.noise has only one output and no input, the corresponding program will have a single output. Let's statically change the gain of the output of no.noise simply by multiplying it by a number between 0 and 1: process = no.noise*0.5; Thus, standard mathematical operations can be used in Faust just like in any other language. We'll now connect the noise generator to a resonant lowpass filter ( fi.resonlp ) by using the Faust sequential composition operator : : import( stdfaust.lib ); ctFreq = 500; q = 5; gain = 1; process = no.noise : fi.resonlp(ctFreq,q,gain); Try it Yourself >> fi.resonlp has four arguments (in order): cut-off frequency , q , gain and its input . Here, we're setting the first three arguments with fixed variables. Variables don't have a type in Faust and everything is considered as a signal. The Faust compiler takes care of making the right optimizations by choosing which variable is ran at audio rate, what their types are, etc. Thus, ctFreq , q and gain could well be controlled by oscillators (i.e., signals running at audio rate) here. Since the input of the filter is not specified as an argument here (but it could, of course), it automatically becomes an \"implicit\" input/argument of fi.resonlp . The : sequential composition operator can be used to connect two elements that have the same number of outputs and inputs. Since no.noise has one output and fi.resonlp(ctFreq,q,gain) has one implicit input, we can connect them together. This is essentially the same as writing something like: import( stdfaust.lib ); ctFreq = 500; q = 5; gain = 1; process = fi.resonlp(ctFreq,q,gain,no.noise); Try it Yourself >> While this would work, it's kind of ugly and not very \"Faustian\", so we don't do it... ;) At this point, you should be able to use and plug various elements of the Faust libraries together. The Faust libraries implement hundreds of functions and some of them have a very specialized use. Fortunately, the Faust libraries documentation contains a section on Standard Faust Libraries listing all the high level \"standard\" Faust functions organized by types. We recommend you to have a look at it now . As you do this, be aware that implicit signals in Faust can be explicitly represented with the _ character. Thus, when you see something like this in the libraries documentation: _ : aFunction(a,b) : _ it means that this function has one implicit input, one implicit output and two parameters ( a and b ). On the other hand: anotherFunction(a,b,c) : _,_ is a function that has three parameters, no implicit input and two outputs. Just for \"fun,\" try to rewrite the previous example running in the Faust online editor so that the process line looks like this: import( stdfaust.lib ); ctFreq = 500; q = 5; gain = 1; process = no.noise : _ : fi.resonlp(ctFreq,q,gain) : _; Try it Yourself >> Of course, this should not affect the result. You probably noticed that we used the , Faust composition operator to express two signals in parallel . We can easily turn our filtered noise example into a stereo object using it: import( stdfaust.lib ); ctFreq = 500; q = 5; gain = 1; process = no.noise : _ : fi.resonlp(ctFreq,q,gain),fi.resonlp(ctFreq,q,gain); Try it Yourself >> or we could even write this in a cleaner way: import( stdfaust.lib ); ctFreq = 500; q = 5; gain = 1; filter = fi.resonlp(ctFreq,q,gain); process = no.noise : filter,filter; Try it Yourself >> Note that this example allows us to have 2 separate filters for each channel. Since both filters currently have the same parameters, another way of writing this could be: process = no.noise : filter : _,_; . Since filter,filter is considered here as a full expression, we cannot use the : operator to connect no.noise to the two filters in parallel because filter,filter has two inputs ( _,_ : filter,filter : _,_ ) and no.noise only has one output. The : split composition operator used here takes n signals and splits them into m signals. The only rule is that m has to be a multiple of n . The merge : composition operator can be used exactly the same way: import( stdfaust.lib ); process = no.noise : filter,filter : _; Here we split the signal of no.noise into two signals that are connected to two filters in parallel. Finally, we merge the outputs of the filters into one signal. Note, that the previous expression could have been written as such too: import( stdfaust.lib ); process = no.noise : filter+filter; Keep in mind that splitting a signal doesn't mean that its energy get spread in each copy, for example, in the expression: process = 1 : _,_; Try it Yourself >> the two _ both contain 1... All right, it's now time to add a basic user interface to our Faust program to make things a bit more interactive.","title":"Making Sound"},{"location":"guide/quick-start/#building-a-simple-user-interface","text":"In this section, we'll add a simple user interface to the code that we wrote in the previous section: import( stdfaust.lib ); ctFreq = 500; q = 5; gain = 1; process = no.noise : fi.resonlp(ctFreq,q,gain) ; Try it Yourself >> Faust allows us to declare basic user interface (UI) elements to control the parameters of a Faust object. Since Faust can be used to make a wide range of elements ranging from standalone applications to audio plug-ins or API, the role of UI declarations differs a little in function of the target. For example, in the Faust Online Editor, a UI is a window with various kind of controllers (sliders, buttons, etc.). On the other hand, if you're using Faust to generate an audio engine using faust2api , then UI elements declared in your Faust code will be the parameters visible to \"the rest of the world\" and controllable through the API. An exhaustive list of the standard Faust UI elements is given in the corresponding section . Be aware that they not all supported by all the Faust targets. For example, you wont be able to declare vertical sliders if you're using the Faust Playground , etc. In the current case, we'd like to control the ctFreq , q and gain parameters of the previous program with horizontal sliders. To do this, we can write something like: import( stdfaust.lib ); ctFreq = hslider( cutoffFrequency ,500,50,10000,0.01); q = hslider( q ,5,1,30,0.1); gain = hslider( gain ,1,0,1,0.01); process = no.noise : fi.resonlp(ctFreq,q,gain); Try it Yourself >> The first argument of hslider is the name of the parameter as it will be displayed in the interface or used in the API (it can be different from the name of the variable associated with the UI element), the next one is the default value , then the min and max values and finally the step . To summarize: hslider(\"paramName\",default,min,max,step) . Let's now add a \"gate\" button to start and stop the sound (where gate is just the name of the button): import( stdfaust.lib ); ctFreq = hslider( [0]cutoffFrequency ,500,50,10000,0.01); q = hslider( [1]q ,5,1,30,0.1); gain = hslider( [2]gain ,1,0,1,0.01); t = button( [3]gate ); process = no.noise : fi.resonlp(ctFreq,q,gain)*t; Try it Yourself >> Note that we were able to order parameters in the interface by numbering them in the parameter name field using squared brackets. Faust user interface elements run at control rate. Thus, you might have noticed that clicks are produced when moving sliders quickly. This problem can be easily solved by \"smoothing\" down the output of the sliders using the si.smoo function: import( stdfaust.lib ); ctFreq = hslider( [0]cutoffFrequency ,500,50,10000,0.01) : si.smoo; q = hslider( [1]q ,5,1,30,0.1) : si.smoo; gain = hslider( [2]gain ,1,0,1,0.01) : si.smoo; t = button( [3]gate ) : si.smoo; process = no.noise : fi.resonlp(ctFreq,q,gain)*t; Try it Yourself >> Note that we're also using si.smoo on the output of the gate button to apply a exponential envelope on its signal. This is a very broad introduction to making user interface elements in Faust. You can do much more like creating groups, using knobs, different types of menus, etc. but at least you should be able to make Faust programs at this point that are controllable and sound good (or not ;) ).","title":"Building a Simple User Interface"},{"location":"guide/quick-start/#final-polishing","text":"Some Faust functions already contain a built-in UI and are ready-to-be-used. These functions are all placed in demo.lib and are accessible through the dm. environment. As an example, let's add a reverb to our previous code by calling dm.zita_light (high quality feedback delay network based reverb). Since this function has two implicit inputs, we also need to split the output of the filter (otherwise you will get an error because Faust wont know how to connect things): import( stdfaust.lib ); ctFreq = hslider( [0]cutoffFrequency ,500,50,10000,0.01) : si.smoo; q = hslider( [1]q ,5,1,30,0.1) : si.smoo; gain = hslider( [2]gain ,1,0,1,0.01) : si.smoo; t = button( [3]gate ) : si.smoo; process = no.noise : fi.resonlp(ctFreq,q,gain)*t : dm.zita_light; Try it Yourself >> Hopefully, you should see many more UI elements in your interface. That's it folks! At this point you should be able to use Faust standard functions , connect them together and build a simple UI at the top of them.","title":"Final Polishing"},{"location":"guide/quick-start/#some-project-ideas","text":"In this section, we present a couple of project ideas that you could try to implement using Faust standard functions . Also, feel free to check the /examples folder of the Faust repository .","title":"Some Project Ideas"},{"location":"guide/quick-start/#additive-synthesizer","text":"Make an additive synthesizer using os.osc (sine wave oscillator): import( stdfaust.lib ); // freqs and gains definitions go here process = os.osc(freq0)*gain0, os.osc(freq2)*gain2 : _ // merging signals here : dm.zita_light; // and then splitting them for stereo in","title":"Additive Synthesizer"},{"location":"guide/quick-start/#fm-synthesizer","text":"Make a frequency modulation (FM) synthesizer using os.osc (sine wave oscillator): import( stdfaust.lib ); // carrierFreq, modulatorFreq and index definitions go here process = os.osc(carrierFreq+os.osc(modulatorFreq)*index) : dm.zita_light; // splitting signals for stereo in","title":"FM Synthesizer"},{"location":"guide/quick-start/#guitar-effect-chain","text":"Make a guitar effect chain: import( stdfaust.lib ); process = dm.cubicnl_demo : // distortion dm.wah4_demo : // wah pedal dm.phaser2_demo : // stereo phaser dm.compressor_demo : // stereo compressor dm.zita_light; // stereo reverb Try it Yourself >> Since we're only using functions from demo.lib here, there's no need to define any UI since it is built-in in the functions that we're calling. Note that the mono output of dm.wah4_demo is split to fit the stereo input of dm.phaser2_demo . The last three effects have the same number of inputs and outputs (2x2) so no need to split or merge them.","title":"Guitar Effect Chain"},{"location":"guide/quick-start/#string-physical-model-based-on-a-comb-filter","text":"Make a string physical model based on a feedback comb filter: import( stdfaust.lib ); // freq, res and gate definitions go here string(frequency,resonance,trigger) = trigger : ba.impulsify : fi.fb_fcomb(1024,del,1,resonance) with { del = ma.SR/frequency; }; process = string(freq,res,gate); Sampling rate is defined in maths.lib as SR . We're using it here to compute the length of the delay of the comb filter. with{} is a Faust primitive to attach local variables to a function. So in the current case, del is a local variable of string .","title":"String Physical Model Based On a Comb Filter"},{"location":"guide/quick-start/#what-to-do-from-here","text":"TODO.","title":"What to Do From Here?"},{"location":"refs/compiler/","text":"Using the Faust Compiler While the Faust compiler is available in different forms (e.g., Embedded Compiler , etc.), its most \"common\" one is the command line version, which can be invoked using the faust command. It translates a Faust program into code in a wide range of languages (C, O-C++, C++, Rust, JAVA, JavaScript, ASM JavaScript, LLVM, C-LLVM, FIR, and WebAssembly). The generated code can be wrapped into an optional architecture file allowing to directly produce a fully operational program. A typical call of the Faust command line compiler is: faust [OPTIONS] faustFile.dsp The Faust compiler outputs C++ code by default therefore running: faust noise.dsp will compile noise.dsp and output the corresponding C++ code on the standard output. The option -o allows to reroute the standard output to a file: faust noise.dsp -o noise.cpp The -a option allows us to wrap the generated code into an architecture file: faust -a alsa-gtk.cpp noise.dsp which can either be placed in the same folder as the current Faust file ( noise.dsp here) or be one of the standard Faust architectures. To compile a Faust program into an ALSA application on Linux, the following commands can be used: faust -a alsa-gtk.cpp noise.dsp -o noise.cpp g++ -lpthread -lasound `pkg-config --cflags --libs gtk+-2.0` noise.cpp -o noise Note that a wide range of faust2... compilation scripts can be used to facilitate this operation by taking a Faust file and returning the corresponding binary for your platform. Structure of the Generated Code A Faust DSP C++ class derives from the base dsp class defined as below (a similar structure is used for languages than C++): class dsp { public: dsp() {} virtual ~dsp() {} // Returns the number of inputs of the Faust program virtual int getNumInputs() = 0; // Returns the number of outputs of the Faust program virtual int getNumOutputs() = 0; // This method can be called to retrieve the UI description of // the Faust program and its associated fields virtual void buildUserInterface(UI* ui_interface) = 0; // Returns the current sampling rate virtual int getSampleRate() = 0; // Init methods virtual void init(int samplingRate) = 0; virtual void instanceInit(int samplingRate) = 0; virtual void instanceConstants(int samplingRate) = 0; virtual void instanceResetUserInterface() = 0; virtual void instanceClear() = 0; // Returns a clone of the instance virtual dsp* clone() = 0; // Retrieve the global metadata of the Faust program virtual void metadata(Meta* m) = 0; // Compute one audio frame virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) = 0; // Compute a time-stamped audio frame virtual void compute(double /*date_usec*/, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); } }; Methods are filled by the compiler with the actual code. In the case of noise.dsp : class mydsp : public dsp { private: int iRec0[2]; int fSamplingFreq; public: void metadata(Meta* m) { m- declare( author , GRAME ); m- declare( filename , noise ); m- declare( name , Noise ); m- declare( noises.lib/name , Faust Noise Generator Library ); m- declare( noises.lib/version , 0.0 ); } virtual int getNumInputs() { return 0; } virtual int getNumOutputs() { return 1; } virtual int getInputRate(int channel) { int rate; switch (channel) { default: { rate = -1; break; } } return rate; } virtual int getOutputRate(int channel) { int rate; switch (channel) { case 0: { rate = 1; break; } default: { rate = -1; break; } } return rate; } static void classInit(int samplingFreq) {} virtual void instanceConstants(int samplingFreq) { fSamplingFreq = samplingFreq; } virtual void instanceResetUserInterface() {} virtual void instanceClear() { for (int l0 = 0; (l0 2); l0 = (l0 + 1)) { iRec0[l0] = 0; } } virtual void init(int samplingFreq) { classInit(samplingFreq); instanceInit(samplingFreq); } virtual void instanceInit(int samplingFreq) { instanceConstants(samplingFreq); instanceResetUserInterface(); instanceClear(); } virtual mydsp* clone() { return new mydsp(); } virtual int getSampleRate() { return fSamplingFreq; } virtual void buildUserInterface(UI* ui_interface) { ui_interface- openVerticalBox( Noise ); ui_interface- closeBox(); } virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { FAUSTFLOAT* output0 = outputs[0]; for (int i = 0; (i count); i = (i + 1)) { iRec0[0] = ((1103515245 * iRec0[1]) + 12345); output0[i] = FAUSTFLOAT((4.65661287e-10f * float(iRec0[0]))); iRec0[1] = iRec0[0]; } } }; Several fine-grained initialization methods are available. The instanceInit method calls several additional initialization methods. The instanceConstants method sets the instance constant state. The instanceClear method resets the instance dynamic state (delay lines...). The instanceResetUserInterface method resets all control value to their default state. All of those methods can be used individually on an allocated instance to reset part of its state. The init method combines class static state and instance initialization. When using a single instance, calling init is the simplest way to do \"what is needed.\" When using several instances, all of them can be initialized using instanceInit , with a single call to classInit to initialize the static shared state. Controlling Code Generation Several options of the Faust compiler allow to control the generated C++ code. By default computation is done sample by sample in a single loop. But the compiler can also generate vector and parallel code. Vector Code Generation Modern C++ compilers are able to do autovectorization, that is to use SIMD instructions to speedup the code. These instructions can typically operate in parallel on short vectors of 4 simple precision floating point numbers, leading to a theoretical speedup of $\\times4$. Autovectorization of C/C++ programs is a difficult task. Current compilers are very sensitive to the way the code is arranged. In particular, complex loops can prevent autovectorization. The goal of the vector code generation is to rearrange the C++ code in a way that facilitates the autovectorization job of the C++ compiler. Instead of generating a single sample computation loop, it splits the computation into several simpler loops that communicates by vectors. The vector code generation is activated by passing the --vectorize (or -vec ) option to the Faust compiler. Two additional options are available: --vec-size n controls the size of the vector (by default 32 samples) and --loop-variant 0/1 gives some additional control on the loops. To illustrate the difference between scalar code and vector code, let's take the computation of the RMS (Root Mean Square) value of a signal. Here is the Faust code that computes the Root Mean Square of a sliding window of 1000 samples: // Root Mean Square of n consecutive samples RMS(n) = square : mean(n) : sqrt; // Square of a signal square(x) = x * x; // Mean of n consecutive samples of a signal (uses fixpoint to avoid the // accumulation of rounding errors) mean(n) = float2fix : integrate(n) : fix2float : /(n); // Sliding sum of n consecutive samples integrate(n,x) = x - x@n : +~_; // Convertion between float and fix point float2fix(x) = int(x*(1 20)); fix2float(x) = float(x)/(1 20); // Root Mean Square of 1000 consecutive samples process = RMS(1000); Try it Yourself >> The corresponding compute() method generated in scalar mode is the following: virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { FAUSTFLOAT* input0 = inputs[0]; FAUSTFLOAT* output0 = outputs[0]; for (int i = 0; (i count); i = (i + 1)) { int iTemp0 = int((1048576.0f * mydsp_faustpower2_f(float(input0[i])))); iVec0[(IOTA 1023)] = iTemp0; iRec0[0] = ((iRec0[1] + iTemp0) - iVec0[((IOTA - 1000) 1023)]); output0[i] = FAUSTFLOAT(std::sqrt((9.53674362e-10f * float(iRec0[0])))); IOTA = (IOTA + 1); iRec0[1] = iRec0[0]; } } The -vec option leads to the following reorganization of the code: virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { fInput0_ptr = inputs[0]; FAUSTFLOAT* fInput0 = 0; fOutput0_ptr = outputs[0]; FAUSTFLOAT* fOutput0 = 0; int iRec0_tmp[36]; int* iRec0 = iRec0_tmp[4]; int fullcount = count; int index = 0; /* Main loop */ for (index = 0; (index = (fullcount - 32)); index = (index + 32)) { fInput0 = fInput0_ptr[index]; fOutput0 = fOutput0_ptr[index]; int count = 32; /* Recursive loop 0 */ /* Pre code */ iYec0_idx = ((iYec0_idx + iYec0_idx_save) 2047); /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { iYec0[((i + iYec0_idx) 2047)] = int((1048576.0f mydsp_faustpower2_f(float(fInput0[i])))); } /* Post code */ iYec0_idx_save = count; /* Recursive loop 1 */ /* Pre code */ for (int j0 = 0; (j0 4); j0 = (j0 + 1)) { iRec0_tmp[j0] = iRec0_perm[j0]; } /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { iRec0[i] = ((iRec0[(i - 1)] + iYec0[((i + iYec0_idx) 2047)]) - iYec0[(((i + iYec0_idx) - 1000) 2047)]); } /* Post code */ for (int j = 0; (j 4); j = (j + 1)) { iRec0_perm[j] = iRec0_tmp[(count + j)]; } /* Vectorizable loop 2 */ /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fOutput0[i] = FAUSTFLOAT(std::sqrt((9.53674362e-10f * float(iRec0[i])))); } } /* Remaining frames */ if (index fullcount) { fInput0 = fInput0_ptr[index]; fOutput0 = fOutput0_ptr[index]; int count = (fullcount - index); /* Recursive loop 0 */ /* Pre code */ iYec0_idx = ((iYec0_idx + iYec0_idx_save) 2047); /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { iYec0[((i + iYec0_idx) 2047)] = int((1048576.0f * mydsp_faustpower2_f(float(fInput0[i])))); } /* Post code */ iYec0_idx_save = count; /* Recursive loop 1 */ /* Pre code */ for (int j0 = 0; (j0 4); j0 = (j0 + 1)) { iRec0_tmp[j0] = iRec0_perm[j0]; } /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { iRec0[i] = ((iRec0[(i - 1)] + iYec0[((i + iYec0_idx) 2047)]) - iYec0[(((i + iYec0_idx) - 1000) 2047)]); } /* Post code */ for (int j = 0; (j 4); j = (j + 1)) { iRec0_perm[j] = iRec0_tmp[(count + j)]; } /* Vectorizable loop 2 */ /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fOutput0[i] = FAUSTFLOAT(std::sqrt((9.53674362e-10f * float(iRec0[i])))); } } } While the second version of the code is more complex, it turns out to be much easier to vectorize efficiently by the C++ compiler. With the exact same compilation options: -O3 -xHost -ftz -fno-alias -fp-model fast=2 , the scalar version leads to a throughput performance of 129.144 MB/s, while the vector version achieves 359.548 MB/s, a speedup of x2.8 ! The vector code generation is built on top of the scalar code generation (see previous figure). Every time an expression needs to be compiled, the compiler checks if it requires a separate loop or not. Expressions that are shared (and are complex enough) are good candidates to be compiled in a separate loop, as well as recursive expressions and expressions used in delay lines. The result is a directed graph in which each node is a computation loop (see figure below). This graph is stored in the class object and a topological sort is applied to it before printing the code. Parallel Code Generation Parallel code generation is activated by passing either the --openMP (or -omp ) option or the --scheduler (or -sch ) option . It implies that the -vec option as well as the parallel code generation are built on top of the vector code generation. The OpenMP Code Generator The --openMP (or -omp ) option , when given to the Faust compiler, will insert appropriate OpenMP directives into the C++ code. OpenMP is a well established API that is used to explicitly define direct multi-threaded, shared memory parallelism. It is based on a fork-join model of parallelism (see figure above). Parallel regions are delimited by #pragma omp parallel constructs. At the entrance of a parallel region, a group of parallel threads is activated. The code within a parallel region is executed by each thread of the parallel group until the end of the region. #pragma omp parallel { // the code here is executed simultaneously by every thread of the parallel // team ... } In order not to have every thread doing redundantly the exact same work, OpenMP provides specific work-sharing directives. For example #pragma omp sections allows to break the work into separate, discrete sections, each section being executed by one thread: #pragma omp parallel { #pragma omp sections { #pragma omp section { // job 1 } #pragma omp section { // job 2 } ... } ... } Adding Open MP Directives As said before, parallel code generation is built on top of vector code generation. The graph of loops produced by the vector code generator is topologically sorted in order to detect the loops that can be computed in parallel. The first set $S_0$ (loops $L1$, $L2$ and $L3$) contains the loops that don't depend on any other loops, the set $S_1$ contains the loops that only depend on loops of $S_0$, (that is loops $L4$ and $L5$), etc.. As all the loops of a given set $S_n$ can be computed in parallel, the compiler will generate a sections construct with a section for each loop. #pragma omp sections { #pragma omp section for (...) { // Loop 1 } #pragma omp section for (...) { // Loop 2 } ... } If a given set contains only one loop, then the compiler checks to see if the loop can be parallelized (no recursive dependencies) or not. If it can be parallelized, it generates: #pragma omp for for (...) { // Loop code } otherwise it generates a single construct so that only one thread will execute the loop: #pragma omp single for (...) { // Loop code } Example of Parallel OpenMP Code To illustrate how Faust uses the OpenMP directives, here is a very simple example, two 1-pole filters in parallel connected to an adder: filter(c) = *(1-c) : + ~ *(c); process = filter(0.9), filter(0.9) : +; Try it Yourself >> The corresponding compute() method obtained using the -omp option looks like this: virtual void compute(int fullcount, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { float fRec0_tmp[36]; float fRec1_tmp[36]; FAUSTFLOAT* fInput0 = 0; FAUSTFLOAT* fInput1 = 0; FAUSTFLOAT* fOutput0 = 0; float* fRec0 = fRec0_tmp[4]; float* fRec1 = fRec1_tmp[4]; fInput0_ptr = inputs[0]; fInput1_ptr = inputs[1]; fOutput0_ptr = outputs[0]; #pragma omp parallel\\ firstprivate(fInput0, fInput1, fOutput0, fRec0, fRec1) { for (int index = 0; (index fullcount); index = (index + 32)) { fInput0 = fInput0_ptr[index]; fInput1 = fInput1_ptr[index]; fOutput0 = fOutput0_ptr[index]; int count = min(32, (fullcount - index)); #pragma omp sections { #pragma omp section { /* Recursive loop 0 */ /* Pre code */ for (int j0 = 0; (j0 4); j0 = (j0 + 1)) { fRec0_tmp[j0] = fRec0_perm[j0]; } /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fRec0[i] = ((0.899999976f * fRec0[(i - 1)]) + (0.100000001f * float(fInput0[i]))); } /* Post code */ for (int j = 0; (j 4); j = (j + 1)) { fRec0_perm[j] = fRec0_tmp[(count + j)]; } } #pragma omp section { /* Recursive loop 1 */ /* Pre code */ for (int j1 = 0; (j1 4); j1 = (j1 + 1)) { fRec1_tmp[j1] = fRec1_perm[j1]; } /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fRec1[i] = ((0.899999976f * fRec1[(i - 1)]) + (0.100000001f * float(fInput1[i]))); } /* Post code */ for (int j = 0; (j 4); j = (j + 1)) { fRec1_perm[j] = fRec1_tmp[(count + j)]; } } } #pragma omp single { /* Vectorizable loop 2 */ /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fOutput0[i] = FAUSTFLOAT((fRec0[i] + fRec1[i])); } } } } } This code requires some comments: The parallel construct #pragma omp parallel is the fundamental construct that starts parallel execution. The number of parallel threads is generally the number of CPU cores but it can be controlled in several ways. Variables external to the parallel region are shared by default. The pragma firstprivate(fRec0,fRec1) indicates that each thread should have its private copy of fRec0 and fRec1 . The reason is that accessing shared variables requires an indirection and is quite inefficient compared to private copies. The top level loop for (int index = 0;...)... is executed by all threads simultaneously. The subsequent work-sharing directives inside the loop will indicate how the work must be shared between threads. Please note that an implied barrier exists at the end of each work-sharing region. All threads must have executed the barrier before any of them can continue. The work-sharing directive #pragma omp single indicates that this first section will be executed by only one thread (any of them). The work-sharing directive #pragma omp sections indicates that each corresponding #pragma omp section , here our two filters, will be executed in parallel. The loop construct #pragma omp for specifies that the iterations of the associated loop will be executed in parallel. The iterations of the loop are distributed across the parallel threads. For example, if we have two threads, the first one can compute indices between 0 and count/2 and the other one between count/2 and count. Finally #pragma omp single indicates that this section will be executed by only one thread (any of them). The Scheduler Code Generator With the --scheduler (or -sch ) option given to the Faust compiler, the computation graph is cut into separate computation loops (called \"tasks\"), and a \"Work Stealing Scheduler\" is used to activate and execute them following their dependencies. A pool of worked threads is created and each thread uses it's own local WSQ (Work Stealing Queue) of tasks. A WSQ is a special queue with a Push operation, a \"private\" LIFO Pop operation and a \"public\" FIFO Pop operation. Starting from a ready task, each thread follows the dependencies, possibly pushing ready sub-tasks into it's own local WSQ. When no more tasks can be activated on a given computation path, the thread pops a task from it's local WSQ. If the WSQ is empty, then the thread is allowed to \"steal\" tasks from other threads WSQ. The local LIFO Pop operation allows better cache locality and the FIFO steal Pop \"larger chuck\" of work to be done. The reason for this is that many work stealing workloads are divide-and-conquer in nature, stealing one of the oldest task implicitly also steals a (potentially) large sub-tree of computations that will unfold once that piece of work is stolen and run. Compared to the OpenMP model ( -omp ) the new model is worse for simple Faust programs and usually starts to behave comparable or sometimes better for \"complex enough\" Faust programs. In any case, since OpenMP does not behave so well with GCC compilers, and is unusable on OSX in real-time contexts, this new scheduler option has it's own value. We plan to improve it adding a \"pipelining\" idea in the future. Example of Parallel Scheduler Code To illustrate how Faust generates the scheduler code, let's reuse the previous example made of two 1-pole filters in parallel connected to an adder: filter(c) = *(1-c) : + ~ *(c); process = filter(0.9), filter(0.9) : +; Try it Yourself >> When -sch option is used, the content of the additional architecture/scheduler.h file is inserted in the generated code. It contains code to deal with WSQ and thread management. The compute() and computeThread() methods are the following: virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { fInput0_ptr = inputs[0]; fInput1_ptr = inputs[1]; fOutput0_ptr = outputs[0]; fCount = count; fIndex = 0; /* End task has only one input, so will be directly activated */ /* Only initialize tasks with more than one input */ initTask(fScheduler, 4, 2); /* Push ready tasks in each thread WSQ */ initTaskList(fScheduler, -1); signalAll(fScheduler); computeThread(0); syncAll(fScheduler); } void computeThread(int num_thread) { int count = fCount; FAUSTFLOAT* fInput0 = 0; FAUSTFLOAT* fInput1 = 0; FAUSTFLOAT* fOutput0 = 0; int tasknum = 0; while ((fIndex fCount)) { fInput0 = fInput0_ptr[fIndex]; fInput1 = fInput1_ptr[fIndex]; fOutput0 = fOutput0_ptr[fIndex]; count = min(32, (fCount - fIndex)); switch (tasknum) { case 0: { /* Work Stealing task */ tasknum = getNextTask(fScheduler, num_thread); break; } case 1: { /* Last task */ fIndex = (fIndex + 32); if (fIndex fCount) { /* End task has only one input, so will be directly activated */ /* Only initialize tasks with more than one input */ initTask(fScheduler, 4, 2); /* Push ready tasks in 'num_thread' WSQ */ initTaskList(fScheduler, num_thread); } tasknum = 0; break; } case 2: { /* Recursive loop 2 */ /* Pre code */ for (int j0 = 0; (j0 4); j0 = (j0 + 1)) { fRec0_tmp[j0] = fRec0_perm[j0]; } /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fRec0[i] = ((0.899999976f * fRec0[(i - 1)]) + (0.100000001f * float(fInput0[i]))); } /* Post code */ for (int j = 0; (j 4); j = (j + 1)) { fRec0_perm[j] = fRec0_tmp[(count + j)]; } /* One output only */ activateOneOutputTask(fScheduler, num_thread, 4, tasknum); break; } case 3: { /* Recursive loop 3 */ /* Pre code */ for (int j1 = 0; (j1 4); j1 = (j1 + 1)) { fRec1_tmp[j1] = fRec1_perm[j1]; } /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fRec1[i] = ((0.899999976f * fRec1[(i - 1)]) + (0.100000001f * float(fInput1[i]))); } /* Post code */ for (int j = 0; (j 4); j = (j + 1)) { fRec1_perm[j] = fRec1_tmp[(count + j)]; } /* One output only */ activateOneOutputTask(fScheduler, num_thread, 4, tasknum); break; } case 4: { /* Vectorizable loop 4 */ /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fOutput0[i] = FAUSTFLOAT((fRec0[i] + fRec1[i])); } tasknum = 1; break; } } } }","title":"Using the Compiler"},{"location":"refs/compiler/#using-the-faust-compiler","text":"While the Faust compiler is available in different forms (e.g., Embedded Compiler , etc.), its most \"common\" one is the command line version, which can be invoked using the faust command. It translates a Faust program into code in a wide range of languages (C, O-C++, C++, Rust, JAVA, JavaScript, ASM JavaScript, LLVM, C-LLVM, FIR, and WebAssembly). The generated code can be wrapped into an optional architecture file allowing to directly produce a fully operational program. A typical call of the Faust command line compiler is: faust [OPTIONS] faustFile.dsp The Faust compiler outputs C++ code by default therefore running: faust noise.dsp will compile noise.dsp and output the corresponding C++ code on the standard output. The option -o allows to reroute the standard output to a file: faust noise.dsp -o noise.cpp The -a option allows us to wrap the generated code into an architecture file: faust -a alsa-gtk.cpp noise.dsp which can either be placed in the same folder as the current Faust file ( noise.dsp here) or be one of the standard Faust architectures. To compile a Faust program into an ALSA application on Linux, the following commands can be used: faust -a alsa-gtk.cpp noise.dsp -o noise.cpp g++ -lpthread -lasound `pkg-config --cflags --libs gtk+-2.0` noise.cpp -o noise Note that a wide range of faust2... compilation scripts can be used to facilitate this operation by taking a Faust file and returning the corresponding binary for your platform.","title":"Using the Faust Compiler"},{"location":"refs/compiler/#structure-of-the-generated-code","text":"A Faust DSP C++ class derives from the base dsp class defined as below (a similar structure is used for languages than C++): class dsp { public: dsp() {} virtual ~dsp() {} // Returns the number of inputs of the Faust program virtual int getNumInputs() = 0; // Returns the number of outputs of the Faust program virtual int getNumOutputs() = 0; // This method can be called to retrieve the UI description of // the Faust program and its associated fields virtual void buildUserInterface(UI* ui_interface) = 0; // Returns the current sampling rate virtual int getSampleRate() = 0; // Init methods virtual void init(int samplingRate) = 0; virtual void instanceInit(int samplingRate) = 0; virtual void instanceConstants(int samplingRate) = 0; virtual void instanceResetUserInterface() = 0; virtual void instanceClear() = 0; // Returns a clone of the instance virtual dsp* clone() = 0; // Retrieve the global metadata of the Faust program virtual void metadata(Meta* m) = 0; // Compute one audio frame virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) = 0; // Compute a time-stamped audio frame virtual void compute(double /*date_usec*/, int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { compute(count, inputs, outputs); } }; Methods are filled by the compiler with the actual code. In the case of noise.dsp : class mydsp : public dsp { private: int iRec0[2]; int fSamplingFreq; public: void metadata(Meta* m) { m- declare( author , GRAME ); m- declare( filename , noise ); m- declare( name , Noise ); m- declare( noises.lib/name , Faust Noise Generator Library ); m- declare( noises.lib/version , 0.0 ); } virtual int getNumInputs() { return 0; } virtual int getNumOutputs() { return 1; } virtual int getInputRate(int channel) { int rate; switch (channel) { default: { rate = -1; break; } } return rate; } virtual int getOutputRate(int channel) { int rate; switch (channel) { case 0: { rate = 1; break; } default: { rate = -1; break; } } return rate; } static void classInit(int samplingFreq) {} virtual void instanceConstants(int samplingFreq) { fSamplingFreq = samplingFreq; } virtual void instanceResetUserInterface() {} virtual void instanceClear() { for (int l0 = 0; (l0 2); l0 = (l0 + 1)) { iRec0[l0] = 0; } } virtual void init(int samplingFreq) { classInit(samplingFreq); instanceInit(samplingFreq); } virtual void instanceInit(int samplingFreq) { instanceConstants(samplingFreq); instanceResetUserInterface(); instanceClear(); } virtual mydsp* clone() { return new mydsp(); } virtual int getSampleRate() { return fSamplingFreq; } virtual void buildUserInterface(UI* ui_interface) { ui_interface- openVerticalBox( Noise ); ui_interface- closeBox(); } virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { FAUSTFLOAT* output0 = outputs[0]; for (int i = 0; (i count); i = (i + 1)) { iRec0[0] = ((1103515245 * iRec0[1]) + 12345); output0[i] = FAUSTFLOAT((4.65661287e-10f * float(iRec0[0]))); iRec0[1] = iRec0[0]; } } }; Several fine-grained initialization methods are available. The instanceInit method calls several additional initialization methods. The instanceConstants method sets the instance constant state. The instanceClear method resets the instance dynamic state (delay lines...). The instanceResetUserInterface method resets all control value to their default state. All of those methods can be used individually on an allocated instance to reset part of its state. The init method combines class static state and instance initialization. When using a single instance, calling init is the simplest way to do \"what is needed.\" When using several instances, all of them can be initialized using instanceInit , with a single call to classInit to initialize the static shared state.","title":"Structure of the Generated Code"},{"location":"refs/compiler/#controlling-code-generation","text":"Several options of the Faust compiler allow to control the generated C++ code. By default computation is done sample by sample in a single loop. But the compiler can also generate vector and parallel code.","title":"Controlling Code Generation"},{"location":"refs/compiler/#vector-code-generation","text":"Modern C++ compilers are able to do autovectorization, that is to use SIMD instructions to speedup the code. These instructions can typically operate in parallel on short vectors of 4 simple precision floating point numbers, leading to a theoretical speedup of $\\times4$. Autovectorization of C/C++ programs is a difficult task. Current compilers are very sensitive to the way the code is arranged. In particular, complex loops can prevent autovectorization. The goal of the vector code generation is to rearrange the C++ code in a way that facilitates the autovectorization job of the C++ compiler. Instead of generating a single sample computation loop, it splits the computation into several simpler loops that communicates by vectors. The vector code generation is activated by passing the --vectorize (or -vec ) option to the Faust compiler. Two additional options are available: --vec-size n controls the size of the vector (by default 32 samples) and --loop-variant 0/1 gives some additional control on the loops. To illustrate the difference between scalar code and vector code, let's take the computation of the RMS (Root Mean Square) value of a signal. Here is the Faust code that computes the Root Mean Square of a sliding window of 1000 samples: // Root Mean Square of n consecutive samples RMS(n) = square : mean(n) : sqrt; // Square of a signal square(x) = x * x; // Mean of n consecutive samples of a signal (uses fixpoint to avoid the // accumulation of rounding errors) mean(n) = float2fix : integrate(n) : fix2float : /(n); // Sliding sum of n consecutive samples integrate(n,x) = x - x@n : +~_; // Convertion between float and fix point float2fix(x) = int(x*(1 20)); fix2float(x) = float(x)/(1 20); // Root Mean Square of 1000 consecutive samples process = RMS(1000); Try it Yourself >> The corresponding compute() method generated in scalar mode is the following: virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { FAUSTFLOAT* input0 = inputs[0]; FAUSTFLOAT* output0 = outputs[0]; for (int i = 0; (i count); i = (i + 1)) { int iTemp0 = int((1048576.0f * mydsp_faustpower2_f(float(input0[i])))); iVec0[(IOTA 1023)] = iTemp0; iRec0[0] = ((iRec0[1] + iTemp0) - iVec0[((IOTA - 1000) 1023)]); output0[i] = FAUSTFLOAT(std::sqrt((9.53674362e-10f * float(iRec0[0])))); IOTA = (IOTA + 1); iRec0[1] = iRec0[0]; } } The -vec option leads to the following reorganization of the code: virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { fInput0_ptr = inputs[0]; FAUSTFLOAT* fInput0 = 0; fOutput0_ptr = outputs[0]; FAUSTFLOAT* fOutput0 = 0; int iRec0_tmp[36]; int* iRec0 = iRec0_tmp[4]; int fullcount = count; int index = 0; /* Main loop */ for (index = 0; (index = (fullcount - 32)); index = (index + 32)) { fInput0 = fInput0_ptr[index]; fOutput0 = fOutput0_ptr[index]; int count = 32; /* Recursive loop 0 */ /* Pre code */ iYec0_idx = ((iYec0_idx + iYec0_idx_save) 2047); /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { iYec0[((i + iYec0_idx) 2047)] = int((1048576.0f mydsp_faustpower2_f(float(fInput0[i])))); } /* Post code */ iYec0_idx_save = count; /* Recursive loop 1 */ /* Pre code */ for (int j0 = 0; (j0 4); j0 = (j0 + 1)) { iRec0_tmp[j0] = iRec0_perm[j0]; } /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { iRec0[i] = ((iRec0[(i - 1)] + iYec0[((i + iYec0_idx) 2047)]) - iYec0[(((i + iYec0_idx) - 1000) 2047)]); } /* Post code */ for (int j = 0; (j 4); j = (j + 1)) { iRec0_perm[j] = iRec0_tmp[(count + j)]; } /* Vectorizable loop 2 */ /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fOutput0[i] = FAUSTFLOAT(std::sqrt((9.53674362e-10f * float(iRec0[i])))); } } /* Remaining frames */ if (index fullcount) { fInput0 = fInput0_ptr[index]; fOutput0 = fOutput0_ptr[index]; int count = (fullcount - index); /* Recursive loop 0 */ /* Pre code */ iYec0_idx = ((iYec0_idx + iYec0_idx_save) 2047); /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { iYec0[((i + iYec0_idx) 2047)] = int((1048576.0f * mydsp_faustpower2_f(float(fInput0[i])))); } /* Post code */ iYec0_idx_save = count; /* Recursive loop 1 */ /* Pre code */ for (int j0 = 0; (j0 4); j0 = (j0 + 1)) { iRec0_tmp[j0] = iRec0_perm[j0]; } /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { iRec0[i] = ((iRec0[(i - 1)] + iYec0[((i + iYec0_idx) 2047)]) - iYec0[(((i + iYec0_idx) - 1000) 2047)]); } /* Post code */ for (int j = 0; (j 4); j = (j + 1)) { iRec0_perm[j] = iRec0_tmp[(count + j)]; } /* Vectorizable loop 2 */ /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fOutput0[i] = FAUSTFLOAT(std::sqrt((9.53674362e-10f * float(iRec0[i])))); } } } While the second version of the code is more complex, it turns out to be much easier to vectorize efficiently by the C++ compiler. With the exact same compilation options: -O3 -xHost -ftz -fno-alias -fp-model fast=2 , the scalar version leads to a throughput performance of 129.144 MB/s, while the vector version achieves 359.548 MB/s, a speedup of x2.8 ! The vector code generation is built on top of the scalar code generation (see previous figure). Every time an expression needs to be compiled, the compiler checks if it requires a separate loop or not. Expressions that are shared (and are complex enough) are good candidates to be compiled in a separate loop, as well as recursive expressions and expressions used in delay lines. The result is a directed graph in which each node is a computation loop (see figure below). This graph is stored in the class object and a topological sort is applied to it before printing the code.","title":"Vector Code Generation"},{"location":"refs/compiler/#parallel-code-generation","text":"Parallel code generation is activated by passing either the --openMP (or -omp ) option or the --scheduler (or -sch ) option . It implies that the -vec option as well as the parallel code generation are built on top of the vector code generation.","title":"Parallel Code Generation"},{"location":"refs/compiler/#the-openmp-code-generator","text":"The --openMP (or -omp ) option , when given to the Faust compiler, will insert appropriate OpenMP directives into the C++ code. OpenMP is a well established API that is used to explicitly define direct multi-threaded, shared memory parallelism. It is based on a fork-join model of parallelism (see figure above). Parallel regions are delimited by #pragma omp parallel constructs. At the entrance of a parallel region, a group of parallel threads is activated. The code within a parallel region is executed by each thread of the parallel group until the end of the region. #pragma omp parallel { // the code here is executed simultaneously by every thread of the parallel // team ... } In order not to have every thread doing redundantly the exact same work, OpenMP provides specific work-sharing directives. For example #pragma omp sections allows to break the work into separate, discrete sections, each section being executed by one thread: #pragma omp parallel { #pragma omp sections { #pragma omp section { // job 1 } #pragma omp section { // job 2 } ... } ... }","title":"The OpenMP Code Generator"},{"location":"refs/compiler/#adding-open-mp-directives","text":"As said before, parallel code generation is built on top of vector code generation. The graph of loops produced by the vector code generator is topologically sorted in order to detect the loops that can be computed in parallel. The first set $S_0$ (loops $L1$, $L2$ and $L3$) contains the loops that don't depend on any other loops, the set $S_1$ contains the loops that only depend on loops of $S_0$, (that is loops $L4$ and $L5$), etc.. As all the loops of a given set $S_n$ can be computed in parallel, the compiler will generate a sections construct with a section for each loop. #pragma omp sections { #pragma omp section for (...) { // Loop 1 } #pragma omp section for (...) { // Loop 2 } ... } If a given set contains only one loop, then the compiler checks to see if the loop can be parallelized (no recursive dependencies) or not. If it can be parallelized, it generates: #pragma omp for for (...) { // Loop code } otherwise it generates a single construct so that only one thread will execute the loop: #pragma omp single for (...) { // Loop code }","title":"Adding Open MP Directives"},{"location":"refs/compiler/#example-of-parallel-openmp-code","text":"To illustrate how Faust uses the OpenMP directives, here is a very simple example, two 1-pole filters in parallel connected to an adder: filter(c) = *(1-c) : + ~ *(c); process = filter(0.9), filter(0.9) : +; Try it Yourself >> The corresponding compute() method obtained using the -omp option looks like this: virtual void compute(int fullcount, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { float fRec0_tmp[36]; float fRec1_tmp[36]; FAUSTFLOAT* fInput0 = 0; FAUSTFLOAT* fInput1 = 0; FAUSTFLOAT* fOutput0 = 0; float* fRec0 = fRec0_tmp[4]; float* fRec1 = fRec1_tmp[4]; fInput0_ptr = inputs[0]; fInput1_ptr = inputs[1]; fOutput0_ptr = outputs[0]; #pragma omp parallel\\ firstprivate(fInput0, fInput1, fOutput0, fRec0, fRec1) { for (int index = 0; (index fullcount); index = (index + 32)) { fInput0 = fInput0_ptr[index]; fInput1 = fInput1_ptr[index]; fOutput0 = fOutput0_ptr[index]; int count = min(32, (fullcount - index)); #pragma omp sections { #pragma omp section { /* Recursive loop 0 */ /* Pre code */ for (int j0 = 0; (j0 4); j0 = (j0 + 1)) { fRec0_tmp[j0] = fRec0_perm[j0]; } /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fRec0[i] = ((0.899999976f * fRec0[(i - 1)]) + (0.100000001f * float(fInput0[i]))); } /* Post code */ for (int j = 0; (j 4); j = (j + 1)) { fRec0_perm[j] = fRec0_tmp[(count + j)]; } } #pragma omp section { /* Recursive loop 1 */ /* Pre code */ for (int j1 = 0; (j1 4); j1 = (j1 + 1)) { fRec1_tmp[j1] = fRec1_perm[j1]; } /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fRec1[i] = ((0.899999976f * fRec1[(i - 1)]) + (0.100000001f * float(fInput1[i]))); } /* Post code */ for (int j = 0; (j 4); j = (j + 1)) { fRec1_perm[j] = fRec1_tmp[(count + j)]; } } } #pragma omp single { /* Vectorizable loop 2 */ /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fOutput0[i] = FAUSTFLOAT((fRec0[i] + fRec1[i])); } } } } } This code requires some comments: The parallel construct #pragma omp parallel is the fundamental construct that starts parallel execution. The number of parallel threads is generally the number of CPU cores but it can be controlled in several ways. Variables external to the parallel region are shared by default. The pragma firstprivate(fRec0,fRec1) indicates that each thread should have its private copy of fRec0 and fRec1 . The reason is that accessing shared variables requires an indirection and is quite inefficient compared to private copies. The top level loop for (int index = 0;...)... is executed by all threads simultaneously. The subsequent work-sharing directives inside the loop will indicate how the work must be shared between threads. Please note that an implied barrier exists at the end of each work-sharing region. All threads must have executed the barrier before any of them can continue. The work-sharing directive #pragma omp single indicates that this first section will be executed by only one thread (any of them). The work-sharing directive #pragma omp sections indicates that each corresponding #pragma omp section , here our two filters, will be executed in parallel. The loop construct #pragma omp for specifies that the iterations of the associated loop will be executed in parallel. The iterations of the loop are distributed across the parallel threads. For example, if we have two threads, the first one can compute indices between 0 and count/2 and the other one between count/2 and count. Finally #pragma omp single indicates that this section will be executed by only one thread (any of them).","title":"Example of Parallel OpenMP Code"},{"location":"refs/compiler/#the-scheduler-code-generator","text":"With the --scheduler (or -sch ) option given to the Faust compiler, the computation graph is cut into separate computation loops (called \"tasks\"), and a \"Work Stealing Scheduler\" is used to activate and execute them following their dependencies. A pool of worked threads is created and each thread uses it's own local WSQ (Work Stealing Queue) of tasks. A WSQ is a special queue with a Push operation, a \"private\" LIFO Pop operation and a \"public\" FIFO Pop operation. Starting from a ready task, each thread follows the dependencies, possibly pushing ready sub-tasks into it's own local WSQ. When no more tasks can be activated on a given computation path, the thread pops a task from it's local WSQ. If the WSQ is empty, then the thread is allowed to \"steal\" tasks from other threads WSQ. The local LIFO Pop operation allows better cache locality and the FIFO steal Pop \"larger chuck\" of work to be done. The reason for this is that many work stealing workloads are divide-and-conquer in nature, stealing one of the oldest task implicitly also steals a (potentially) large sub-tree of computations that will unfold once that piece of work is stolen and run. Compared to the OpenMP model ( -omp ) the new model is worse for simple Faust programs and usually starts to behave comparable or sometimes better for \"complex enough\" Faust programs. In any case, since OpenMP does not behave so well with GCC compilers, and is unusable on OSX in real-time contexts, this new scheduler option has it's own value. We plan to improve it adding a \"pipelining\" idea in the future.","title":"The Scheduler Code Generator"},{"location":"refs/compiler/#example-of-parallel-scheduler-code","text":"To illustrate how Faust generates the scheduler code, let's reuse the previous example made of two 1-pole filters in parallel connected to an adder: filter(c) = *(1-c) : + ~ *(c); process = filter(0.9), filter(0.9) : +; Try it Yourself >> When -sch option is used, the content of the additional architecture/scheduler.h file is inserted in the generated code. It contains code to deal with WSQ and thread management. The compute() and computeThread() methods are the following: virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) { fInput0_ptr = inputs[0]; fInput1_ptr = inputs[1]; fOutput0_ptr = outputs[0]; fCount = count; fIndex = 0; /* End task has only one input, so will be directly activated */ /* Only initialize tasks with more than one input */ initTask(fScheduler, 4, 2); /* Push ready tasks in each thread WSQ */ initTaskList(fScheduler, -1); signalAll(fScheduler); computeThread(0); syncAll(fScheduler); } void computeThread(int num_thread) { int count = fCount; FAUSTFLOAT* fInput0 = 0; FAUSTFLOAT* fInput1 = 0; FAUSTFLOAT* fOutput0 = 0; int tasknum = 0; while ((fIndex fCount)) { fInput0 = fInput0_ptr[fIndex]; fInput1 = fInput1_ptr[fIndex]; fOutput0 = fOutput0_ptr[fIndex]; count = min(32, (fCount - fIndex)); switch (tasknum) { case 0: { /* Work Stealing task */ tasknum = getNextTask(fScheduler, num_thread); break; } case 1: { /* Last task */ fIndex = (fIndex + 32); if (fIndex fCount) { /* End task has only one input, so will be directly activated */ /* Only initialize tasks with more than one input */ initTask(fScheduler, 4, 2); /* Push ready tasks in 'num_thread' WSQ */ initTaskList(fScheduler, num_thread); } tasknum = 0; break; } case 2: { /* Recursive loop 2 */ /* Pre code */ for (int j0 = 0; (j0 4); j0 = (j0 + 1)) { fRec0_tmp[j0] = fRec0_perm[j0]; } /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fRec0[i] = ((0.899999976f * fRec0[(i - 1)]) + (0.100000001f * float(fInput0[i]))); } /* Post code */ for (int j = 0; (j 4); j = (j + 1)) { fRec0_perm[j] = fRec0_tmp[(count + j)]; } /* One output only */ activateOneOutputTask(fScheduler, num_thread, 4, tasknum); break; } case 3: { /* Recursive loop 3 */ /* Pre code */ for (int j1 = 0; (j1 4); j1 = (j1 + 1)) { fRec1_tmp[j1] = fRec1_perm[j1]; } /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fRec1[i] = ((0.899999976f * fRec1[(i - 1)]) + (0.100000001f * float(fInput1[i]))); } /* Post code */ for (int j = 0; (j 4); j = (j + 1)) { fRec1_perm[j] = fRec1_tmp[(count + j)]; } /* One output only */ activateOneOutputTask(fScheduler, num_thread, 4, tasknum); break; } case 4: { /* Vectorizable loop 4 */ /* Compute code */ for (int i = 0; (i count); i = (i + 1)) { fOutput0[i] = FAUSTFLOAT((fRec0[i] + fRec1[i])); } tasknum = 1; break; } } } }","title":"Example of Parallel Scheduler Code"},{"location":"refs/options/","text":"Faust compiler options FAUST compiler version 2.23.2 usage : faust [options] file1 [file2 ...]. where options represent zero or more compiler options and fileN represents a Faust source file (.dsp extension). Input options: -a file wrapper architecture file. -i --inline-architecture-files inline architecture files. -A dir --architecture-dir dir add the directory dir to the architecture search path. -I dir --import-dir dir add the directory dir to the import search path. -L file --library file link with the LLVM module file . -t sec --timeout sec abort compilation after sec seconds (default 120). Output options: -o file the output file. -e --export-dsp export expanded DSP (with all included libraries). -uim --user-interface-macros add user interface macro definitions to the output code. -xml generate an XML description file. -json generate a JSON description file. -O dir --output-dir dir specify the relative directory of the generated output code and of additional generated files (SVG, XML...). Code generation options: -lang lang --language select output language, 'lang' should be in c, ocpp, cpp (default), rust, java, llvm, cllvm, fir, wast/wasm, soul, interp. -single --single-precision-floats use single precision floats for internal computations (default). -double --double-precision-floats use double precision floats for internal computations. -quad --quad-precision-floats use quad precision floats for internal computations. -es 1|0 --enable-semantics 1|0 use enable semantics when 1 (default), and simple multiplication otherwise. -lcc --local-causality-check check causality also at local level. -light --light-mode do not generate the entire DSP API. -clang --clang when compiled with clang/clang++, adds specific #pragma for auto-vectorization. -flist --file-list use file list used to eval process. -exp10 --generate-exp10 function call instead of pow(10) function. -os --one-sample generate one sample computation. -cn name --class-name name specify the name of the dsp class to be used instead of mydsp. -scn name --super-class-name name specify the name of the super class to be used instead of dsp. -pn name --process-name name specify the name of the dsp entry-point instead of process. -lb --left-balanced generate left balanced expressions. -mb --mid-balanced generate mid balanced expressions (default). -rb --right-balanced generate right balanced expressions. -lt --less-temporaries generate less temporaries in compiling delays. -mcd n --max-copy-delay n threshold between copy and ring buffer implementation (default 16 samples). -mem --memory allocate static in global state using a custom memory manager. -ftz n --flush-to-zero n code added to recursive signals [0:no (default), 1:fabs based, 2:mask based (fastest)]. -inj f --inject f inject source file f into architecture file instead of compile a dsp file. -scal --scalar generate non-vectorized code. -inpl --in-place generates code working when input and output buffers are the same (scalar mode only). -vec --vectorize generate easier to vectorize code. -vs n --vec-size n size of the vector (default 32 samples). -lv n --loop-variant n [0:fastest (default), 1:simple]. -omp --openmp generate OpenMP pragmas, activates --vectorize option. -pl --par-loop generate parallel loops in --openmp mode. -sch --scheduler generate tasks and use a Work Stealing scheduler, activates --vectorize option. -ocl --opencl generate tasks with OpenCL (experimental). -cuda --cuda generate tasks with CUDA (experimental). -dfs --deep-first-scheduling schedule vector loops in deep first order. -g --group-tasks group single-threaded sequential tasks together when -omp or -sch is used. -fun --fun-tasks separate tasks code as separated functions (in -vec, -sch, or -omp mode). -fm file --fast-math file use optimized versions of mathematical functions implemented in file , use 'faust/dsp/fastmath.cpp' when file is 'def'. -ns name --namespace name generate C++ code in a namespace name Block diagram options: -ps --postscript print block-diagram to a postscript file. -svg --svg print block-diagram to a svg file. -sd --simplify-diagrams try to further simplify diagrams before drawing. -drf --draw-route-frame draw route frames instead of simple cables. -f n --fold n threshold to activate folding mode during block-diagram generation (default 25 elements). -fc n --fold-complexity n complexity threshold to fold an expression in folding mode (default 2) -mns n --max-name-size n threshold during block-diagram generation (default 40 char). -sn --simple-names use simple names (without arguments) during block-diagram generation. -blur --shadow-blur add a shadow blur to SVG boxes. Math doc options: -mdoc --mathdoc print math documentation of the Faust program in LaTeX format in a -mdoc folder. -mdlang l --mathdoc-lang l if translation file exists ( l = en, fr, ...). -stripmdoc --strip-mdoc-tags strip mdoc tags when printing Faust -mdoc listings. Debug options: -d --details print compilation details. -time --compilation-time display compilation phases timing information. -tg --task-graph print the internal task graph in dot format. -sg --signal-graph print the internal signal graph in dot format. -norm --normalized-form print signals in normalized form and exit. -ct --check-table check table index range and fails. -cat --check-all-table check all table index range. Information options: -h --help print this help message. -v --version print version information and embedded backends list. -libdir --libdir print directory containing the Faust libraries. -includedir --includedir print directory containing the Faust headers. -archdir --archdir print directory containing the Faust architectures. -dspdir --dspdir print directory containing the Faust dsp libraries. -pathslist --pathslist print the architectures and dsp library paths. Example: faust -a jack-gtk.cpp -o myfx.cpp myfx.dsp","title":"Compiler Options"},{"location":"refs/options/#faust-compiler-options","text":"","title":"Faust compiler options"},{"location":"refs/options/#faust-compiler-version-2232","text":"usage : faust [options] file1 [file2 ...]. where options represent zero or more compiler options and fileN represents a Faust source file (.dsp extension).","title":"FAUST compiler version 2.23.2"},{"location":"refs/options/#input-options","text":"-a file wrapper architecture file. -i --inline-architecture-files inline architecture files. -A dir --architecture-dir dir add the directory dir to the architecture search path. -I dir --import-dir dir add the directory dir to the import search path. -L file --library file link with the LLVM module file . -t sec --timeout sec abort compilation after sec seconds (default 120).","title":"Input options:"},{"location":"refs/options/#output-options","text":"-o file the output file. -e --export-dsp export expanded DSP (with all included libraries). -uim --user-interface-macros add user interface macro definitions to the output code. -xml generate an XML description file. -json generate a JSON description file. -O dir --output-dir dir specify the relative directory of the generated output code and of additional generated files (SVG, XML...).","title":"Output options:"},{"location":"refs/options/#code-generation-options","text":"-lang lang --language select output language, 'lang' should be in c, ocpp, cpp (default), rust, java, llvm, cllvm, fir, wast/wasm, soul, interp. -single --single-precision-floats use single precision floats for internal computations (default). -double --double-precision-floats use double precision floats for internal computations. -quad --quad-precision-floats use quad precision floats for internal computations. -es 1|0 --enable-semantics 1|0 use enable semantics when 1 (default), and simple multiplication otherwise. -lcc --local-causality-check check causality also at local level. -light --light-mode do not generate the entire DSP API. -clang --clang when compiled with clang/clang++, adds specific #pragma for auto-vectorization. -flist --file-list use file list used to eval process. -exp10 --generate-exp10 function call instead of pow(10) function. -os --one-sample generate one sample computation. -cn name --class-name name specify the name of the dsp class to be used instead of mydsp. -scn name --super-class-name name specify the name of the super class to be used instead of dsp. -pn name --process-name name specify the name of the dsp entry-point instead of process. -lb --left-balanced generate left balanced expressions. -mb --mid-balanced generate mid balanced expressions (default). -rb --right-balanced generate right balanced expressions. -lt --less-temporaries generate less temporaries in compiling delays. -mcd n --max-copy-delay n threshold between copy and ring buffer implementation (default 16 samples). -mem --memory allocate static in global state using a custom memory manager. -ftz n --flush-to-zero n code added to recursive signals [0:no (default), 1:fabs based, 2:mask based (fastest)]. -inj f --inject f inject source file f into architecture file instead of compile a dsp file. -scal --scalar generate non-vectorized code. -inpl --in-place generates code working when input and output buffers are the same (scalar mode only). -vec --vectorize generate easier to vectorize code. -vs n --vec-size n size of the vector (default 32 samples). -lv n --loop-variant n [0:fastest (default), 1:simple]. -omp --openmp generate OpenMP pragmas, activates --vectorize option. -pl --par-loop generate parallel loops in --openmp mode. -sch --scheduler generate tasks and use a Work Stealing scheduler, activates --vectorize option. -ocl --opencl generate tasks with OpenCL (experimental). -cuda --cuda generate tasks with CUDA (experimental). -dfs --deep-first-scheduling schedule vector loops in deep first order. -g --group-tasks group single-threaded sequential tasks together when -omp or -sch is used. -fun --fun-tasks separate tasks code as separated functions (in -vec, -sch, or -omp mode). -fm file --fast-math file use optimized versions of mathematical functions implemented in file , use 'faust/dsp/fastmath.cpp' when file is 'def'. -ns name --namespace name generate C++ code in a namespace name","title":"Code generation options:"},{"location":"refs/options/#block-diagram-options","text":"-ps --postscript print block-diagram to a postscript file. -svg --svg print block-diagram to a svg file. -sd --simplify-diagrams try to further simplify diagrams before drawing. -drf --draw-route-frame draw route frames instead of simple cables. -f n --fold n threshold to activate folding mode during block-diagram generation (default 25 elements). -fc n --fold-complexity n complexity threshold to fold an expression in folding mode (default 2) -mns n --max-name-size n threshold during block-diagram generation (default 40 char). -sn --simple-names use simple names (without arguments) during block-diagram generation. -blur --shadow-blur add a shadow blur to SVG boxes.","title":"Block diagram options:"},{"location":"refs/options/#math-doc-options","text":"-mdoc --mathdoc print math documentation of the Faust program in LaTeX format in a -mdoc folder. -mdlang l --mathdoc-lang l if translation file exists ( l = en, fr, ...). -stripmdoc --strip-mdoc-tags strip mdoc tags when printing Faust -mdoc listings.","title":"Math doc options:"},{"location":"refs/options/#debug-options","text":"-d --details print compilation details. -time --compilation-time display compilation phases timing information. -tg --task-graph print the internal task graph in dot format. -sg --signal-graph print the internal signal graph in dot format. -norm --normalized-form print signals in normalized form and exit. -ct --check-table check table index range and fails. -cat --check-all-table check all table index range.","title":"Debug options:"},{"location":"refs/options/#information-options","text":"-h --help print this help message. -v --version print version information and embedded backends list. -libdir --libdir print directory containing the Faust libraries. -includedir --includedir print directory containing the Faust headers. -archdir --archdir print directory containing the Faust architectures. -dspdir --dspdir print directory containing the Faust dsp libraries. -pathslist --pathslist print the architectures and dsp library paths.","title":"Information options:"},{"location":"refs/options/#example","text":"faust -a jack-gtk.cpp -o myfx.cpp myfx.dsp","title":"Example:"},{"location":"refs/syntax/","text":"Faust Syntax Faust Program A Faust program is essentially a list of statements . These statements can be metadata declarations (either global metadata or function metadata ), imports , definitions , and documentation tags , with optional C++ style ( //... and /*...*/ ) comments. Here is a short Faust program that implements of a simple noise generator (called from the noises.lib Faust library). It exhibits various kind of statements : two global metadata declarations, an imports , a comment , and a definition . We will study later how documentation statements work: declare name Noise ; declare copyright (c)GRAME 2018 ; import( stdfaust.lib ); // noise level controlled by a slider process = no.noise * hslider( gain ,0,0,1, 0.1); Try it Yourself >> The keyword process is the equivalent of main in C/C++. Any Faust program, to be valid, must at least define process . Statements The statements of a Faust program are of four kinds: metadata declarations , file imports , definitions , documentation . All statements but documentation end with a semicolon ; . Metadata Metadata allow us to add elements which are not part of the language to Faust code. These can range to the name of a Faust program, its author, to potential compilation options or user interface element customizations. There are three different types of metadata in Faust: Global Metadata : metadata global to a Faust code Function Metadata : metadata specific to a function UI Metadata : metadata specific to a UI element Note that some Global Metadata have standard names and can be used for specific tasks. Their role is described in the Standard Metadata section. Global Metadata All global metadata declaration in Faust start with declare , followed by a key and a string. For example: declare name Noise ; allows us to specify the name of a Faust program in its whole. Unlike regular comments, metadata declarations will appear in the C++ code generated by the Faust compiler. A good practice is to start a Faust program with some standard declarations: declare name MyProgram ; declare author MySelf ; declare copyright MyCompany ; declare version 1.00 ; declare license BSD ; Function Metadata Metadata can be associated to a specific function. In that case, declare is followed by the name of the function, a key, and a string. For example: declare add author John Doe add = +; This is very useful when a library has several contributors and that functions potentially have different license terms, etc. Standard Metadata There exists a series of standard global metadata in Faust whose role role is described in the following table: Metadata Role declare options \"[key0:value][key1:value]\" This metadata can be used to specify various options associated to a Faust code such as the fact its polyphonic, if it should have OSC, MIDI support, etc. Specific keys usable with this metadata are described throughout this documentation. declare interface \"xxx\" Specifies an interface replacing the standard Faust UI. Imports File imports allow us to import definitions from other source files. For example import(\"maths.lib\"); imports the definitions of the maths.lib library. The most common file to be imported is the stdfaust.lib library which gives access to all the standard Faust libraries from a single point: import( stdfaust.lib ); process = os.osc(440); // the hello world of computer music Try it Yourself >> Documentation Tags Documentation statements are optional and typically used to control the generation of the mathematical documentation of a Faust program. This documentation system is detailed in the Mathematical Documentation chapter. In this section we essentially describe the documentation statements syntax. A documentation statement starts with an opening mdoc tag and ends with a closing /mdoc tag. Free text content, typically in Latex format, can be placed in between these two tags. Moreover, optional sub-tags can be inserted in the text content itself to require the generation, at the insertion point, of mathematical equations , graphical block-diagrams , Faust source code listing and explanation notice . The generation of the mathematical equations of a Faust expression can be requested by placing this expression between an opening equation and a closing /equation tag. The expression is evaluated within the lexical context of the Faust program. Similarly, the generation of the graphical block-diagram of a Faust expression can be requested by placing this expression between an opening diagram and a closing /diagram tag. The expression is evaluated within the lexical context of the Faust program. The metadata tags allow to reference Faust global metadatas , calling the corresponding keyword. The notice/ empty-element tag is used to generate the conventions used in the mathematical equations. The listing/ empty-element tag is used to generate the listing of the Faust program. Its three attributes mdoctags , dependencies , and distributed enable or disable respectively mdoc tags, other files dependencies and distribution of interleaved Faust code between mdoc sections. Definitions A definition associates an identifier with an expression. Definitions are essentially a convenient shortcut avoiding to type long expressions. During compilation, more precisely during the evaluation stage, identifiers are replaced by their definitions. It is therefore always equivalent to use an identifier or directly its definition. Please note that multiple definitions of a same identifier are not allowed, unless it is a pattern matching based definition. Simple Definitions The syntax of a simple definition is: identifier = expression ; For example here is the definition of random , a simple pseudo-random number generator: random = +(12345) ~ *(1103515245); Function Definitions Definitions with formal parameters correspond to functions definitions. For example the definition of linear2db , a function that converts linear values to decibels, is: linear2db(x) = 20*log10(x); Please note that this notation is only a convenient alternative to the direct use of lambda-abstractions (also called anonymous functions). The following is an equivalent definition of linear2db using a lambda-abstraction: linear2db = \\(x).(20*log10(x)); Definitions with pattern matching Moreover, formal parameters can also be full expressions representing patterns. This powerful mechanism allows to algorithmically create and manipulate block diagrams expressions. Let's say that you want to describe a function to duplicate an expression several times in parallel: duplicate(1,x) = x; duplicate(n,x) = x, duplicate(n-1,x); Note that this last definition is a convenient alternative to the more verbose: duplicate = case { (1,x) = x; (n,x) = x, duplicate(n-1,x); }; A use case for duplicate could be to put 5 white noise generators in parallel: import( stdfaust.lib ); duplicate(1,x) = x; duplicate(n,x) = x, duplicate(n-1,x); process = duplicate(5,no.noise); Try it Yourself >> Here is another example to count the number of elements of a list. Please note that we simulate lists using parallel composition : (1,2,3,5,7,11) . The main limitation of this approach is that there is no empty list. Moreover lists of only one element are represented by this element: count((x,xs)) = 1+count(xs); count(x) = 1; If we now write count(duplicate(10,666)) , the expression will be evaluated as 10 . Note that the order of pattern matching rules matters. The more specific rules must precede the more general rules. When this order is not respected, as in: count(x) = 1; count((x,xs)) = 1+count(xs); the first rule will always match and the second rule will never be called. Expressions Despite its textual syntax, Faust is conceptually a block-diagram language. Faust expressions represent DSP block-diagrams and are assembled from primitive ones using various composition operations. More traditional numerical expressions in infix notation are also possible. Additionally Faust provides time based expressions, like delays, expressions related to lexical environments, expressions to interface with foreign function and lambda expressions. Diagram Expressions Diagram expressions are assembled from primitive ones using either binary composition operations or high level iterative constructions. Diagram Composition Operations Five binary composition operations are available to combine block-diagrams: recursion ( ~ ), parallel ( , ), sequential ( : ), split ( : ), merge ( : ). One can think of each of these composition operations as a particular way to connect two block diagrams. To describe precisely how these connections are done, we have to introduce some notation. The number of inputs and outputs of a block-diagram $A$ are expressed as $\\mathrm{inputs}(A)$ and $\\mathrm{outputs}(A)$. The inputs and outputs themselves are respectively expressed as: $[0]A$, $[1]A$, $[2]A$, $\\ldots$ and $A[0]$, $A[1]$, $A[2]$, etc. For each composition operation between two block-diagrams $A$ and $B$ we will describe the connections $A[i]\\rightarrow [j]B$ that are created and the constraints on their relative numbers of inputs and outputs. The priority and associativity of this five operations are: Syntax Priority Association Description expression ~ expression 4 left Recursive Composition expression , expression 3 right Parallel Composition expression : expression 2 right Sequential Composition expression : expression 1 right Split Composition expression : expression 1 right Merge Composition Parallel Composition The parallel composition (e.g., (A,B) ) is probably the simplest one. It places the two block-diagrams one on top of the other, without connections. The inputs of the resulting block-diagram are the inputs of A and B . The outputs of the resulting block-diagram are the outputs of A and B . Parallel composition is an associative operation: (A,(B,C)) and ((A,B),C) are equivalents. When no parenthesis are used (e.g., A,B,C,D ), Faust uses right associativity and therefore builds internally the expression (A,(B,(C,D))) . This organization is important to know when using pattern matching techniques on parallel compositions. Example: Oscillators in Parallel Parallel composition can be used to put 3 oscillators of different kinds and frequencies in parallel, which will result in a Faust program with 3 outputs: import( stdfaust.lib ); process = os.osc(440),os.sawtooth(550),os.triangle(660); Try it Yourself >> Example: Stereo Effect Parallel composition can be used to easily turn a mono effect into a stereo one which will result in a Faust program with 2 inputs and 2 outputs: import( stdfaust.lib ); level = 1; process = ve.autowah(level),ve.autowah(level); Try it Yourself >> Note that there's a better to write this last example using the par iteration : import( stdfaust.lib ); level = 1; process = par(i,2,ve.autowah(level)); Try it Yourself >> Sequential Composition The sequential composition (e.g., A:B ) expects: $$\\mathrm{outputs}(A)=\\mathrm{inputs}(B)$$ It connects each output of $A$ to the corresponding input of $B$: $$A[i]\\rightarrow[i]B$$ Sequential composition is an associative operation: (A:(B:C)) and ((A:B):C) are equivalents. When no parenthesis are used, like in A:B:C:D , Faust uses right associativity and therefore builds internally the expression (A:(B:(C:D))) . Example: Sine Oscillator Since everything is considered as a signal generator in Faust, sequential composition can be simply used to pass an argument to a function: import( stdfaust.lib ); process = 440 : os.osc; Try it Yourself >> Example: Effect Chain Sequential composition can be used to create an audio effect chain. Here we're plugging a guitar distortion to an autowah: import( stdfaust.lib ); drive = 0.6; offset = 0; autoWahLevel = 1; process = ef.cubicnl(drive,offset) : ve.autowah(autoWahLevel); Try it Yourself >> Split Composition The split composition (e.g., A :B ) operator is used to distribute the outputs of $A$ to the inputs of $B$. For the operation to be valid, the number of inputs of $B$ must be a multiple of the number of outputs of $A$: $$\\mathrm{outputs}(A).k=\\mathrm{inputs}(B)$$ Each input $i$ of $B$ is connected to the output $i \\bmod k$ of $A$: $$A[i \\bmod k]\\rightarrow[i]B$$ Example: Duplicating the Output of an Oscillator Split composition can be used to duplicate signals. For example, the output of the following sawtooth oscillator is duplicated 3 times in parallel. import( stdfaust.lib ); process = os.sawtooth(440) : _,_,_; Try it Yourself >> Note that this can be written in a more effective way by replacing _,_,_ with par(i,3,_) using the par iteration . Example: Connecting a Mono Effect to a Stereo One More generally, the split composition can be used to connect a block with a certain number of output to a block with a greater number of inputs: import( stdfaust.lib ); drive = 0.6; offset = 0; process = ef.cubicnl(drive,offset) : dm.zita_light; Try it Yourself >> Note that an arbitrary number of signals can be split, for example: import( stdfaust.lib ); drive = 0.6; offset = 0; process = par(i,2,ef.cubicnl(drive,offset)) : par(i,2,dm.zita_light); Try it Yourself >> Once again, the only rule with this is that in the expression A :B the number of inputs of B has to be a multiple of the number of outputs of A . Merge Composition The merge composition (e.g., A: B ) is the dual of the split composition . The number of outputs of $A$ must be a multiple of the number of inputs of $B$: $$\\mathrm{outputs}(A)=k.\\mathrm{inputs}(B)$$ Each output $i$ of $A$ is connected to the input $i \\bmod k$ of $B$ : $$A[i]\\rightarrow\\ [i \\bmod k]B$$ The $k$ incoming signals of an input of $B$ are summed together. Example: Summing Signals Together - Additive Synthesis Merge composition can be used to sum an arbitrary number of signals together. Here's an example of a simple additive synthesizer (note that the result of the sum of the signals is divided by 3 to prevent clicking): import( stdfaust.lib ); freq = hslider( freq ,440,50,3000,0.01); gain = hslider( gain ,1,0,1,0.01); gate = button( gate ); envelope = gain*gate : si.smoo; process = os.osc(freq),os.osc(freq*2),os.osc(freq*3) : /(3)*envelope; Try it Yourself >> While the resulting block diagram will look slightly different, this is mathematically equivalent to: import( stdfaust.lib ); freq = hslider( freq ,440,50,3000,0.01); gain = hslider( gain ,1,0,1,0.01); gate = button( gate ); envelope = gain*gate : si.smoo; process = (os.osc(freq) + os.osc(freq*2) + os.osc(freq*3))/(3)*envelope; Try it Yourself >> Example: Connecting a Stereo Effect to a Mono One More generally, the merge composition can be used to connect a block with a certain number of output to a block with a smaller number of inputs: import( stdfaust.lib ); drive = 0.6; offset = 0; process = dm.zita_light : ef.cubicnl(drive,offset); Try it Yourself >> Note that an arbitrary number of signals can be split, for example: import( stdfaust.lib ); drive = 0.6; offset = 0; process = par(i,2,dm.zita_light) : par(i,2,ef.cubicnl(drive,offset)); Try it Yourself >> Once again, the only rule with this is that in the expression A: B the number of outputs of A has to be a multiple of the number of inputs of B . Recursive Composition The recursive composition (e.g., A~B ) is used to create cycles in the block-diagram in order to express recursive computations. It is the most complex operation in terms of connections. To be applicable, it requires that: $$\\mathrm{outputs}(A) \\geq \\mathrm{inputs}(B) and \\mathrm{inputs}(A) \\geq \\mathrm{outputs}(B)$$ Each input of $B$ is connected to the corresponding output of $A$ via an implicit 1-sample delay : $$A[i]\\stackrel{Z^{-1}}{\\rightarrow}[i]B$$ and each output of $B$ is connected to the corresponding input of $A$: $$B[i]\\rightarrow [i]A$$ The inputs of the resulting block diagram are the remaining unconnected inputs of $A$. The outputs are all the outputs of $A$. Example: Timer Recursive composition can be used to implement a \"timer\" that will count each sample starting at time $n=0$: process = _~+(1); Try it Yourself >> The difference equation corresponding to this program is: $$y(n) = y(n-1) + 1$$ an its output signal will look like: $(1,2,3,4,5,6,\\dots)$. Example: One Pole Filter Recursive composition can be used to implement a one pole filter with one line of code and just a few characters: a1 = 0.999; // the pole process = +~*(a1); Try it Yourself >> The difference equation corresponding to this program is: $$y(n) = x(n) + a_{1}y(n-1)$$ Note that the one sample delay of the filter is implicit here so it doesn't have to be declared. Inputs and Outputs of an Expression The number of inputs and outputs of a Faust expression can be known at compile time simply by using inputs(expression) and outputs(expression) . For example, the number of outputs of a sine wave oscillator can be known simply by writing the following program: import( stdfaust.lib ); process = outputs(os.osc(440)); Try it Yourself >> Note that Faust automatically simplified the expression by generating a program that just outputs 1 . This type of construction is useful to define high order functions and build algorithmically complex block-diagrams. Here is an example to automatically reverse the order of the outputs of an expression. Xo(expr) = expr : par(i,n,ba.selector(n-i-1,n)) with { n = outputs(expr); }; And the inputs of an expression : Xi(expr) = si.bus(n) : par(i,n,ba.selector(n-i-1,n)) : expr with { n = inputs(expr); }; For example Xi(-) will reverse the order of the two inputs of the substraction: import( stdfaust.lib ); Xi(expr) = si.bus(n) : par(i,n,ba.selector(n-i-1,n)) : expr with { n = inputs(expr); }; toto = os.osc(440),os.sawtooth(440), os.triangle(440); process = Xi(-); Try it Yourself >> Iterations Iterations are analogous to for(...) loops in other languages and provide a convenient way to automate some complex block-diagram constructions. The use and role of par , seq , sum , and prod are detailed in the following sections. par Iteration The par iteration can be used to duplicate an expression in parallel. Just like other types of iterations in Faust: its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named i in a for loop) starting at 0, its second argument is the number of iterations, its third argument is the expression to be duplicated. Example: Simple Additive Synthesizer import( stdfaust.lib ); freq = hslider( freq ,440,50,3000,0.01); gain = hslider( gain ,1,0,1,0.01); gate = button( gate ); envelope = gain*gate : si.smoo; nHarmonics = 4; process = par(i,nHarmonics,os.osc(freq*(i+1))) : /(nHarmonics)*envelope; Try it Yourself >> i is used here at each iteration to compute the value of the frequency of the current oscillator. Also, note that this example could be re-wrtitten using sum iteration (see example in the corresponding section). seq Iteration The seq iteration can be used to duplicate an expression in series. Just like other types of iterations in Faust: its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named i in a for loop) starting at 0, its second argument is the number of iterations, its third argument is the expression to be duplicated. Example: Peak Equalizer The fi.peak_eq function of the Faust libraries implements a second order \"peak equalizer\" section (gain boost or cut near some frequency). When placed in series, it can be used to implement a full peak equalizer: import( stdfaust.lib ); nBands = 8; filterBank(N) = hgroup( Filter Bank ,seq(i,N,oneBand(i))) with { oneBand(j) = vgroup( [%j]Band %a ,fi.peak_eq(l,f,b)) with { a = j+1; // just so that band numbers don't start at 0 l = vslider( [2]Level[unit:db] ,0,-70,12,0.01) : si.smoo; f = nentry( [1]Freq ,(80+(1000*8/N*(j+1)-80)),20,20000,0.01) : si.smoo; b = f/hslider( [0]Q[style:knob] ,1,1,50,0.01) : si.smoo; }; }; process = filterBank(nBands); Try it Yourself >> Note that i is used here at each iteration to compute various elements and to format some labels. Having user interface elements with different names is a way to force their differentiation in the generated interface. sum Iteration The sum iteration can be used to duplicate an expression as a sum. Just like other types of iterations in Faust: its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named i in a for loop) starting at 0, its second argument is the number of iterations, its third argument is the expression to be duplicated. Example: Simple Additive Synthesizer The following example is just a slightly different version from the one presented in the par iteration section. While their block diagrams look slightly different, the generated code is exactly the same. import( stdfaust.lib ); freq = hslider( freq ,440,50,3000,0.01); gain = hslider( gain ,1,0,1,0.01); gate = button( gate ); envelope = gain*gate : si.smoo; nHarmonics = 4; process = sum(i,nHarmonics,os.osc(freq*(i+1)))/(nHarmonics)*envelope; Try it Yourself >> i is used here at each iteration to compute the value of the frequency of the current oscillator. prod Iteration The prod iteration can be used to duplicate an expression as a product. Just like other types of iterations in Faust: its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named i in a for loop) starting at 0, its second argument is the number of iterations, its third argument is the expression to be duplicated. Example: Amplitude Modulation Synthesizer The following example implements an amplitude modulation synthesizer using an arbitrary number of oscillators thanks to the prod iteration: import( stdfaust.lib ); freq = hslider( [0]freq ,440,50,3000,0.01); gain = hslider( [1]gain ,1,0,1,0.01); shift = hslider( [2]shift ,0,0,1,0.01); gate = button( [3]gate ); envelope = gain*gate : si.smoo; nOscs = 4; process = prod(i,nOscs,os.osc(freq*(i+1+shift)))*envelope; Try it Yourself >> i is used here at each iteration to compute the value of the frequency of the current oscillator. Note that the shift parameter can be used to tune the frequency drift between each oscillator. Infix Notation and Other Syntax Extensions Infix notation is commonly used in mathematics. It consists in placing the operand between the arguments as in $2+3$ Besides its algebra-based core syntax, Faust provides some syntax extensions, in particular the familiar infix notation . For example if you want to multiply two numbers, say 2 and 3 , you can write directly 2*3 instead of the equivalent core-syntax expression 2,3 : * . The infix notation is not limited to numbers or numerical expressions. Arbitrary expressions A and B can be used, provided that A,B has exactly two outputs. For example _/2 is equivalent to _,2:/ which divides the incoming signal by 2 . Here are a few examples of equivalences: Infix Syntax Core Syntax 2-3 $\\equiv$ 2,3 : - 2*3 $\\equiv$ 2,3 : * _@7 $\\equiv$ _,7 : @ _/2 $\\equiv$ _,2 : / A B $\\equiv$ A,B : In case of doubts on the meaning of an infix expression, for example _*_ , it is useful to translate it to its core syntax equivalent, here _,_:* , which is equivalent to * . Infix Operators Built-in primitives that can be used in infix notation are called infix operators and are listed below. Please note that a more detailed description of these operators is available section on primitives . Prefix Notation Beside infix notation , it is also possible to use prefix notation . The prefix notation is the usual mathematical notation for functions $f(x,y,z,\\ldots)$, but extended to infix operators . It consists in first having the operator, for example / , followed by its arguments between parentheses: /(2,3) : Prefix Syntax Core Syntax *(2,3) $\\equiv$ 2,3 : * @(_,7) $\\equiv$ _,7 : @ /(_,2) $\\equiv$ _,2 : / (A,B) $\\equiv$ A,B : Partial Application The partial application notation is a variant of the prefix notation in which not all arguments are given. For instance /(2) (divide by 2), ^(3) (rise to the cube), and @(512) (delay by 512 samples) are examples of partial applications where only one argument is given. The result of a partial application is a function that \"waits\" for the remaining arguments. When doing partial application with an infix operator , it is important to note that the supplied argument is not the first argument, but always the second one: Prefix Partial Application Syntax Core Syntax +(C) $\\equiv$ _,C : * -(C) $\\equiv$ _,C : - (C) $\\equiv$ _,C : /(C) $\\equiv$ _,C : / For commutative operations that doesn't matter. But for non-commutative ones, it is more \"natural\" to fix the second argument. We use divide by 2 ( /(2) ) or rise to the cube ( ^(3) ) more often than the other way around. Please note that this rule only applies to infix operators, not to other primitives or functions. If you partially apply a regular function to a single argument, it will correspond to the first parameter. Example: Gain Controller The following example demonstrates the use of partial application in the context of a gain controller: gain = hslider( gain ,0.5,0,1,0.01); process = *(gain); Try it Yourself >> ' Time Expression ' is used to express a one sample delay. For example: process = _'; Try it Yourself >> will delay the incoming signal by one sample. ' time expressions can be chained, so the output signal of this program: process = 1''; Try it Yourself >> will look like: $(0,0,1,1,1,1,\\dots)$. The ' time expression is useful when designing filters, etc. and is equivalent to @(1) (see the @ Time Expression ). @ Time Expression @ is used to express a delay with an arbitrary number of samples. For example: process = @(10); Try it Yourself >> will delay the incoming signal by 10 samples. A delay expressed with @ doesn't have to be fixed but it must be positive and bounded. Therefore, the values of a slider are perfectly acceptable: process = @(hslider( delay ,0,0,100,1)); Try it Yourself >> @ only allows for the implementation of integer delay. Thus, various fractional delay algorithms are implemented in the Faust libraries . Environment Expressions Faust is a lexically scoped language. The meaning of a Faust expression is determined by its context of definition (its lexical environment) and not by its context of use. To keep their original meaning, Faust expressions are bounded to their lexical environment in structures called closures . The following constructions allow to explicitly create and access such environments. Moreover they provide powerful means to reuse existing code and promote modular design. with Expression The with construction allows to specify a local environment : a private list of definition that will be used to evaluate the left hand expression. In the following example : pink = f : + ~ g with { f(x) = 0.04957526213389*x - 0.06305581334498*x' + 0.01483220320740*x''; g(x) = 1.80116083982126*x - 0.80257737639225*x'; }; process = pink; Try it Yourself >> the definitions of f(x) and g(x) are local to f : + ~ g . Please note that with is left associative and has the lowest priority: f : + ~ g with {...} is equivalent to (f : + ~ g) with {...} . f : + ~ g with {...} with {...} is equivalent to ((f : + ~ g) with {...}) with {...} . letrec Expression The letrec construction is somehow similar to with , but for difference equations instead of regular definitions. It allows us to easily express groups of mutually recursive signals, for example: $$ x(t) = y(t-1) + 10\\ y(t) = x(t-1) - 1 $$ as E letrec { 'x = y+10; 'y = x-1; } The syntax is defined by the following rules: Note the special notation 'x = y + 10 instead of x = y' + 10 . It makes syntactically impossible to write non-sensical equations like x=x+1 . Here is a more involved example. Let say we want to define an envelope generator with an attack and a release time (as a number of samples), and a gate signal. A possible definition could be: import( stdfaust.lib ); ar(a,r,g) = v letrec { 'n = (n+1) * (g =g'); 'v = max(0, v + (n a)/a - (n =a)/r) * (g =g'); }; gate = button( gate ); process = os.osc(440)*ar(1000,1000,gate); Try it Yourself >> With the following semantics for $n(t)$ and $v(t)$: $$ n(t) = (n(t-1)+1) * (g(t) = g(t-1))\\ v(t) = max(0, v(t-1) + (n(t-1) =a(t))/r(t)) * (g(t) =g(t-1)) $$ environment Expression The environment construction allows to create an explicit environment. It is like a `with' , but without the left hand expression. It is a convenient way to group together related definitions, to isolate groups of definitions and to create a name space hierarchy. In the following example an environment construction is used to group together some constant definitions : constant = environment { pi = 3.14159; e = 2,718; ... }; The . construction allows to access the definitions of an environment (see next section). Access Expression Definitions inside an environment can be accessed using the . construction. For example constant.pi refers to the definition of pi in the constant environment defined above . Note that environments don't have to be named. We could have written directly: environment{pi = 3.14159; e = 2,718;....}.pi library Expression The library construct allows to create an environment by reading the definitions from a file. For example library(\"filters.lib\") represents the environment obtained by reading the file filters.lib . It works like import(\"miscfilter.lib\") but all the read definitions are stored in a new separate lexical environment. Individual definitions can be accessed as described in the previous paragraph. For example library(\"filters.lib\").lowpass denotes the function lowpass as defined in the file miscfilter.lib . To avoid name conflicts when importing libraries it is recommended to prefer library to import . So instead of : import( filters.lib ); ... ...lowpass.... ... }; the following will ensure an absence of conflicts : fl = library( filters.lib ); ... ...fl.lowpass.... ... }; In practice, that's how the stdfaust.lib library works. component Expression The component construction allows us to reuse a full Faust program (e.g., a .dsp file) as a simple expression. For example component(\"freeverb.dsp\") denotes the signal processor defined in file freeverb.dsp . Components can be used within expressions like in: ...component( karplus32.dsp ) : component( freeverb.dsp )... Please note that component(\"freeverb.dsp\") is equivalent to library(\"freeverb.dsp\").process . component works well in tandem with explicit substitution (see next section). Explicit Substitution Explicit substitution can be used to customize a component or any expression with a lexical environment by replacing some of its internal definitions, without having to modify it. For example we can create a customized version of component(\"freeverb.dsp\") , with a different definition of foo(x) , by writing: ...component( freeverb.dsp )[foo(x) = ...;]... }; Foreign Expressions Reference to external C functions , variables and constants can be introduced using the foreign function mechanism. ffunction An external C function is declared by indicating its name and signature as well as the required include file. The file maths.lib of the Faust distribution contains several foreign function definitions, for example the inverse hyperbolic sine function asinh : asinh = ffunction(float asinh (float), math.h , ); Foreign functions with input parameters are considered pure math functions. They are therefore considered free of side effects and called only when their parameters change (that is at the rate of the fastest parameter). Exceptions are functions with no input parameters. A typical example is the C rand() function. In this case, the compiler generates code to call the function at sample rate. Signature The signature part ( float asinh (float) in the example presented in the previous section ) describes the prototype of the C function: return type, function name, and list of parameter types. Because the name of the foreign function can possibly depend on the floating point precision in use (float, double and quad), it is possible to give a different function name for each floating point precision using a signature with up to three function names. For example in the declaration: asinh = ffunction(float asinhf|asinh|asinhl (float), math.h , ); the signature float asinhf|asinh|asinhl (float) indicates to use the function name asinhf in single precision, asinh in double precision and asinhl in long double (quad) precision. Types Only numerical functions involving simple int and float parameters are allowed currently in Faust. No vectors, tables or data structures can be passed as parameters or returned. Variables and Constants External variables and constants can also be declared with a similar syntax. In the same maths.lib file, the definition of the sampling rate constant SR and the definition of the block-size variable BS can be found: SR = min(192000.0,max(1.0,fconstant(int fSamplingFreq, math.h ))); BS = fvariable(int count, math.h ); Foreign constants are not supposed to vary. Therefore expressions involving only foreign constants are only computed once, during the initialization period. Variable are considered to vary at block speed. This means that expressions depending of external variables are computed every block. File Include In declaring foreign functions one has also to specify the include file. It allows the Faust compiler to add the corresponding #include in the generated code. Library File In declaring foreign functions one can possibly specify the library where the actual code is located. It allows the Faust compiler to (possibly) automatically link the library. Note that this feature is only used with the LLVM backend in 'libfaust' dynamic library model . Applications and Abstractions Abstractions and applications are fundamental programming constructions directly inspired by Lambda-Calculus. These constructions provide powerful ways to describe and transform block-diagrams algorithmically. Abstractions Abstractions correspond to functions definitions and allow to generalize a block-diagram by making variable some of its parts. Let's say we want to transform a stereo reverb, dm.zita_light for instance, into a mono effect. The following expression can be written (see the sections on Split Composition and Merge Composition ): _ : dm.zita_light : _ The incoming mono signal is split to feed the two input channels of the reverb, while the two output channels of the reverb are mixed together to produce the resulting mono output. Imagine now that we are interested in transforming other stereo effects. We could generalize this principle by making zita_light a variable: \\(zita_light).(_ : zita_light : _) The resulting abstraction can then be applied to transform other effects. Note that if zita_light is a perfectly valid variable name, a more neutral name would probably be easier to read like: \\(fx).(_ : fx : _) A name can be given to the abstraction and in turn use it on dm.zita_light : import( stdfaust.lib ); mono = \\(fx).(_ : fx : _); process = mono(dm.zita_light); Try it Yourself >> Or even use a more traditional, but equivalent, notation: mono(fx) = _ : fx : _; Applications Applications correspond to function calls and allow to replace the variable parts of an abstraction with the specified arguments. For example, the abstraction described in the previous section can be used to transform a stereo reverb: mono(dm.zita_light) The compiler will start by replacing mono by its definition: \\(fx).(_ : fx : _)(dm.zita_light) Replacing the variable part with the argument is called beta-reduction in Lambda-Calculus Whenever the Faust compiler find an application of an abstraction it replaces the variable part with the argument. The resulting expression is as expected: (_ : dm.zita_light : _) Pattern Matching Pattern matching rules provide an effective way to analyze and transform block-diagrams algorithmically. For example case{ (x:y) = y:x; (x) = x; } contains two rules. The first one will match a sequential expression and invert the two part. The second one will match all remaining expressions and leave it untouched. Therefore the application: case{(x:y) = y:x; (x) = x;}(reverb : harmonizer) will produce: harmonizer : freeverb Please note that patterns are evaluated before the pattern matching operation. Therefore only variables that appear free in the pattern are binding variables during pattern matching. Primitives The primitive signal processing operations represent the built-in functionalities of Faust, that is the atomic operations on signals provided by the language. All these primitives denote signal processors , in other words, functions transforming input signals into output signals . Numbers Faust considers two types of numbers: integers and floats . Integers are implemented as 32-bits integers, and floats are implemented either with a simple, double, or extended precision depending of the compiler options. Floats are available in decimal or scientific notation. Like any other Faust expression, numbers are signal processors. For example the number 0.95 is a signal processor of type $\\mathbb{S}^{0}\\rightarrow\\mathbb{S}^{1}$ that transforms an empty tuple of signals $()$ into a 1-tuple of signals $(y)$ such that $\\forall t\\in\\mathbb{N}, y(t)=0.95$. waveform Primitive The waveform primitive was designed to facilitate the use of rdtable (read table). It allows us to specify a fixed periodic signal as a list of samples. waveform has two outputs: a constant and indicating the size (as a number of samples) of the period, the periodic signal itself. For example waveform{0,1,2,3} produces two outputs: the constant signal 4 and the periodic signal $(0,1,2,3,0,1,2,3,0,1,\\dots)$. In the following example: import( stdfaust.lib ); triangleWave = waveform{0,0.5,1,0.5,0,-0.5,-1,-.5}; triangleOsc(f) = triangleWave,int(os.phasor(8,f)) : rdtable; f = hslider( freq ,440,50,2000,0.01); process = triangleOsc(f); Try it Yourself >> waveform is used to define a triangle waveform (in its most primitive form), which is then used with a rdtable controlled by a phasor to implement a triangle wave oscillator. Note that the quality of this oscillator is very low because of the low resolution of the triangle waveform. soundfile Primitive The soundfile(\"label[url:{'path1';'path2';'path3'}]\", n) primitive allows for the access a list of externally defined sound resources, described as the list of their filename, or complete paths. The soundfile(\"label[url:path]\", n) simplified syntax allows to use a single file. A soundfile has: two inputs: the sound number (as a integer between 0 and 255 checked at compilation time), and the read index in the sound (which will access the last sample of the sound if the read index is greater than the sound length) two fixed outputs: the first one is the currently accessed sound length in frames, the second one is the currently accessed sound nominal sample rate in frames several more outputs for the sound channels themselves If more outputs than the actual number of channels in the sound file are used, the audio channels will be automatically duplicated up to the wanted number of outputs (so for instance, if a stereo file is used with four output channels, the same group of two channels will be duplicated). If the soundfile cannot be loaded for whatever reason, a default sound with one channel, a length of 1024 frames and null outputs (with samples of value 0) will be used. Note also that soundfiles are entirely loaded in memory by the architecture file, so that the read index signal can access any sample. Architecture files are responsible to load the actual soundfile. The SoundUI C++ class located in the faust/gui/SoundUI.h file in the Faust repository implements the void addSoundfile(label, path, sf_zone) method, which loads the actual soundfiles using the libsndfile library, or possibly specific audio file loading code (in the case of the JUCE framework for instance), and set up the sf_zone sound memory pointers. If label is used without any url metadata, it will be considered as the soundfile pathname. Note that a special architecture file can well decide to access and use sound resources created by another means (that is, not directly loaded from a sound file). For instance a mapping between labels and sound resources defined in memory could be used, with some additional code in charge of actually setting up all sound memory pointers when void addSoundfile(label, path, sf_zone) is called by the buidUserInterface mechanism. C-Equivalent Primitives Most Faust primitives are analogous to their C counterpart but adapted to signal processing. For example + is a function of type $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ that transforms a pair of signals $(x_1,x_2)$ into a 1-tuple of signals $(y)$ such that $\\forall t\\in\\mathbb{N}, y(t)=x_{1}(t)+x_{2}(t)$. + can be used to very simply implement a mixer: process = +; Try it Yourself >> Note that this is equivalent to (see Identity Function ): process = _+_; Try it Yourself >> The function - has type $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ and transforms a pair of signals $(x_1,x_2)$ into a 1-tuple of signals $(y)$ such that $\\forall t\\in\\mathbb{N}, y(t)=x_{1}(t)-x_{2}(t)$. Be aware that the unary - only exists in a limited form. It can be used with numbers: -0.5 and variables: -myvar , but not with expressions surrounded by parenthesis, because in this case it represents a partial application. For instance, -(a*b) is a partial application. It is syntactic sugar for _,(a*b) : - . If you want to negate a complex term in parenthesis, you'll have to use 0 - (a*b) instead. Integer Number Integer numbers are of type $\\mathbb{S}^{0}\\rightarrow\\mathbb{S}^{1}$ in Faust and can be described mathematically as $y(t)=n$. Example: DC Offset of 1 process = 1; Try it Yourself >> Floating Point Number Floating point numbers are of type $\\mathbb{S}^{0}\\rightarrow\\mathbb{S}^{1}$ in Faust and can be described as $y(t)=n.m$. Example: DC Offset of 0.5 process = 0.5; Try it Yourself >> Identity Function The identity function is expressed in Faust with the _ primitive. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x(t)$ Example: a Signal Passing Through In the following example, the _ primitive is used to connect the single audio input of a Faust program to its output: process = _; Try it Yourself >> Cut Primitive The cut primitive is expressed in Faust with ! . It can be used to \"stop\"/terminate a signal. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{0}$ Mathematical Description: $\\forall x\\in\\mathbb{S},(x)\\rightarrow ()$ Example: Stopping a Signal In the following example, the ! primitive is used to stop one of two parallel signals: process = 1,2 : !,_; Try it Yourself >> int Primitive The int primitive can be used to force the cast of a signal to int. It is of type $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ and can be described mathematically as $y(t)=(int)x(t)$. This primitive is useful when declaring indices to read in a table, etc. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=(int)x(t)$ Example: Simple Cast process = 1.5 : int; Try it Yourself >> float Primitive The float primitive can be used to force the cast of a signal to float. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=(float)x(t)$ Example: Simple Cast process = 1.5 : float; Try it Yourself >> Add Primitive The + primitive can be used to add two signals together. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)+x_{2}(t)$ Example: Simple Mixer process = +; Try it Yourself >> Subtract Primitive The - primitive can be used to subtract two signals. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)-x_{2}(t)$ Example: Subtracting Two Input Signals process = -; Try it Yourself >> Multiply Primitive The * primitive can be used to multiply two signals. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)*x_{2}(t)$ Example: Multiplying a Signal by 0.5 process = *(0.5); Try it Yourself >> Divide Primitive The / primitive can be used to divide two signals. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)/{x_{2}(t)}$ Example: Dividing a Signal by 2 process = ^(2); Try it Yourself >> Power Primitive The ^ primitive can be used to raise to the power of N a signal. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)^{x_{2}(t)}$ Example: Power of Two of a Signal process = ^(2); Try it Yourself >> Modulo Primitive The % primitive can be used to take the modulo of a signal. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)\\%{x_{2}(t)}$ Example: Phaser The following example uses a counter and the % primitive to implement a basic phaser: process = _~+(1) : -(1) : %(10); Try it Yourself >> will output a signal: (0,1,2,3,4,5,6,7,8,9,0,1,2,3,4) . AND Primitive Logical AND can be expressed in Faust with the primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)\\ {x_{2}(t)}$ Example TODO OR Primitive Logical OR can be expressed in Faust with the | primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)|{x_{2}(t)}$ Example The following example will output 1 if the incoming signal is smaller than 0.5 or greater than 0.7 and 0 otherwise. Note that the result of this operation could be multiplied to another signal to create a condition. process = _ : (0.5) | (0.7); Try it Yourself >> XOR Primitive Logical XOR can be expressed in Faust with the xor primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)\\land {x_{2}(t)}$ Example process = _ : (0.5) xor (0.7); Try it Yourself >> Left Shift Primitive Left shift can be expressed in Faust with the primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) {x_{2}(t)}$ Example process = 1 2; Try it Yourself >> Right Shift Primitive Right shift can be expressed in Faust with the primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) {x_{2}(t)}$ Example process = 1 2; Try it Yourself >> Smaller Than Primitive The smaller than comparison can be expressed in Faust with the primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) {x_{2}(t)}$ Example The following code will output 1 if the input signal is smaller than 0.5 and 0 otherwise. process = (0.5); Try it Yourself >> Smaller or Equal Than Primitive The smaller or equal than comparison can be expressed in Faust with the = primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) = {x_{2}(t)}$ Example The following code will output 1 if the input signal is smaller or equal than 0.5 and 0 otherwise. process = =(0.5); Try it Yourself >> Greater Than Primitive The greater than comparison can be expressed in Faust with the primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) {x_{2}(t)}$ Example The following code will output 1 if the input signal is greater than 0.5 and 0 otherwise. process = (0.5); Try it Yourself >> Greater or Equal Than Primitive The greater or equal than comparison can be expressed in Faust with the = primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) = {x_{2}(t)}$ Example The following code will output 1 if the input signal is greater or equal than 0.5 and 0 otherwise. process = =(0.5); Try it Yourself >> Equal to Primitive The equal to comparison can be expressed in Faust with the == primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) == {x_{2}(t)}$ Example process = 0 == 1; Try it Yourself >> Different Than Primitive The different than comparison can be expressed in Faust with the != primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) != {x_{2}(t)}$ Example process = 0 != 1; Try it Yourself >> math.h -Equivalent Primitives Most of the C math.h functions are also built-in as primitives (the others are defined as external functions in file math.lib ). acos Primitive Arc cosine can be expressed as acos in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{acosf}(x(t))$ Example process = 0.1 : acos; Try it Yourself >> asin Primitive Arc sine can be expressed as asin in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{asinf}(x(t))$ Example process = 0.1 : asin; Try it Yourself >> atan Primitive Arc tangent can be expressed as atan in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{atanf}(x(t))$ Example process = 0.1 : atan; Try it Yourself >> atan2 Primitive The arc tangent of 2 signals can be expressed as atan2 in Faust. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{atan2f}(x_{1}(t), x_{2}(t))$ Example process = 0.1,-0.1 : atan2; Try it Yourself >> cos Primitive Cosine can be expressed as cos in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{cosf}(x(t))$ Example process = 0.1 : cos; Try it Yourself >> sin Primitive Sine can be expressed as sin in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{sinf}(x(t))$ Example process = 0.1 : sin; Try it Yourself >> tan Primitive Tangent can be expressed as tan in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{tanf}(x(t))$ Example process = 0.1 : tan; Try it Yourself >> exp Primitive Base-e exponential can be expressed as exp in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{expf}(x(t))$ Example process = 0.1 : exp; Try it Yourself >> log Primitive Base-e logarithm can be expressed as log in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{logf}(x(t))$ Example process = 0.1 : log; Try it Yourself >> log10 Primitive Base-10 logarithm can be expressed as log10 in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{log10}(x(t))$ Example process = 0.1 : log10; Try it Yourself >> pow Primitive Power can be expressed as pow in Faust. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{powf}(x_{1}(t),x_{2}(t))$ Example process = 2,4 : pow; Try it Yourself >> sqrt Primitive Square root can be expressed as sqrt in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{sqrtf}(x(t))$ Example process = 4 : sqrt; Try it Yourself >> abs Primitive Absolute value can be expressed as abs in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{abs}(x(t))$ (int) or $y(t)=\\mathrm{fabsf}(x(t))$ (float) Example process = -0.5 : abs; Try it Yourself >> min Primitive Minimum can be expressed as min in Faust. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{min}(x_{1}(t),x_{2}(t))$ Example process = -0.5,0.2 : min; Try it Yourself >> max Primitive Maximum can be expressed as max in Faust. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{max}(x_{1}(t),x_{2}(t))$ Example process = -0.5,0.2 : max; Try it Yourself >> fmod Primitive Float modulo can be expressed as fmod in Faust. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{fmodf}(x_{1}(t),x_{2}(t))$ Example process = 5.3,2 : fmod; Try it Yourself >> remainder Primitive Float remainder can be expressed as remainder in Faust. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{remainderf}(x_{1}(t),x_{2}(t))$ Example process = 5.3,2 : remainder; Try it Yourself >> floor Primitive Largest int can be expressed as floor in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $\\leq$: $y(t)=\\mathrm{floorf}(x(t))$ Example process = 3.6 : floor; Try it Yourself >> ceil Primitive Smallest int can be expressed as ceil in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $\\geq$: $y(t)=\\mathrm{ceilf}(x(t))$ Example process = 3.6 : ceil; Try it Yourself >> rint Primitive Closest int can be expressed as rint in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{rintf}(x(t))$ Example process = 3.6 : rint; Try it Yourself >> Delay Primitives and Modifiers Faust hosts various modifiers and primitives to define one sample or integer delay of arbitrary length. They are presented in this section. mem Primitive A 1 sample delay can be expressed as mem in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t+1)=x(t),y(0)=0$ Example process = mem; Try it Yourself >> Note that this is equivalent to process = _' (see ' Modifier ) and process = @(1) (see @ Primitive ) ' Modifier ' can be used to apply a 1 sample delay to a signal in Faust. It can be seen as syntactic sugar to the mem primitive . ' is very convenient when implementing filters and can help significantly decrease the size of the Faust code. Example process = _'; Try it Yourself >> @ Primitive An integer delay of N samples can be expressed as @(N) in Faust. Note that N can be dynamic but that its range must be bounded. This can be done by using a UI primitive (see example below) allowing for the definition of a range such as hslider , vslider , or nentry . Note that floating point delay is also available in Faust by the mean of various fractional delay implementations available in the Faust standard libraries. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t+x_{2}(t))=x_{1}(t), y(t x_{2}(t))=0$ Usage _ : @(N) : _ Where: N : the length of the delay as a number of samples Example: Static N Samples Delay N = 10; process = @(N); Try it Yourself >> Example: Dynamic N Samples Delay N = hslider( N ,10,1,10,1); process = @(N); Try it Yourself >> Table Primitives TODO rdtable Primitive The rdtable primitive can be used to read through a read-only (pre-defined before compilation) table. The table can either be implemented using a function controlled by a timer (such as ba.time ) as demonstrated in the first example, or by using the waveform primitive (as shown in the second example). The idea is that the table is parsed during the initialization step and before audio computation begins. Type: $\\mathbb{S}^{3}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=T[r(t)]$ Usage rdtable(n,s,r) : _ Where: n : the table size s : the table content r : the read index (an int between 0 and n-1 ) Example: Basic Triangle Wave Oscillator Using the waveform Primitive In this example, a basic (and dirty) triangle wave-table is defined using the waveform . It is then used with the rdtable primitive and a phasor to implement a triangle wave oscillator. Note that the output of import( stdfaust.lib ); triangleWave = waveform{0,0.5,1,0.5,0,-0.5,-1,-.5}; triangleOsc(f) = triangleWave,int(os.phasor(8,f)) : rdtable; f = hslider( freq ,440,50,2000,0.01); process = triangleOsc(f); Try it Yourself >> Example: Basic Triangle Wave Oscillator Using the waveform Primitive In this example, a sine table is implemented using the sin primitive and a timer ( ba.time ). The timer parses the sin function during the initialization step of the Faust program. It is then used with rdtable to implement a sine wave oscillator. import( stdfaust.lib ); sineWave(tablesize) = float(ba.time)*(2.0*ma.PI)/float(tablesize) : sin; tableSize = 1 16; triangleOsc(f) = tableSize,sineWave(tableSize),int(os.phasor(tableSize,f)) : rdtable; f = hslider( freq ,440,50,2000,0.01); process = triangleOsc(f); Try it Yourself >> rwtable Primitive The rwtable primitive can be used to implement a read/write table. It takes an audio input that can be written in the table using a record index (i.e., w below) and read using a read index (i.e., r below). Type: $\\mathbb{S}^{5}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $T[w(t)]=c(t); y(t)=T[r(t)]$ Usage _ : rwtable(n,s,w,_,r) : _ Where: n : the table size s : the initial table content w : the write index (an int between 0 and n-1 ) r : the read index (an int between 0 and n-1 ) Note that the fourth argument of rwtable corresponds to the input of the table. Example: Simple Looper In this example, an input signal is written in the table when record is true (equal to 1). The read index is constantly updated to loop through the table. The table size is set to 48000, which corresponds to one second if the sampling rate is 48000 KHz. import( stdfaust.lib ); tableSize = 48000; recIndex = (+(1) : %(tableSize)) ~ *(record); readIndex = readSpeed/float(ma.SR) : (+ : ma.decimal) ~ _ : *(float(tableSize)) : int; readSpeed = hslider( [0]Read Speed ,1,0.001,10,0.01); record = button( [1]Record ) : int; looper = rwtable(tableSize,0.0,recIndex,_,readIndex); process = looper; Try it Yourself >> Selector Primitives Selector primitives can be used to create conditions in Faust and to implement switches to choose between several signals. Note that selector primitives optimize the code generated by the Faust compiler by only computing the selected signal. select2 Primitives The select2 primitive is a \"two-ways selector\" that can be used to select between 2 signals. Type: $\\mathbb{S}^{3}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $T[]={x_{0}(t),x_{1}(t)}; y(t)=T[s(t)]$ Usage _,_ : select2(s) : _,_ Where: s : the selector ( 0 for the first signal, 1 for the second one) Example: Signal Selector The following example allows the user to choose between a sine and a sawtooth wave oscillator. import( stdfaust.lib ); s = nentry( Selector ,0,0,1,1); sig = os.osc(440),os.sawtooth(440) : select2(s); process = sig; Try it Yourself >> Note that select2 could be easily implemented from scratch in Faust using Boolean primitives: import( stdfaust.lib ); s = nentry( Selector ,0,0,1,1); mySelect2(s) = *(s==0),*(s==1) : _; sig = os.osc(440),os.sawtooth(440) : mySelect2(s); process = sig; Try it Yourself >> While the behavior of this last solution is identical to the first one, the generated code will be less optimized as the sine and the sawtooth waves will both be computed all the time. select3 Primitives The select3 primitive is a \"three-ways selector\" that can be used to select between 3 signals. Type: $\\mathbb{S}^{4}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $T[]={x_{0}(t),x_{1}(t),x_{2}(t)}; y(t)=T[s(t)]$ Usage _,_,_ : select3(s) : _,_,_ Where: s : the selector ( 0 for the first signal, 1 for the second one, 2 for the third one) Example: Signal Selector The following example allows the user to choose between a sine, a sawtooth and a triangle wave oscillator. import( stdfaust.lib ); s = nentry( Selector ,0,0,1,1); sig = os.osc(440),os.sawtooth(440),os.triangle(440) : select3(s); process = sig; Try it Yourself >> Note that select3 could be easily implemented from scratch in Faust using Boolean primitives: import( stdfaust.lib ); s = nentry( Selector ,0,0,2,1); mySelect3(s) = *(s==0),*(s==1),*(s==2) : _; sig = os.osc(440),os.sawtooth(440),os.triangle(440) : mySelect3(s); process = sig; Try it Yourself >> While the behavior of this last solution is identical to the first one, the generated code will be less optimized as the sine, the sawtooth and the triangle waves will all be computed all the time. User Interface Primitives and Configuration Faust user interface widgets/primitives allow for an abstract description of a user interface from within the Faust code. This description is independent from any GUI toolkits/frameworks and is purely abstract. Widgets can be discrete (e.g., button , checkbox , etc.), continuous (e.g., hslider , vslider , nentry ), and organizational (e.g., vgroup , hgroup ). Discrete and continuous elements are signal generators. For example, a button produces a signal which is 1 when the button is pressed and 0 otherwise: These signals can be freely combined with other audio signals. In fact, the following code is perfectly valid and will generate sound: process = button( DC ); Try it Yourself >> Each primitive implements a specific UI element, but their appearance can also be completely modified using metadata (a little bit like HTML and CSS in the web). Therefore, hslider , vslider , and nentry ) can for example be turned into a knob, a dropdown menu, etc. This concept is further developed in the section on UI metadata . Continuous UI elements (i.e., hslider , vslider , and nentry ) must all declare a range for the parameter they're controlling. In some cases, this range is used during compilation to allocate memory and will impact the generated code. For example, in the case of: process = @(hslider( N ,1,1,10,1)); Try it Yourself >> a buffer of 10 samples will be allocated for the delay implemented with the @ primitive while 20 samples will be allocated in the following example: process = @(hslider( N ,1,1,20,1)); Try it Yourself >> button Primitive The button primitive implements a button. Usage button( label ) : _ Where: label : the label (expressed as a string) of the element in the interface Example: Trigger import( stdfaust.lib ); process = no.noise*button( gate ); Try it Yourself >> checkbox Primitive The checkbox primitive implements a checkbox/toggle. Usage checkbox( label ) : _ Where: label : the label (expressed as a string) of the element in the interface Example: Trigger import( stdfaust.lib ); process = no.noise*checkbox( gate ); Try it Yourself >> hslider Primitive The hslider primitive implements a horizontal slider. Usage hslider( label ,init,min,max,step) : _ Where: label : the label (expressed as a string) of the element in the interface init : the initial value of the slider min : the minimum value of the slider max : the maximum value of the slider step : the precision (step) of the slider (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.) Example: Gain Control gain = hslider( gain ,0,0,1,0.01); process = *(gain); Try it Yourself >> vslider Primitive The vslider primitive implements a vertical slider. Usage vslider( label ,init,min,max,step) : _ Where: label : the label (expressed as a string) of the element in the interface init : the initial value of the slider min : the minimum value of the slider max : the maximum value of the slider step : the precision (step) of the slider (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.) Example gain = vslider( gain ,0,0,1,0.01); process = *(gain); Try it Yourself >> nentry Primitive The nentry primitive implements a \"numerical entry\". Usage nentry( label ,init,min,max,step) : _ Where: label : the label (expressed as a string) of the element in the interface init : the initial value of the numerical entry min : the minimum value of the numerical entry max : the maximum value of the numerical entry step : the precision (step) of the numerical entry (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.) Example gain = nentry( gain ,0,0,1,0.01); process = *(gain); Try it Yourself >> hgroup Primitive The hgroup primitive implements a horizontal group. A group contains other UI elements that can also be groups. hgroup is not a signal processor per se and is just a way to label/delimitate part of a Faust code. Usage hgroup( label ,x) Where: label : the label (expressed as a string) of the element in the interface x : the encapsulated/labeled Faust code Example In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group. import( stdfaust.lib ); freq = vslider( freq ,440,50,1000,0.1); gain = vslider( gain ,0,0,1,0.01); process = hgroup( Oscillator ,os.sawtooth(freq)*gain); Try it Yourself >> Note that the Oscillator group can be placed in a function in case we'd like to add elements to it multiple times. import( stdfaust.lib ); oscGroup(x) = hgroup( Oscillator ,x); freq = oscGroup(vslider( freq ,440,50,1000,0.1)); gain = oscGroup(vslider( gain ,0,0,1,0.01)); process = os.sawtooth(freq)*gain; Try it Yourself >> vgroup Primitive The vgroup primitive implements a vertical group. A group contains other UI elements that can also be groups. vgroup is not a signal processor per se and is just a way to label/delimitate part of a Faust code. Usage vgroup( label ,x) Where: label : the label (expressed as a string) of the element in the interface x : the encapsulated/labeled Faust code Example In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group. import( stdfaust.lib ); freq = hslider( freq ,440,50,1000,0.1); gain = hslider( gain ,0,0,1,0.01); process = vgroup( Oscillator ,os.sawtooth(freq)*gain); Try it Yourself >> Note that the Oscillator group can be placed in a function in case we'd like to add elements to it multiple times. import( stdfaust.lib ); oscGroup(x) = vgroup( Oscillator ,x); freq = oscGroup(hslider( freq ,440,50,1000,0.1)); gain = oscGroup(hslider( gain ,0,0,1,0.01)); process = os.sawtooth(freq)*gain; Try it Yourself >> tgroup Primitive The tgroup primitive implements a \"tab group.\" Tab groups can be used to group UI elements in tabs in the interface. A group contains other UI elements that can also be groups. tgroup is not a signal processor per se and is just a way to label/delimitate part of a Faust code. Usage tgroup( label ,x) Where: label : the label (expressed as a string) of the element in the interface x : the encapsulated/labeled Faust code Example In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group. import( stdfaust.lib ); freq = hslider( freq ,440,50,1000,0.1); gain = hslider( gain ,0,0,1,0.01); process = tgroup( Oscillator ,os.sawtooth(freq)*gain); Try it Yourself >> Note that the Oscillator group can be placed in a function in case we'd like to add elements to it multiple times. import( stdfaust.lib ); oscGroup(x) = tgroup( Oscillator ,x); freq = oscGroup(hslider( freq ,440,50,1000,0.1)); gain = oscGroup(hslider( gain ,0,0,1,0.01)); process = os.sawtooth(freq)*gain; Try it Yourself >> vbargraph Primitive The vbargraph primitive implements a vertical bar-graph (typically a meter displaying the level of a signal). Usage vbargraph takes an input signal and outputs it while making it available to the UI. _ : vbargraph( label ,min,max) : _ Where: min : the minimum value of the signal in the interface max : the maximum value of the signal in the interface Example: Simple VU Meter A simple VU meter can be implemented using the vbargraph primitive: import( stdfaust.lib ); process = _ : attach(_,abs : ba.linear2db : vbargraph( Level ,-60,0)); Try it Yourself >> Note the use of the attach primitive here that forces the compilation of the vbargraph without using its output signal (see section on the attach primitive ). hbargraph Primitive The hbargraph primitive implements a horizontal bar-graph (typically a meter displaying the level of a signal). Usage hbargraph takes an input signal and outputs it while making it available to the UI. _ : hbargraph( label ,min,max) : _ Where: min : the minimum value of the signal in the interface max : the maximum value of the signal in the interface Example: Simple VU Meter A simple VU meter can be implemented using the hbargraph primitive: import( stdfaust.lib ); process = _ : attach(_,abs : ba.linear2db : hbargraph( Level ,-60,0)); Try it Yourself >> Note the use of the attach primitive here that forces the compilation of the hbargraph without using its output signal (see section on the attach primitive ). attach Primitive The attach primitive takes two input signals and produces one output signal which is a copy of the first input. The role of attach is to force its second input signal to be compiled with the first one. From a mathematical standpoint attach(x,y) is equivalent to 1*x+0*y , which is in turn equivalent to x , but it tells the compiler not to optimize-out y . To illustrate this role, let's say that we want to develop a mixer application with a vumeter for each input signals. Such vumeters can be easily coded in Faust using an envelope detector connected to a bargraph. The problem is that the signal of the envelope generators has no role in the output signals. Using attach(x,vumeter(x)) one can tell the compiler that when x is compiled vumeter(x) should also be compiled. The examples in the hbargraph Primitive and the vbargraph Primitive illustrate well the use of attach . Variable Parts of a Label Labels can contain variable parts. These are indicated with the sign % followed by the name of a variable. During compilation each label is processed in order to replace the variable parts by the value of the variable. For example: process = par(i,8,hslider( Voice %i , 0.9, 0, 1, 0.01)); Try it Yourself >> creates 8 sliders in parallel with different names while par(i,8,hslider(\"Voice\", 0.9, 0, 1, 0.01)) would have created only one slider and duplicated its output 8 times. The variable part can have an optional format digit. For example \"Voice %2i\" would indicate to use two digit when inserting the value of i in the string. An escape mechanism is provided. If the sign % is followed by itself, it will be included in the resulting string. For example \"feedback (%%)\" will result in \"feedback (%)\" . Labels as Pathnames Thanks to horizontal , vertical , and tabs groups, user interfaces have a hierarchical structure analog to a hierarchical file system. Each widget has an associated path name obtained by concatenating the labels of all its surrounding groups with its own label. In the following example : hgroup( Foo , ... vgroup( Faa , ... hslider( volume ,...) ... ) ... ) the volume slider has pathname /h:Foo/v:Faa/volume . In order to give more flexibility to the design of user interfaces, it is possible to explicitly specify the absolute or relative pathname of a widget directly in its label. Elements of a path are separated using / . Group types are defined with the following identifiers: Group Type Group Identifier hgroup h: vgroup v: tgroup t: Hence, the example presented in the section on the hgroup primitive can be rewritten as: import( stdfaust.lib ); freq = vslider( h:Oscillator/freq ,440,50,1000,0.1); gain = vslider( h:Oscillator/gain ,0,0,1,0.01); process = os.sawtooth(freq)*gain; Try it Yourself >> which will be reflected in C++ as: virtual void buildUserInterface(UI* ui_interface) { ui_interface- openHorizontalBox( Oscillator ); ui_interface- addVerticalSlider( freq , fVslider1, 440.0f, 50.0f, 1000.0f, 0.100000001f); ui_interface- addVerticalSlider( gain , fVslider0, 0.0f, 0.0f, 1.0f, 0.00999999978f); ui_interface- closeBox(); } Note that path names are inherent to the use of tools gravitating around Faust such as OSC control or faust2api . In the case of faust2api , since no user interface is actually generated, UI elements just become a way to declare parameters of a Faust object. Therefore, there's no distinction between nentry , hslider , vslider , etc. Smoothing Despite the fact that the signal generated by user interface elements can be used in Faust with any other signals, UI elements run at a slower rate than the audio rate. This might be a source of clicking if the value of the corresponding parameter is modified while the program is running. This behavior is also amplified by the low resolution of signals generated by UI elements (as opposed to actual audio signals). For example, changing the value of the freq or gain parameters of the following code will likely create clicks (in the case of gain ) or abrupt jumps (in the case of freq ) in the signal: import( stdfaust.lib ); freq = hslider( freq ,440,50,1000,0.1); gain = hslider( gain ,0,0,1,0.01); process = os.osc(freq)*gain; Try it Yourself >> This problem can be easily solved in Faust by using the si.smoo function which implements an exponential smoothing by a unit-dc-gain one-pole lowpass with a pole at 0.999 ( si.smoo is just sugar for si.smooth(0.999) ). Therefore, the previous example can be rewritten as: import( stdfaust.lib ); freq = hslider( freq ,440,50,1000,0.1) : si.smoo; gain = hslider( gain ,0,0,1,0.01) : si.smoo; process = os.osc(freq)*gain; Try it Yourself >> Beware that each si.smoo that you place in your code will add some extra computation so they should be used precociously. Links to Generated Code UI elements provide a convenient entry point to the DSP process in the code generated by the Faust compiler (e.g., C++, etc.). For example, the Faust program: import( stdfaust.lib ); freq = hslider( freq ,440,50,1000,0.1); process = os.osc(freq); will have the corresponding buildUserInterface method in C++: virtual void buildUserInterface(UI* ui_interface) { ui_interface- openVerticalBox( osc ); ui_interface- addHorizontalSlider( freq , fHslider0, 440.0f, 50.0f, 1000.0f, 0.100000001f); ui_interface- closeBox(); } The second argument of the addHorizontalSlider method is a pointer to the variable containing the current value of the freq parameter. The value of this pointer can be updated at any point to change the frequency of the corresponding oscillator. UI Label Metadata Widget labels can contain metadata enclosed in square brackets. These metadata associate a key with a value and are used to provide additional information to the architecture file. They are typically used to improve the look and feel of the user interface, configure OSC and accelerometer control/mapping, etc. Since the format of the value associated to a key is relatively open, metadata constitute a flexible way for programmers to add features to the language. The Faust code: process = *(hslider( foo[key1: val 1][key2: val 2] ,0,0,1,0.1)); will produce the corresponding C++ code: class mydsp : public dsp { ... virtual void buildUserInterface(UI* ui_interface) { ui_interface- openVerticalBox( tst ); ui_interface- declare( fHslider0, key1 , val 1 ); ui_interface- declare( fHslider0, key2 , val 2 ); ui_interface- addHorizontalSlider( foo , fHslider0, 0.0f, 0.0f, 1.0f, 0.100000001f); ui_interface- closeBox(); } ... }; All metadata are removed from the label by the compiler and transformed in calls to the UI::declare() method. All these UI::declare() calls will always take place before the UI::AddSomething() call that creates the User Interface element. This allows the UI::AddSomething() method to make full use of the available metadata. Metadata are architecture-specific: it is up to the architecture file to decide what to do with it. While some metadata will work with most architectures (e.g., accelerometer and OSC configuration, etc.), others might be more specific. Some of them are presented in the following sections. Ordering UI Elements The order of UI declarations in a Faust code doesn't necessarily reflect the actual order of the UI elements in the corresponding interface. Therefore, UI elements can be ordered by placing a metadata before the declaration of the name of the UI element in the label. For example, in the following declaration: gain = vslider( h:Oscillator/[1]gain ,0,0,1,0.01); freq = vslider( h:Oscillator/[0]freq ,440,50,1000,0.1); the freq parameter will be placed before gain despite the fact that gain is declared first. This system can be used to order groups as well. Ordering will be carried out on elements at the same level. For example: import( stdfaust.lib ); freqS = vslider( h:Oscillators/h:[0]Sawtooth/[0]freq ,440,50,1000,0.1); gainS = vslider( h:Oscillators/h:[0]Sawtooth/[1]gain ,0,0,1,0.01); freqT = vslider( h:Oscillators/h:[1]Triangle/[0]freq ,440,50,1000,0.1); gainT = vslider( h:Oscillators/h:[1]Triangle/[1]gain ,0,0,1,0.01); process = os.sawtooth(freqS)*gainS + os.triangle(freqT)*gainT; Try it Yourself >> Note that this could also be written as: import( stdfaust.lib ); freqS = vslider( [0]freq ,440,50,1000,0.1); gainS = vslider( [1]gain ,0,0,1,0.01); freqT = vslider( [0]freq ,440,50,1000,0.1); gainT = vslider( [1]gain ,0,0,1,0.01); process = hgroup( Oscillators , hgroup( [0]Sawtooth ,os.sawtooth(freqS)*gainS) + hgroup( [1]Triangle ,os.triangle(freqT)*gainT) ); Try it Yourself >> Global UI Metadata Note that global user interfaces completely replacing the one defined using the standard Faust UI primitives may be declared using global metadata . This is the case of the SmartKeyboard interface for example. In the following subsections, the standard Faust UI metadata are documented. Other types of metadata (e.g., accelerometers, OSC, etc.) are documented in the sections related to these topics. [style:knob] Metadata The [style:knob] metadata turns any continuous UI element (i.e., hslider , vslider , nentry ) into a knob. Example import( stdfaust.lib ); freq = vslider( freq[style:knob] ,440,50,1000,0.1); process = os.sawtooth(freq); Try it Yourself >> [style:menu] Metadata The [style:menu] metadata turns any continuous UI element (i.e., hslider , vslider , nentry ) into a drop-down menu. Usage [style:menu{'Name0':value0;'Name1':value1}] Where: NameN : the name associated to valueN valueN : the value associated to NameN Example: Selector import( stdfaust.lib ); s = vslider( Signal[style:menu{'Noise':0;'Sawtooth':1}] ,0,0,1,1); process = select2(s,no.noise,os.sawtooth(440)); Try it Yourself >> [style:radio] Metadata The [style:radio] metadata turns a hslider or a vslider into a radio-button-menu. The orientation of the menu is determined by the type of UI element (i.e., hslider for horizontal and vslider for vertical). Usage [style:radio{'Name0':value0;'Name1':value1}] Where: NameN : the name associated to valueN valueN : the value associated to NameN Example: Selector import( stdfaust.lib ); s = vslider( Signal[style:radio{'Noise':0;'Sawtooth':1}] ,0,0,1,1); process = select2(s,no.noise,os.sawtooth(440)); Try it Yourself >> [style:led] Metadata The [style:led] metadata turns a vbargraph or a hbargraph into a blinking LED (with varying intensity). Example: Level Display import( stdfaust.lib ); process = _ : attach(_,abs : ba.linear2db : vbargraph( Level[style:led] ,-60,0)); Try it Yourself >> [style:numerical] Metadata The [style:numerical] metadata turns a vbargraph or a hbargraph into a numerical zone (thus the bargraph itself is no more displayed). Example: Level Display import( stdfaust.lib ); process = _ : attach(_,abs : ba.linear2db : vbargraph( Level[style:numerical] ,-60,0)); Try it Yourself >> [unit:dB] Metadata The [style:dB] metadata changes the unit of a vbargraph or a hbargraph to dB. This impacts its overall appearance by applying a rainbow color scheme, etc. Example: Level Display import( stdfaust.lib ); process = _ : attach(_,abs : ba.linear2db : vbargraph( Level[style:dB] ,-60,0)); Try it Yourself >> [unit:xx] Metadata The [unit:xx] metadata allows us to specify the unit of a UI element. The unit will be displayed right next to the current value of the parameter in the interface. Usage [unit:xx] Where: xx : the unit of the current parameter Example import( stdfaust.lib ); freq = vslider( freq[unit:Hz] ,440,50,1000,0.1); process = os.sawtooth(freq); Try it Yourself >> [scale:xx] Metadata The [scale:xx] metadata allows for the specification of a scale (different than the default linear one) to the parameter in the UI. [scale:log] can be used to change to scale to logarithmic and [scale:exp] to exponential. [tooltip:xx] Metadata The [tooltip:xx] metadata allows for the specification of a \"tooltip\" when the mouse hover a parameter in the interface. This is very convenient when implementing complex interfaces. Usage [tooltip:xx] Where: xx : a string to be used as a tooltip in the interface Example import( stdfaust.lib ); freq = vslider( freq[tooltip:The frequency of the oscillator] ,440,50,1000,0.1); process = os.sawtooth(freq); Try it Yourself >> [hidden:xx] Metadata The [hidden:xx] metadata can be used to hide a parameter in the interface. This is convenient when controlling a parameter with a motion sensor or OSC messages and we don't want it to be visible in the interface. This feature is commonly used when making apps for Android and iOS using faust2android or faust2ios . Compatibility iOS Android Sensors Control Metadatas Sensors control metadata can be used to map the built-in sensors of mobile devices to some of the parameters of a Faust program. Compatibility These metadatas are compatible with the following Faust targets and no additional step is required for them to be taken into account when the corresponding app is generated: faust2android faust2ios faust2smartkeyb Sensors control metadatas have five parameters and follow the following syntax: [acc: a b c d e] // for accelerometer [gyr: a b c d e] // for gyroscope They can be used in a Faust UI parameter declaration: parameter = nentry( UIparamName[acc: a b c d e] ,def,min,max,step); with: a : the accelerometer axis ( 0 : x, 1 : y, 2 : z) b : the accelerometer curve (see figure below) c : the minimum acceleration (m/s^2) d : the center acceleration (m/s^2) e : the maximum acceleration (m/s^2) def : the default/init value of the parameter min : the minimum value of the parameter max : the maximum value of the parameter step : the step of the parameter (precision) This allows for the implementation of complex linear and non-linear mappings that are summarized in this figure: For example, controlling the gain of a synthesizer using the X axis of the accelerometer can be easily done simply by writing something like: g = nentry( gain[acc: 0 0 -10 0 10] ,0.5,0,1,0.01); With this configuration, g = 0 when the device is standing vertically on its right side, g = 0.5 when the device is standing horizontally with screen facing up, and g = 1 when the device is standing vertically on its left side. Finally, in this slightly more complex mapping, g = 0 when the device is tilted on its right side and the value of g increases towards 1 when the device is tilted on its left side: g = nentry( gain[acc: 0 0 0 0 10] ,0,0,1,0.01); Complex nonlinear mappings can be implemented using this system.","title":"Faust Syntax"},{"location":"refs/syntax/#faust-syntax","text":"","title":"Faust Syntax"},{"location":"refs/syntax/#faust-program","text":"A Faust program is essentially a list of statements . These statements can be metadata declarations (either global metadata or function metadata ), imports , definitions , and documentation tags , with optional C++ style ( //... and /*...*/ ) comments. Here is a short Faust program that implements of a simple noise generator (called from the noises.lib Faust library). It exhibits various kind of statements : two global metadata declarations, an imports , a comment , and a definition . We will study later how documentation statements work: declare name Noise ; declare copyright (c)GRAME 2018 ; import( stdfaust.lib ); // noise level controlled by a slider process = no.noise * hslider( gain ,0,0,1, 0.1); Try it Yourself >> The keyword process is the equivalent of main in C/C++. Any Faust program, to be valid, must at least define process .","title":"Faust Program"},{"location":"refs/syntax/#statements","text":"The statements of a Faust program are of four kinds: metadata declarations , file imports , definitions , documentation . All statements but documentation end with a semicolon ; .","title":"Statements"},{"location":"refs/syntax/#metadata","text":"Metadata allow us to add elements which are not part of the language to Faust code. These can range to the name of a Faust program, its author, to potential compilation options or user interface element customizations. There are three different types of metadata in Faust: Global Metadata : metadata global to a Faust code Function Metadata : metadata specific to a function UI Metadata : metadata specific to a UI element Note that some Global Metadata have standard names and can be used for specific tasks. Their role is described in the Standard Metadata section.","title":"Metadata"},{"location":"refs/syntax/#global-metadata","text":"All global metadata declaration in Faust start with declare , followed by a key and a string. For example: declare name Noise ; allows us to specify the name of a Faust program in its whole. Unlike regular comments, metadata declarations will appear in the C++ code generated by the Faust compiler. A good practice is to start a Faust program with some standard declarations: declare name MyProgram ; declare author MySelf ; declare copyright MyCompany ; declare version 1.00 ; declare license BSD ;","title":"Global Metadata"},{"location":"refs/syntax/#function-metadata","text":"Metadata can be associated to a specific function. In that case, declare is followed by the name of the function, a key, and a string. For example: declare add author John Doe add = +; This is very useful when a library has several contributors and that functions potentially have different license terms, etc.","title":"Function Metadata"},{"location":"refs/syntax/#standard-metadata","text":"There exists a series of standard global metadata in Faust whose role role is described in the following table: Metadata Role declare options \"[key0:value][key1:value]\" This metadata can be used to specify various options associated to a Faust code such as the fact its polyphonic, if it should have OSC, MIDI support, etc. Specific keys usable with this metadata are described throughout this documentation. declare interface \"xxx\" Specifies an interface replacing the standard Faust UI.","title":"Standard Metadata"},{"location":"refs/syntax/#imports","text":"File imports allow us to import definitions from other source files. For example import(\"maths.lib\"); imports the definitions of the maths.lib library. The most common file to be imported is the stdfaust.lib library which gives access to all the standard Faust libraries from a single point: import( stdfaust.lib ); process = os.osc(440); // the hello world of computer music Try it Yourself >>","title":"Imports"},{"location":"refs/syntax/#documentation-tags","text":"Documentation statements are optional and typically used to control the generation of the mathematical documentation of a Faust program. This documentation system is detailed in the Mathematical Documentation chapter. In this section we essentially describe the documentation statements syntax. A documentation statement starts with an opening mdoc tag and ends with a closing /mdoc tag. Free text content, typically in Latex format, can be placed in between these two tags. Moreover, optional sub-tags can be inserted in the text content itself to require the generation, at the insertion point, of mathematical equations , graphical block-diagrams , Faust source code listing and explanation notice . The generation of the mathematical equations of a Faust expression can be requested by placing this expression between an opening equation and a closing /equation tag. The expression is evaluated within the lexical context of the Faust program. Similarly, the generation of the graphical block-diagram of a Faust expression can be requested by placing this expression between an opening diagram and a closing /diagram tag. The expression is evaluated within the lexical context of the Faust program. The metadata tags allow to reference Faust global metadatas , calling the corresponding keyword. The notice/ empty-element tag is used to generate the conventions used in the mathematical equations. The listing/ empty-element tag is used to generate the listing of the Faust program. Its three attributes mdoctags , dependencies , and distributed enable or disable respectively mdoc tags, other files dependencies and distribution of interleaved Faust code between mdoc sections.","title":"Documentation Tags"},{"location":"refs/syntax/#definitions","text":"A definition associates an identifier with an expression. Definitions are essentially a convenient shortcut avoiding to type long expressions. During compilation, more precisely during the evaluation stage, identifiers are replaced by their definitions. It is therefore always equivalent to use an identifier or directly its definition. Please note that multiple definitions of a same identifier are not allowed, unless it is a pattern matching based definition.","title":"Definitions"},{"location":"refs/syntax/#simple-definitions","text":"The syntax of a simple definition is: identifier = expression ; For example here is the definition of random , a simple pseudo-random number generator: random = +(12345) ~ *(1103515245);","title":"Simple Definitions"},{"location":"refs/syntax/#function-definitions","text":"Definitions with formal parameters correspond to functions definitions. For example the definition of linear2db , a function that converts linear values to decibels, is: linear2db(x) = 20*log10(x); Please note that this notation is only a convenient alternative to the direct use of lambda-abstractions (also called anonymous functions). The following is an equivalent definition of linear2db using a lambda-abstraction: linear2db = \\(x).(20*log10(x));","title":"Function Definitions"},{"location":"refs/syntax/#definitions-with-pattern-matching","text":"Moreover, formal parameters can also be full expressions representing patterns. This powerful mechanism allows to algorithmically create and manipulate block diagrams expressions. Let's say that you want to describe a function to duplicate an expression several times in parallel: duplicate(1,x) = x; duplicate(n,x) = x, duplicate(n-1,x); Note that this last definition is a convenient alternative to the more verbose: duplicate = case { (1,x) = x; (n,x) = x, duplicate(n-1,x); }; A use case for duplicate could be to put 5 white noise generators in parallel: import( stdfaust.lib ); duplicate(1,x) = x; duplicate(n,x) = x, duplicate(n-1,x); process = duplicate(5,no.noise); Try it Yourself >> Here is another example to count the number of elements of a list. Please note that we simulate lists using parallel composition : (1,2,3,5,7,11) . The main limitation of this approach is that there is no empty list. Moreover lists of only one element are represented by this element: count((x,xs)) = 1+count(xs); count(x) = 1; If we now write count(duplicate(10,666)) , the expression will be evaluated as 10 . Note that the order of pattern matching rules matters. The more specific rules must precede the more general rules. When this order is not respected, as in: count(x) = 1; count((x,xs)) = 1+count(xs); the first rule will always match and the second rule will never be called.","title":"Definitions with pattern matching"},{"location":"refs/syntax/#expressions","text":"Despite its textual syntax, Faust is conceptually a block-diagram language. Faust expressions represent DSP block-diagrams and are assembled from primitive ones using various composition operations. More traditional numerical expressions in infix notation are also possible. Additionally Faust provides time based expressions, like delays, expressions related to lexical environments, expressions to interface with foreign function and lambda expressions.","title":"Expressions"},{"location":"refs/syntax/#diagram-expressions","text":"Diagram expressions are assembled from primitive ones using either binary composition operations or high level iterative constructions.","title":"Diagram Expressions"},{"location":"refs/syntax/#diagram-composition-operations","text":"Five binary composition operations are available to combine block-diagrams: recursion ( ~ ), parallel ( , ), sequential ( : ), split ( : ), merge ( : ). One can think of each of these composition operations as a particular way to connect two block diagrams. To describe precisely how these connections are done, we have to introduce some notation. The number of inputs and outputs of a block-diagram $A$ are expressed as $\\mathrm{inputs}(A)$ and $\\mathrm{outputs}(A)$. The inputs and outputs themselves are respectively expressed as: $[0]A$, $[1]A$, $[2]A$, $\\ldots$ and $A[0]$, $A[1]$, $A[2]$, etc. For each composition operation between two block-diagrams $A$ and $B$ we will describe the connections $A[i]\\rightarrow [j]B$ that are created and the constraints on their relative numbers of inputs and outputs. The priority and associativity of this five operations are: Syntax Priority Association Description expression ~ expression 4 left Recursive Composition expression , expression 3 right Parallel Composition expression : expression 2 right Sequential Composition expression : expression 1 right Split Composition expression : expression 1 right Merge Composition","title":"Diagram Composition Operations"},{"location":"refs/syntax/#parallel-composition","text":"The parallel composition (e.g., (A,B) ) is probably the simplest one. It places the two block-diagrams one on top of the other, without connections. The inputs of the resulting block-diagram are the inputs of A and B . The outputs of the resulting block-diagram are the outputs of A and B . Parallel composition is an associative operation: (A,(B,C)) and ((A,B),C) are equivalents. When no parenthesis are used (e.g., A,B,C,D ), Faust uses right associativity and therefore builds internally the expression (A,(B,(C,D))) . This organization is important to know when using pattern matching techniques on parallel compositions. Example: Oscillators in Parallel Parallel composition can be used to put 3 oscillators of different kinds and frequencies in parallel, which will result in a Faust program with 3 outputs: import( stdfaust.lib ); process = os.osc(440),os.sawtooth(550),os.triangle(660); Try it Yourself >> Example: Stereo Effect Parallel composition can be used to easily turn a mono effect into a stereo one which will result in a Faust program with 2 inputs and 2 outputs: import( stdfaust.lib ); level = 1; process = ve.autowah(level),ve.autowah(level); Try it Yourself >> Note that there's a better to write this last example using the par iteration : import( stdfaust.lib ); level = 1; process = par(i,2,ve.autowah(level)); Try it Yourself >>","title":"Parallel Composition"},{"location":"refs/syntax/#sequential-composition","text":"The sequential composition (e.g., A:B ) expects: $$\\mathrm{outputs}(A)=\\mathrm{inputs}(B)$$ It connects each output of $A$ to the corresponding input of $B$: $$A[i]\\rightarrow[i]B$$ Sequential composition is an associative operation: (A:(B:C)) and ((A:B):C) are equivalents. When no parenthesis are used, like in A:B:C:D , Faust uses right associativity and therefore builds internally the expression (A:(B:(C:D))) . Example: Sine Oscillator Since everything is considered as a signal generator in Faust, sequential composition can be simply used to pass an argument to a function: import( stdfaust.lib ); process = 440 : os.osc; Try it Yourself >> Example: Effect Chain Sequential composition can be used to create an audio effect chain. Here we're plugging a guitar distortion to an autowah: import( stdfaust.lib ); drive = 0.6; offset = 0; autoWahLevel = 1; process = ef.cubicnl(drive,offset) : ve.autowah(autoWahLevel); Try it Yourself >>","title":"Sequential Composition"},{"location":"refs/syntax/#split-composition","text":"The split composition (e.g., A :B ) operator is used to distribute the outputs of $A$ to the inputs of $B$. For the operation to be valid, the number of inputs of $B$ must be a multiple of the number of outputs of $A$: $$\\mathrm{outputs}(A).k=\\mathrm{inputs}(B)$$ Each input $i$ of $B$ is connected to the output $i \\bmod k$ of $A$: $$A[i \\bmod k]\\rightarrow[i]B$$ Example: Duplicating the Output of an Oscillator Split composition can be used to duplicate signals. For example, the output of the following sawtooth oscillator is duplicated 3 times in parallel. import( stdfaust.lib ); process = os.sawtooth(440) : _,_,_; Try it Yourself >> Note that this can be written in a more effective way by replacing _,_,_ with par(i,3,_) using the par iteration . Example: Connecting a Mono Effect to a Stereo One More generally, the split composition can be used to connect a block with a certain number of output to a block with a greater number of inputs: import( stdfaust.lib ); drive = 0.6; offset = 0; process = ef.cubicnl(drive,offset) : dm.zita_light; Try it Yourself >> Note that an arbitrary number of signals can be split, for example: import( stdfaust.lib ); drive = 0.6; offset = 0; process = par(i,2,ef.cubicnl(drive,offset)) : par(i,2,dm.zita_light); Try it Yourself >> Once again, the only rule with this is that in the expression A :B the number of inputs of B has to be a multiple of the number of outputs of A .","title":"Split Composition"},{"location":"refs/syntax/#merge-composition","text":"The merge composition (e.g., A: B ) is the dual of the split composition . The number of outputs of $A$ must be a multiple of the number of inputs of $B$: $$\\mathrm{outputs}(A)=k.\\mathrm{inputs}(B)$$ Each output $i$ of $A$ is connected to the input $i \\bmod k$ of $B$ : $$A[i]\\rightarrow\\ [i \\bmod k]B$$ The $k$ incoming signals of an input of $B$ are summed together. Example: Summing Signals Together - Additive Synthesis Merge composition can be used to sum an arbitrary number of signals together. Here's an example of a simple additive synthesizer (note that the result of the sum of the signals is divided by 3 to prevent clicking): import( stdfaust.lib ); freq = hslider( freq ,440,50,3000,0.01); gain = hslider( gain ,1,0,1,0.01); gate = button( gate ); envelope = gain*gate : si.smoo; process = os.osc(freq),os.osc(freq*2),os.osc(freq*3) : /(3)*envelope; Try it Yourself >> While the resulting block diagram will look slightly different, this is mathematically equivalent to: import( stdfaust.lib ); freq = hslider( freq ,440,50,3000,0.01); gain = hslider( gain ,1,0,1,0.01); gate = button( gate ); envelope = gain*gate : si.smoo; process = (os.osc(freq) + os.osc(freq*2) + os.osc(freq*3))/(3)*envelope; Try it Yourself >> Example: Connecting a Stereo Effect to a Mono One More generally, the merge composition can be used to connect a block with a certain number of output to a block with a smaller number of inputs: import( stdfaust.lib ); drive = 0.6; offset = 0; process = dm.zita_light : ef.cubicnl(drive,offset); Try it Yourself >> Note that an arbitrary number of signals can be split, for example: import( stdfaust.lib ); drive = 0.6; offset = 0; process = par(i,2,dm.zita_light) : par(i,2,ef.cubicnl(drive,offset)); Try it Yourself >> Once again, the only rule with this is that in the expression A: B the number of outputs of A has to be a multiple of the number of inputs of B .","title":"Merge Composition"},{"location":"refs/syntax/#recursive-composition","text":"The recursive composition (e.g., A~B ) is used to create cycles in the block-diagram in order to express recursive computations. It is the most complex operation in terms of connections. To be applicable, it requires that: $$\\mathrm{outputs}(A) \\geq \\mathrm{inputs}(B) and \\mathrm{inputs}(A) \\geq \\mathrm{outputs}(B)$$ Each input of $B$ is connected to the corresponding output of $A$ via an implicit 1-sample delay : $$A[i]\\stackrel{Z^{-1}}{\\rightarrow}[i]B$$ and each output of $B$ is connected to the corresponding input of $A$: $$B[i]\\rightarrow [i]A$$ The inputs of the resulting block diagram are the remaining unconnected inputs of $A$. The outputs are all the outputs of $A$. Example: Timer Recursive composition can be used to implement a \"timer\" that will count each sample starting at time $n=0$: process = _~+(1); Try it Yourself >> The difference equation corresponding to this program is: $$y(n) = y(n-1) + 1$$ an its output signal will look like: $(1,2,3,4,5,6,\\dots)$. Example: One Pole Filter Recursive composition can be used to implement a one pole filter with one line of code and just a few characters: a1 = 0.999; // the pole process = +~*(a1); Try it Yourself >> The difference equation corresponding to this program is: $$y(n) = x(n) + a_{1}y(n-1)$$ Note that the one sample delay of the filter is implicit here so it doesn't have to be declared.","title":"Recursive Composition"},{"location":"refs/syntax/#inputs-and-outputs-of-an-expression","text":"The number of inputs and outputs of a Faust expression can be known at compile time simply by using inputs(expression) and outputs(expression) . For example, the number of outputs of a sine wave oscillator can be known simply by writing the following program: import( stdfaust.lib ); process = outputs(os.osc(440)); Try it Yourself >> Note that Faust automatically simplified the expression by generating a program that just outputs 1 . This type of construction is useful to define high order functions and build algorithmically complex block-diagrams. Here is an example to automatically reverse the order of the outputs of an expression. Xo(expr) = expr : par(i,n,ba.selector(n-i-1,n)) with { n = outputs(expr); }; And the inputs of an expression : Xi(expr) = si.bus(n) : par(i,n,ba.selector(n-i-1,n)) : expr with { n = inputs(expr); }; For example Xi(-) will reverse the order of the two inputs of the substraction: import( stdfaust.lib ); Xi(expr) = si.bus(n) : par(i,n,ba.selector(n-i-1,n)) : expr with { n = inputs(expr); }; toto = os.osc(440),os.sawtooth(440), os.triangle(440); process = Xi(-); Try it Yourself >>","title":"Inputs and Outputs of an Expression"},{"location":"refs/syntax/#iterations","text":"Iterations are analogous to for(...) loops in other languages and provide a convenient way to automate some complex block-diagram constructions. The use and role of par , seq , sum , and prod are detailed in the following sections.","title":"Iterations"},{"location":"refs/syntax/#par-iteration","text":"The par iteration can be used to duplicate an expression in parallel. Just like other types of iterations in Faust: its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named i in a for loop) starting at 0, its second argument is the number of iterations, its third argument is the expression to be duplicated. Example: Simple Additive Synthesizer import( stdfaust.lib ); freq = hslider( freq ,440,50,3000,0.01); gain = hslider( gain ,1,0,1,0.01); gate = button( gate ); envelope = gain*gate : si.smoo; nHarmonics = 4; process = par(i,nHarmonics,os.osc(freq*(i+1))) : /(nHarmonics)*envelope; Try it Yourself >> i is used here at each iteration to compute the value of the frequency of the current oscillator. Also, note that this example could be re-wrtitten using sum iteration (see example in the corresponding section).","title":"par Iteration"},{"location":"refs/syntax/#seq-iteration","text":"The seq iteration can be used to duplicate an expression in series. Just like other types of iterations in Faust: its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named i in a for loop) starting at 0, its second argument is the number of iterations, its third argument is the expression to be duplicated. Example: Peak Equalizer The fi.peak_eq function of the Faust libraries implements a second order \"peak equalizer\" section (gain boost or cut near some frequency). When placed in series, it can be used to implement a full peak equalizer: import( stdfaust.lib ); nBands = 8; filterBank(N) = hgroup( Filter Bank ,seq(i,N,oneBand(i))) with { oneBand(j) = vgroup( [%j]Band %a ,fi.peak_eq(l,f,b)) with { a = j+1; // just so that band numbers don't start at 0 l = vslider( [2]Level[unit:db] ,0,-70,12,0.01) : si.smoo; f = nentry( [1]Freq ,(80+(1000*8/N*(j+1)-80)),20,20000,0.01) : si.smoo; b = f/hslider( [0]Q[style:knob] ,1,1,50,0.01) : si.smoo; }; }; process = filterBank(nBands); Try it Yourself >> Note that i is used here at each iteration to compute various elements and to format some labels. Having user interface elements with different names is a way to force their differentiation in the generated interface.","title":"seq Iteration"},{"location":"refs/syntax/#sum-iteration","text":"The sum iteration can be used to duplicate an expression as a sum. Just like other types of iterations in Faust: its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named i in a for loop) starting at 0, its second argument is the number of iterations, its third argument is the expression to be duplicated. Example: Simple Additive Synthesizer The following example is just a slightly different version from the one presented in the par iteration section. While their block diagrams look slightly different, the generated code is exactly the same. import( stdfaust.lib ); freq = hslider( freq ,440,50,3000,0.01); gain = hslider( gain ,1,0,1,0.01); gate = button( gate ); envelope = gain*gate : si.smoo; nHarmonics = 4; process = sum(i,nHarmonics,os.osc(freq*(i+1)))/(nHarmonics)*envelope; Try it Yourself >> i is used here at each iteration to compute the value of the frequency of the current oscillator.","title":"sum Iteration"},{"location":"refs/syntax/#prod-iteration","text":"The prod iteration can be used to duplicate an expression as a product. Just like other types of iterations in Faust: its first argument is a variable name containing the number of the current iteration (a bit like the variable that is usually named i in a for loop) starting at 0, its second argument is the number of iterations, its third argument is the expression to be duplicated. Example: Amplitude Modulation Synthesizer The following example implements an amplitude modulation synthesizer using an arbitrary number of oscillators thanks to the prod iteration: import( stdfaust.lib ); freq = hslider( [0]freq ,440,50,3000,0.01); gain = hslider( [1]gain ,1,0,1,0.01); shift = hslider( [2]shift ,0,0,1,0.01); gate = button( [3]gate ); envelope = gain*gate : si.smoo; nOscs = 4; process = prod(i,nOscs,os.osc(freq*(i+1+shift)))*envelope; Try it Yourself >> i is used here at each iteration to compute the value of the frequency of the current oscillator. Note that the shift parameter can be used to tune the frequency drift between each oscillator.","title":"prod Iteration"},{"location":"refs/syntax/#infix-notation-and-other-syntax-extensions","text":"Infix notation is commonly used in mathematics. It consists in placing the operand between the arguments as in $2+3$ Besides its algebra-based core syntax, Faust provides some syntax extensions, in particular the familiar infix notation . For example if you want to multiply two numbers, say 2 and 3 , you can write directly 2*3 instead of the equivalent core-syntax expression 2,3 : * . The infix notation is not limited to numbers or numerical expressions. Arbitrary expressions A and B can be used, provided that A,B has exactly two outputs. For example _/2 is equivalent to _,2:/ which divides the incoming signal by 2 . Here are a few examples of equivalences: Infix Syntax Core Syntax 2-3 $\\equiv$ 2,3 : - 2*3 $\\equiv$ 2,3 : * _@7 $\\equiv$ _,7 : @ _/2 $\\equiv$ _,2 : / A B $\\equiv$ A,B : In case of doubts on the meaning of an infix expression, for example _*_ , it is useful to translate it to its core syntax equivalent, here _,_:* , which is equivalent to * .","title":"Infix Notation and Other Syntax Extensions"},{"location":"refs/syntax/#infix-operators","text":"Built-in primitives that can be used in infix notation are called infix operators and are listed below. Please note that a more detailed description of these operators is available section on primitives .","title":"Infix Operators"},{"location":"refs/syntax/#prefix-notation","text":"Beside infix notation , it is also possible to use prefix notation . The prefix notation is the usual mathematical notation for functions $f(x,y,z,\\ldots)$, but extended to infix operators . It consists in first having the operator, for example / , followed by its arguments between parentheses: /(2,3) : Prefix Syntax Core Syntax *(2,3) $\\equiv$ 2,3 : * @(_,7) $\\equiv$ _,7 : @ /(_,2) $\\equiv$ _,2 : / (A,B) $\\equiv$ A,B :","title":"Prefix Notation"},{"location":"refs/syntax/#partial-application","text":"The partial application notation is a variant of the prefix notation in which not all arguments are given. For instance /(2) (divide by 2), ^(3) (rise to the cube), and @(512) (delay by 512 samples) are examples of partial applications where only one argument is given. The result of a partial application is a function that \"waits\" for the remaining arguments. When doing partial application with an infix operator , it is important to note that the supplied argument is not the first argument, but always the second one: Prefix Partial Application Syntax Core Syntax +(C) $\\equiv$ _,C : * -(C) $\\equiv$ _,C : - (C) $\\equiv$ _,C : /(C) $\\equiv$ _,C : / For commutative operations that doesn't matter. But for non-commutative ones, it is more \"natural\" to fix the second argument. We use divide by 2 ( /(2) ) or rise to the cube ( ^(3) ) more often than the other way around. Please note that this rule only applies to infix operators, not to other primitives or functions. If you partially apply a regular function to a single argument, it will correspond to the first parameter. Example: Gain Controller The following example demonstrates the use of partial application in the context of a gain controller: gain = hslider( gain ,0.5,0,1,0.01); process = *(gain); Try it Yourself >>","title":"Partial Application"},{"location":"refs/syntax/#time-expression","text":"' is used to express a one sample delay. For example: process = _'; Try it Yourself >> will delay the incoming signal by one sample. ' time expressions can be chained, so the output signal of this program: process = 1''; Try it Yourself >> will look like: $(0,0,1,1,1,1,\\dots)$. The ' time expression is useful when designing filters, etc. and is equivalent to @(1) (see the @ Time Expression ).","title":"' Time Expression"},{"location":"refs/syntax/#time-expression_1","text":"@ is used to express a delay with an arbitrary number of samples. For example: process = @(10); Try it Yourself >> will delay the incoming signal by 10 samples. A delay expressed with @ doesn't have to be fixed but it must be positive and bounded. Therefore, the values of a slider are perfectly acceptable: process = @(hslider( delay ,0,0,100,1)); Try it Yourself >> @ only allows for the implementation of integer delay. Thus, various fractional delay algorithms are implemented in the Faust libraries .","title":"@ Time Expression"},{"location":"refs/syntax/#environment-expressions","text":"Faust is a lexically scoped language. The meaning of a Faust expression is determined by its context of definition (its lexical environment) and not by its context of use. To keep their original meaning, Faust expressions are bounded to their lexical environment in structures called closures . The following constructions allow to explicitly create and access such environments. Moreover they provide powerful means to reuse existing code and promote modular design.","title":"Environment Expressions"},{"location":"refs/syntax/#with-expression","text":"The with construction allows to specify a local environment : a private list of definition that will be used to evaluate the left hand expression. In the following example : pink = f : + ~ g with { f(x) = 0.04957526213389*x - 0.06305581334498*x' + 0.01483220320740*x''; g(x) = 1.80116083982126*x - 0.80257737639225*x'; }; process = pink; Try it Yourself >> the definitions of f(x) and g(x) are local to f : + ~ g . Please note that with is left associative and has the lowest priority: f : + ~ g with {...} is equivalent to (f : + ~ g) with {...} . f : + ~ g with {...} with {...} is equivalent to ((f : + ~ g) with {...}) with {...} .","title":"with Expression"},{"location":"refs/syntax/#letrec-expression","text":"The letrec construction is somehow similar to with , but for difference equations instead of regular definitions. It allows us to easily express groups of mutually recursive signals, for example: $$ x(t) = y(t-1) + 10\\ y(t) = x(t-1) - 1 $$ as E letrec { 'x = y+10; 'y = x-1; } The syntax is defined by the following rules: Note the special notation 'x = y + 10 instead of x = y' + 10 . It makes syntactically impossible to write non-sensical equations like x=x+1 . Here is a more involved example. Let say we want to define an envelope generator with an attack and a release time (as a number of samples), and a gate signal. A possible definition could be: import( stdfaust.lib ); ar(a,r,g) = v letrec { 'n = (n+1) * (g =g'); 'v = max(0, v + (n a)/a - (n =a)/r) * (g =g'); }; gate = button( gate ); process = os.osc(440)*ar(1000,1000,gate); Try it Yourself >> With the following semantics for $n(t)$ and $v(t)$: $$ n(t) = (n(t-1)+1) * (g(t) = g(t-1))\\ v(t) = max(0, v(t-1) + (n(t-1) =a(t))/r(t)) * (g(t) =g(t-1)) $$","title":"letrec Expression"},{"location":"refs/syntax/#environment-expression","text":"The environment construction allows to create an explicit environment. It is like a `with' , but without the left hand expression. It is a convenient way to group together related definitions, to isolate groups of definitions and to create a name space hierarchy. In the following example an environment construction is used to group together some constant definitions : constant = environment { pi = 3.14159; e = 2,718; ... }; The . construction allows to access the definitions of an environment (see next section).","title":"environment Expression"},{"location":"refs/syntax/#access-expression","text":"Definitions inside an environment can be accessed using the . construction. For example constant.pi refers to the definition of pi in the constant environment defined above . Note that environments don't have to be named. We could have written directly: environment{pi = 3.14159; e = 2,718;....}.pi","title":"Access Expression"},{"location":"refs/syntax/#library-expression","text":"The library construct allows to create an environment by reading the definitions from a file. For example library(\"filters.lib\") represents the environment obtained by reading the file filters.lib . It works like import(\"miscfilter.lib\") but all the read definitions are stored in a new separate lexical environment. Individual definitions can be accessed as described in the previous paragraph. For example library(\"filters.lib\").lowpass denotes the function lowpass as defined in the file miscfilter.lib . To avoid name conflicts when importing libraries it is recommended to prefer library to import . So instead of : import( filters.lib ); ... ...lowpass.... ... }; the following will ensure an absence of conflicts : fl = library( filters.lib ); ... ...fl.lowpass.... ... }; In practice, that's how the stdfaust.lib library works.","title":"library Expression"},{"location":"refs/syntax/#component-expression","text":"The component construction allows us to reuse a full Faust program (e.g., a .dsp file) as a simple expression. For example component(\"freeverb.dsp\") denotes the signal processor defined in file freeverb.dsp . Components can be used within expressions like in: ...component( karplus32.dsp ) : component( freeverb.dsp )... Please note that component(\"freeverb.dsp\") is equivalent to library(\"freeverb.dsp\").process . component works well in tandem with explicit substitution (see next section).","title":"component Expression"},{"location":"refs/syntax/#explicit-substitution","text":"Explicit substitution can be used to customize a component or any expression with a lexical environment by replacing some of its internal definitions, without having to modify it. For example we can create a customized version of component(\"freeverb.dsp\") , with a different definition of foo(x) , by writing: ...component( freeverb.dsp )[foo(x) = ...;]... };","title":"Explicit Substitution"},{"location":"refs/syntax/#foreign-expressions","text":"Reference to external C functions , variables and constants can be introduced using the foreign function mechanism.","title":"Foreign Expressions"},{"location":"refs/syntax/#ffunction","text":"An external C function is declared by indicating its name and signature as well as the required include file. The file maths.lib of the Faust distribution contains several foreign function definitions, for example the inverse hyperbolic sine function asinh : asinh = ffunction(float asinh (float), math.h , ); Foreign functions with input parameters are considered pure math functions. They are therefore considered free of side effects and called only when their parameters change (that is at the rate of the fastest parameter). Exceptions are functions with no input parameters. A typical example is the C rand() function. In this case, the compiler generates code to call the function at sample rate.","title":"ffunction"},{"location":"refs/syntax/#signature","text":"The signature part ( float asinh (float) in the example presented in the previous section ) describes the prototype of the C function: return type, function name, and list of parameter types. Because the name of the foreign function can possibly depend on the floating point precision in use (float, double and quad), it is possible to give a different function name for each floating point precision using a signature with up to three function names. For example in the declaration: asinh = ffunction(float asinhf|asinh|asinhl (float), math.h , ); the signature float asinhf|asinh|asinhl (float) indicates to use the function name asinhf in single precision, asinh in double precision and asinhl in long double (quad) precision.","title":"Signature"},{"location":"refs/syntax/#types","text":"Only numerical functions involving simple int and float parameters are allowed currently in Faust. No vectors, tables or data structures can be passed as parameters or returned.","title":"Types"},{"location":"refs/syntax/#variables-and-constants","text":"External variables and constants can also be declared with a similar syntax. In the same maths.lib file, the definition of the sampling rate constant SR and the definition of the block-size variable BS can be found: SR = min(192000.0,max(1.0,fconstant(int fSamplingFreq, math.h ))); BS = fvariable(int count, math.h ); Foreign constants are not supposed to vary. Therefore expressions involving only foreign constants are only computed once, during the initialization period. Variable are considered to vary at block speed. This means that expressions depending of external variables are computed every block.","title":"Variables and Constants"},{"location":"refs/syntax/#file-include","text":"In declaring foreign functions one has also to specify the include file. It allows the Faust compiler to add the corresponding #include in the generated code.","title":"File Include"},{"location":"refs/syntax/#library-file","text":"In declaring foreign functions one can possibly specify the library where the actual code is located. It allows the Faust compiler to (possibly) automatically link the library. Note that this feature is only used with the LLVM backend in 'libfaust' dynamic library model .","title":"Library File"},{"location":"refs/syntax/#applications-and-abstractions","text":"Abstractions and applications are fundamental programming constructions directly inspired by Lambda-Calculus. These constructions provide powerful ways to describe and transform block-diagrams algorithmically.","title":"Applications and Abstractions"},{"location":"refs/syntax/#abstractions","text":"Abstractions correspond to functions definitions and allow to generalize a block-diagram by making variable some of its parts. Let's say we want to transform a stereo reverb, dm.zita_light for instance, into a mono effect. The following expression can be written (see the sections on Split Composition and Merge Composition ): _ : dm.zita_light : _ The incoming mono signal is split to feed the two input channels of the reverb, while the two output channels of the reverb are mixed together to produce the resulting mono output. Imagine now that we are interested in transforming other stereo effects. We could generalize this principle by making zita_light a variable: \\(zita_light).(_ : zita_light : _) The resulting abstraction can then be applied to transform other effects. Note that if zita_light is a perfectly valid variable name, a more neutral name would probably be easier to read like: \\(fx).(_ : fx : _) A name can be given to the abstraction and in turn use it on dm.zita_light : import( stdfaust.lib ); mono = \\(fx).(_ : fx : _); process = mono(dm.zita_light); Try it Yourself >> Or even use a more traditional, but equivalent, notation: mono(fx) = _ : fx : _;","title":"Abstractions"},{"location":"refs/syntax/#applications","text":"Applications correspond to function calls and allow to replace the variable parts of an abstraction with the specified arguments. For example, the abstraction described in the previous section can be used to transform a stereo reverb: mono(dm.zita_light) The compiler will start by replacing mono by its definition: \\(fx).(_ : fx : _)(dm.zita_light) Replacing the variable part with the argument is called beta-reduction in Lambda-Calculus Whenever the Faust compiler find an application of an abstraction it replaces the variable part with the argument. The resulting expression is as expected: (_ : dm.zita_light : _)","title":"Applications"},{"location":"refs/syntax/#pattern-matching","text":"Pattern matching rules provide an effective way to analyze and transform block-diagrams algorithmically. For example case{ (x:y) = y:x; (x) = x; } contains two rules. The first one will match a sequential expression and invert the two part. The second one will match all remaining expressions and leave it untouched. Therefore the application: case{(x:y) = y:x; (x) = x;}(reverb : harmonizer) will produce: harmonizer : freeverb Please note that patterns are evaluated before the pattern matching operation. Therefore only variables that appear free in the pattern are binding variables during pattern matching.","title":"Pattern Matching"},{"location":"refs/syntax/#primitives","text":"The primitive signal processing operations represent the built-in functionalities of Faust, that is the atomic operations on signals provided by the language. All these primitives denote signal processors , in other words, functions transforming input signals into output signals .","title":"Primitives"},{"location":"refs/syntax/#numbers","text":"Faust considers two types of numbers: integers and floats . Integers are implemented as 32-bits integers, and floats are implemented either with a simple, double, or extended precision depending of the compiler options. Floats are available in decimal or scientific notation. Like any other Faust expression, numbers are signal processors. For example the number 0.95 is a signal processor of type $\\mathbb{S}^{0}\\rightarrow\\mathbb{S}^{1}$ that transforms an empty tuple of signals $()$ into a 1-tuple of signals $(y)$ such that $\\forall t\\in\\mathbb{N}, y(t)=0.95$.","title":"Numbers"},{"location":"refs/syntax/#waveform-primitive","text":"The waveform primitive was designed to facilitate the use of rdtable (read table). It allows us to specify a fixed periodic signal as a list of samples. waveform has two outputs: a constant and indicating the size (as a number of samples) of the period, the periodic signal itself. For example waveform{0,1,2,3} produces two outputs: the constant signal 4 and the periodic signal $(0,1,2,3,0,1,2,3,0,1,\\dots)$. In the following example: import( stdfaust.lib ); triangleWave = waveform{0,0.5,1,0.5,0,-0.5,-1,-.5}; triangleOsc(f) = triangleWave,int(os.phasor(8,f)) : rdtable; f = hslider( freq ,440,50,2000,0.01); process = triangleOsc(f); Try it Yourself >> waveform is used to define a triangle waveform (in its most primitive form), which is then used with a rdtable controlled by a phasor to implement a triangle wave oscillator. Note that the quality of this oscillator is very low because of the low resolution of the triangle waveform.","title":"waveform Primitive"},{"location":"refs/syntax/#soundfile-primitive","text":"The soundfile(\"label[url:{'path1';'path2';'path3'}]\", n) primitive allows for the access a list of externally defined sound resources, described as the list of their filename, or complete paths. The soundfile(\"label[url:path]\", n) simplified syntax allows to use a single file. A soundfile has: two inputs: the sound number (as a integer between 0 and 255 checked at compilation time), and the read index in the sound (which will access the last sample of the sound if the read index is greater than the sound length) two fixed outputs: the first one is the currently accessed sound length in frames, the second one is the currently accessed sound nominal sample rate in frames several more outputs for the sound channels themselves If more outputs than the actual number of channels in the sound file are used, the audio channels will be automatically duplicated up to the wanted number of outputs (so for instance, if a stereo file is used with four output channels, the same group of two channels will be duplicated). If the soundfile cannot be loaded for whatever reason, a default sound with one channel, a length of 1024 frames and null outputs (with samples of value 0) will be used. Note also that soundfiles are entirely loaded in memory by the architecture file, so that the read index signal can access any sample. Architecture files are responsible to load the actual soundfile. The SoundUI C++ class located in the faust/gui/SoundUI.h file in the Faust repository implements the void addSoundfile(label, path, sf_zone) method, which loads the actual soundfiles using the libsndfile library, or possibly specific audio file loading code (in the case of the JUCE framework for instance), and set up the sf_zone sound memory pointers. If label is used without any url metadata, it will be considered as the soundfile pathname. Note that a special architecture file can well decide to access and use sound resources created by another means (that is, not directly loaded from a sound file). For instance a mapping between labels and sound resources defined in memory could be used, with some additional code in charge of actually setting up all sound memory pointers when void addSoundfile(label, path, sf_zone) is called by the buidUserInterface mechanism.","title":"soundfile Primitive"},{"location":"refs/syntax/#c-equivalent-primitives","text":"Most Faust primitives are analogous to their C counterpart but adapted to signal processing. For example + is a function of type $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ that transforms a pair of signals $(x_1,x_2)$ into a 1-tuple of signals $(y)$ such that $\\forall t\\in\\mathbb{N}, y(t)=x_{1}(t)+x_{2}(t)$. + can be used to very simply implement a mixer: process = +; Try it Yourself >> Note that this is equivalent to (see Identity Function ): process = _+_; Try it Yourself >> The function - has type $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ and transforms a pair of signals $(x_1,x_2)$ into a 1-tuple of signals $(y)$ such that $\\forall t\\in\\mathbb{N}, y(t)=x_{1}(t)-x_{2}(t)$. Be aware that the unary - only exists in a limited form. It can be used with numbers: -0.5 and variables: -myvar , but not with expressions surrounded by parenthesis, because in this case it represents a partial application. For instance, -(a*b) is a partial application. It is syntactic sugar for _,(a*b) : - . If you want to negate a complex term in parenthesis, you'll have to use 0 - (a*b) instead.","title":"C-Equivalent Primitives"},{"location":"refs/syntax/#integer-number","text":"Integer numbers are of type $\\mathbb{S}^{0}\\rightarrow\\mathbb{S}^{1}$ in Faust and can be described mathematically as $y(t)=n$. Example: DC Offset of 1 process = 1; Try it Yourself >>","title":"Integer Number"},{"location":"refs/syntax/#floating-point-number","text":"Floating point numbers are of type $\\mathbb{S}^{0}\\rightarrow\\mathbb{S}^{1}$ in Faust and can be described as $y(t)=n.m$. Example: DC Offset of 0.5 process = 0.5; Try it Yourself >>","title":"Floating Point Number"},{"location":"refs/syntax/#identity-function","text":"The identity function is expressed in Faust with the _ primitive. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x(t)$ Example: a Signal Passing Through In the following example, the _ primitive is used to connect the single audio input of a Faust program to its output: process = _; Try it Yourself >>","title":"Identity Function"},{"location":"refs/syntax/#cut-primitive","text":"The cut primitive is expressed in Faust with ! . It can be used to \"stop\"/terminate a signal. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{0}$ Mathematical Description: $\\forall x\\in\\mathbb{S},(x)\\rightarrow ()$ Example: Stopping a Signal In the following example, the ! primitive is used to stop one of two parallel signals: process = 1,2 : !,_; Try it Yourself >>","title":"Cut Primitive"},{"location":"refs/syntax/#int-primitive","text":"The int primitive can be used to force the cast of a signal to int. It is of type $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ and can be described mathematically as $y(t)=(int)x(t)$. This primitive is useful when declaring indices to read in a table, etc. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=(int)x(t)$ Example: Simple Cast process = 1.5 : int; Try it Yourself >>","title":"int Primitive"},{"location":"refs/syntax/#float-primitive","text":"The float primitive can be used to force the cast of a signal to float. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=(float)x(t)$ Example: Simple Cast process = 1.5 : float; Try it Yourself >>","title":"float Primitive"},{"location":"refs/syntax/#add-primitive","text":"The + primitive can be used to add two signals together. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)+x_{2}(t)$ Example: Simple Mixer process = +; Try it Yourself >>","title":"Add Primitive"},{"location":"refs/syntax/#subtract-primitive","text":"The - primitive can be used to subtract two signals. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)-x_{2}(t)$ Example: Subtracting Two Input Signals process = -; Try it Yourself >>","title":"Subtract Primitive"},{"location":"refs/syntax/#multiply-primitive","text":"The * primitive can be used to multiply two signals. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)*x_{2}(t)$ Example: Multiplying a Signal by 0.5 process = *(0.5); Try it Yourself >>","title":"Multiply Primitive"},{"location":"refs/syntax/#divide-primitive","text":"The / primitive can be used to divide two signals. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)/{x_{2}(t)}$ Example: Dividing a Signal by 2 process = ^(2); Try it Yourself >>","title":"Divide Primitive"},{"location":"refs/syntax/#power-primitive","text":"The ^ primitive can be used to raise to the power of N a signal. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)^{x_{2}(t)}$ Example: Power of Two of a Signal process = ^(2); Try it Yourself >>","title":"Power Primitive"},{"location":"refs/syntax/#modulo-primitive","text":"The % primitive can be used to take the modulo of a signal. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)\\%{x_{2}(t)}$ Example: Phaser The following example uses a counter and the % primitive to implement a basic phaser: process = _~+(1) : -(1) : %(10); Try it Yourself >> will output a signal: (0,1,2,3,4,5,6,7,8,9,0,1,2,3,4) .","title":"Modulo Primitive"},{"location":"refs/syntax/#and-primitive","text":"Logical AND can be expressed in Faust with the primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)\\ {x_{2}(t)}$ Example TODO","title":"AND Primitive"},{"location":"refs/syntax/#or-primitive","text":"Logical OR can be expressed in Faust with the | primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)|{x_{2}(t)}$ Example The following example will output 1 if the incoming signal is smaller than 0.5 or greater than 0.7 and 0 otherwise. Note that the result of this operation could be multiplied to another signal to create a condition. process = _ : (0.5) | (0.7); Try it Yourself >>","title":"OR Primitive"},{"location":"refs/syntax/#xor-primitive","text":"Logical XOR can be expressed in Faust with the xor primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t)\\land {x_{2}(t)}$ Example process = _ : (0.5) xor (0.7); Try it Yourself >>","title":"XOR Primitive"},{"location":"refs/syntax/#left-shift-primitive","text":"Left shift can be expressed in Faust with the primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) {x_{2}(t)}$ Example process = 1 2; Try it Yourself >>","title":"Left Shift Primitive"},{"location":"refs/syntax/#right-shift-primitive","text":"Right shift can be expressed in Faust with the primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) {x_{2}(t)}$ Example process = 1 2; Try it Yourself >>","title":"Right Shift Primitive"},{"location":"refs/syntax/#smaller-than-primitive","text":"The smaller than comparison can be expressed in Faust with the primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) {x_{2}(t)}$ Example The following code will output 1 if the input signal is smaller than 0.5 and 0 otherwise. process = (0.5); Try it Yourself >>","title":"Smaller Than Primitive"},{"location":"refs/syntax/#smaller-or-equal-than-primitive","text":"The smaller or equal than comparison can be expressed in Faust with the = primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) = {x_{2}(t)}$ Example The following code will output 1 if the input signal is smaller or equal than 0.5 and 0 otherwise. process = =(0.5); Try it Yourself >>","title":"Smaller or Equal Than Primitive"},{"location":"refs/syntax/#greater-than-primitive","text":"The greater than comparison can be expressed in Faust with the primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) {x_{2}(t)}$ Example The following code will output 1 if the input signal is greater than 0.5 and 0 otherwise. process = (0.5); Try it Yourself >>","title":"Greater Than Primitive"},{"location":"refs/syntax/#greater-or-equal-than-primitive","text":"The greater or equal than comparison can be expressed in Faust with the = primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) = {x_{2}(t)}$ Example The following code will output 1 if the input signal is greater or equal than 0.5 and 0 otherwise. process = =(0.5); Try it Yourself >>","title":"Greater or Equal Than Primitive"},{"location":"refs/syntax/#equal-to-primitive","text":"The equal to comparison can be expressed in Faust with the == primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) == {x_{2}(t)}$ Example process = 0 == 1; Try it Yourself >>","title":"Equal to Primitive"},{"location":"refs/syntax/#different-than-primitive","text":"The different than comparison can be expressed in Faust with the != primitive. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=x_{1}(t) != {x_{2}(t)}$ Example process = 0 != 1; Try it Yourself >>","title":"Different Than Primitive"},{"location":"refs/syntax/#mathh-equivalent-primitives","text":"Most of the C math.h functions are also built-in as primitives (the others are defined as external functions in file math.lib ).","title":"math.h-Equivalent Primitives"},{"location":"refs/syntax/#acos-primitive","text":"Arc cosine can be expressed as acos in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{acosf}(x(t))$ Example process = 0.1 : acos; Try it Yourself >>","title":"acos Primitive"},{"location":"refs/syntax/#asin-primitive","text":"Arc sine can be expressed as asin in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{asinf}(x(t))$ Example process = 0.1 : asin; Try it Yourself >>","title":"asin Primitive"},{"location":"refs/syntax/#atan-primitive","text":"Arc tangent can be expressed as atan in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{atanf}(x(t))$ Example process = 0.1 : atan; Try it Yourself >>","title":"atan Primitive"},{"location":"refs/syntax/#atan2-primitive","text":"The arc tangent of 2 signals can be expressed as atan2 in Faust. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{atan2f}(x_{1}(t), x_{2}(t))$ Example process = 0.1,-0.1 : atan2; Try it Yourself >>","title":"atan2 Primitive"},{"location":"refs/syntax/#cos-primitive","text":"Cosine can be expressed as cos in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{cosf}(x(t))$ Example process = 0.1 : cos; Try it Yourself >>","title":"cos Primitive"},{"location":"refs/syntax/#sin-primitive","text":"Sine can be expressed as sin in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{sinf}(x(t))$ Example process = 0.1 : sin; Try it Yourself >>","title":"sin Primitive"},{"location":"refs/syntax/#tan-primitive","text":"Tangent can be expressed as tan in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{tanf}(x(t))$ Example process = 0.1 : tan; Try it Yourself >>","title":"tan Primitive"},{"location":"refs/syntax/#exp-primitive","text":"Base-e exponential can be expressed as exp in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{expf}(x(t))$ Example process = 0.1 : exp; Try it Yourself >>","title":"exp Primitive"},{"location":"refs/syntax/#log-primitive","text":"Base-e logarithm can be expressed as log in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{logf}(x(t))$ Example process = 0.1 : log; Try it Yourself >>","title":"log Primitive"},{"location":"refs/syntax/#log10-primitive","text":"Base-10 logarithm can be expressed as log10 in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{log10}(x(t))$ Example process = 0.1 : log10; Try it Yourself >>","title":"log10 Primitive"},{"location":"refs/syntax/#pow-primitive","text":"Power can be expressed as pow in Faust. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{powf}(x_{1}(t),x_{2}(t))$ Example process = 2,4 : pow; Try it Yourself >>","title":"pow Primitive"},{"location":"refs/syntax/#sqrt-primitive","text":"Square root can be expressed as sqrt in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{sqrtf}(x(t))$ Example process = 4 : sqrt; Try it Yourself >>","title":"sqrt Primitive"},{"location":"refs/syntax/#abs-primitive","text":"Absolute value can be expressed as abs in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{abs}(x(t))$ (int) or $y(t)=\\mathrm{fabsf}(x(t))$ (float) Example process = -0.5 : abs; Try it Yourself >>","title":"abs Primitive"},{"location":"refs/syntax/#min-primitive","text":"Minimum can be expressed as min in Faust. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{min}(x_{1}(t),x_{2}(t))$ Example process = -0.5,0.2 : min; Try it Yourself >>","title":"min Primitive"},{"location":"refs/syntax/#max-primitive","text":"Maximum can be expressed as max in Faust. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{max}(x_{1}(t),x_{2}(t))$ Example process = -0.5,0.2 : max; Try it Yourself >>","title":"max Primitive"},{"location":"refs/syntax/#fmod-primitive","text":"Float modulo can be expressed as fmod in Faust. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{fmodf}(x_{1}(t),x_{2}(t))$ Example process = 5.3,2 : fmod; Try it Yourself >>","title":"fmod Primitive"},{"location":"refs/syntax/#remainder-primitive","text":"Float remainder can be expressed as remainder in Faust. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{remainderf}(x_{1}(t),x_{2}(t))$ Example process = 5.3,2 : remainder; Try it Yourself >>","title":"remainder Primitive"},{"location":"refs/syntax/#floor-primitive","text":"Largest int can be expressed as floor in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $\\leq$: $y(t)=\\mathrm{floorf}(x(t))$ Example process = 3.6 : floor; Try it Yourself >>","title":"floor Primitive"},{"location":"refs/syntax/#ceil-primitive","text":"Smallest int can be expressed as ceil in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $\\geq$: $y(t)=\\mathrm{ceilf}(x(t))$ Example process = 3.6 : ceil; Try it Yourself >>","title":"ceil Primitive"},{"location":"refs/syntax/#rint-primitive","text":"Closest int can be expressed as rint in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=\\mathrm{rintf}(x(t))$ Example process = 3.6 : rint; Try it Yourself >>","title":"rint Primitive"},{"location":"refs/syntax/#delay-primitives-and-modifiers","text":"Faust hosts various modifiers and primitives to define one sample or integer delay of arbitrary length. They are presented in this section.","title":"Delay Primitives and Modifiers"},{"location":"refs/syntax/#mem-primitive","text":"A 1 sample delay can be expressed as mem in Faust. Type: $\\mathbb{S}^{1}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t+1)=x(t),y(0)=0$ Example process = mem; Try it Yourself >> Note that this is equivalent to process = _' (see ' Modifier ) and process = @(1) (see @ Primitive )","title":"mem Primitive"},{"location":"refs/syntax/#modifier","text":"' can be used to apply a 1 sample delay to a signal in Faust. It can be seen as syntactic sugar to the mem primitive . ' is very convenient when implementing filters and can help significantly decrease the size of the Faust code. Example process = _'; Try it Yourself >>","title":"' Modifier"},{"location":"refs/syntax/#primitive","text":"An integer delay of N samples can be expressed as @(N) in Faust. Note that N can be dynamic but that its range must be bounded. This can be done by using a UI primitive (see example below) allowing for the definition of a range such as hslider , vslider , or nentry . Note that floating point delay is also available in Faust by the mean of various fractional delay implementations available in the Faust standard libraries. Type: $\\mathbb{S}^{2}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t+x_{2}(t))=x_{1}(t), y(t x_{2}(t))=0$ Usage _ : @(N) : _ Where: N : the length of the delay as a number of samples Example: Static N Samples Delay N = 10; process = @(N); Try it Yourself >> Example: Dynamic N Samples Delay N = hslider( N ,10,1,10,1); process = @(N); Try it Yourself >>","title":"@ Primitive"},{"location":"refs/syntax/#table-primitives","text":"TODO","title":"Table Primitives"},{"location":"refs/syntax/#rdtable-primitive","text":"The rdtable primitive can be used to read through a read-only (pre-defined before compilation) table. The table can either be implemented using a function controlled by a timer (such as ba.time ) as demonstrated in the first example, or by using the waveform primitive (as shown in the second example). The idea is that the table is parsed during the initialization step and before audio computation begins. Type: $\\mathbb{S}^{3}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $y(t)=T[r(t)]$ Usage rdtable(n,s,r) : _ Where: n : the table size s : the table content r : the read index (an int between 0 and n-1 ) Example: Basic Triangle Wave Oscillator Using the waveform Primitive In this example, a basic (and dirty) triangle wave-table is defined using the waveform . It is then used with the rdtable primitive and a phasor to implement a triangle wave oscillator. Note that the output of import( stdfaust.lib ); triangleWave = waveform{0,0.5,1,0.5,0,-0.5,-1,-.5}; triangleOsc(f) = triangleWave,int(os.phasor(8,f)) : rdtable; f = hslider( freq ,440,50,2000,0.01); process = triangleOsc(f); Try it Yourself >> Example: Basic Triangle Wave Oscillator Using the waveform Primitive In this example, a sine table is implemented using the sin primitive and a timer ( ba.time ). The timer parses the sin function during the initialization step of the Faust program. It is then used with rdtable to implement a sine wave oscillator. import( stdfaust.lib ); sineWave(tablesize) = float(ba.time)*(2.0*ma.PI)/float(tablesize) : sin; tableSize = 1 16; triangleOsc(f) = tableSize,sineWave(tableSize),int(os.phasor(tableSize,f)) : rdtable; f = hslider( freq ,440,50,2000,0.01); process = triangleOsc(f); Try it Yourself >>","title":"rdtable Primitive"},{"location":"refs/syntax/#rwtable-primitive","text":"The rwtable primitive can be used to implement a read/write table. It takes an audio input that can be written in the table using a record index (i.e., w below) and read using a read index (i.e., r below). Type: $\\mathbb{S}^{5}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $T[w(t)]=c(t); y(t)=T[r(t)]$ Usage _ : rwtable(n,s,w,_,r) : _ Where: n : the table size s : the initial table content w : the write index (an int between 0 and n-1 ) r : the read index (an int between 0 and n-1 ) Note that the fourth argument of rwtable corresponds to the input of the table. Example: Simple Looper In this example, an input signal is written in the table when record is true (equal to 1). The read index is constantly updated to loop through the table. The table size is set to 48000, which corresponds to one second if the sampling rate is 48000 KHz. import( stdfaust.lib ); tableSize = 48000; recIndex = (+(1) : %(tableSize)) ~ *(record); readIndex = readSpeed/float(ma.SR) : (+ : ma.decimal) ~ _ : *(float(tableSize)) : int; readSpeed = hslider( [0]Read Speed ,1,0.001,10,0.01); record = button( [1]Record ) : int; looper = rwtable(tableSize,0.0,recIndex,_,readIndex); process = looper; Try it Yourself >>","title":"rwtable Primitive"},{"location":"refs/syntax/#selector-primitives","text":"Selector primitives can be used to create conditions in Faust and to implement switches to choose between several signals. Note that selector primitives optimize the code generated by the Faust compiler by only computing the selected signal.","title":"Selector Primitives"},{"location":"refs/syntax/#select2-primitives","text":"The select2 primitive is a \"two-ways selector\" that can be used to select between 2 signals. Type: $\\mathbb{S}^{3}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $T[]={x_{0}(t),x_{1}(t)}; y(t)=T[s(t)]$ Usage _,_ : select2(s) : _,_ Where: s : the selector ( 0 for the first signal, 1 for the second one) Example: Signal Selector The following example allows the user to choose between a sine and a sawtooth wave oscillator. import( stdfaust.lib ); s = nentry( Selector ,0,0,1,1); sig = os.osc(440),os.sawtooth(440) : select2(s); process = sig; Try it Yourself >> Note that select2 could be easily implemented from scratch in Faust using Boolean primitives: import( stdfaust.lib ); s = nentry( Selector ,0,0,1,1); mySelect2(s) = *(s==0),*(s==1) : _; sig = os.osc(440),os.sawtooth(440) : mySelect2(s); process = sig; Try it Yourself >> While the behavior of this last solution is identical to the first one, the generated code will be less optimized as the sine and the sawtooth waves will both be computed all the time.","title":"select2 Primitives"},{"location":"refs/syntax/#select3-primitives","text":"The select3 primitive is a \"three-ways selector\" that can be used to select between 3 signals. Type: $\\mathbb{S}^{4}\\rightarrow\\mathbb{S}^{1}$ Mathematical Description: $T[]={x_{0}(t),x_{1}(t),x_{2}(t)}; y(t)=T[s(t)]$ Usage _,_,_ : select3(s) : _,_,_ Where: s : the selector ( 0 for the first signal, 1 for the second one, 2 for the third one) Example: Signal Selector The following example allows the user to choose between a sine, a sawtooth and a triangle wave oscillator. import( stdfaust.lib ); s = nentry( Selector ,0,0,1,1); sig = os.osc(440),os.sawtooth(440),os.triangle(440) : select3(s); process = sig; Try it Yourself >> Note that select3 could be easily implemented from scratch in Faust using Boolean primitives: import( stdfaust.lib ); s = nentry( Selector ,0,0,2,1); mySelect3(s) = *(s==0),*(s==1),*(s==2) : _; sig = os.osc(440),os.sawtooth(440),os.triangle(440) : mySelect3(s); process = sig; Try it Yourself >> While the behavior of this last solution is identical to the first one, the generated code will be less optimized as the sine, the sawtooth and the triangle waves will all be computed all the time.","title":"select3 Primitives"},{"location":"refs/syntax/#user-interface-primitives-and-configuration","text":"Faust user interface widgets/primitives allow for an abstract description of a user interface from within the Faust code. This description is independent from any GUI toolkits/frameworks and is purely abstract. Widgets can be discrete (e.g., button , checkbox , etc.), continuous (e.g., hslider , vslider , nentry ), and organizational (e.g., vgroup , hgroup ). Discrete and continuous elements are signal generators. For example, a button produces a signal which is 1 when the button is pressed and 0 otherwise: These signals can be freely combined with other audio signals. In fact, the following code is perfectly valid and will generate sound: process = button( DC ); Try it Yourself >> Each primitive implements a specific UI element, but their appearance can also be completely modified using metadata (a little bit like HTML and CSS in the web). Therefore, hslider , vslider , and nentry ) can for example be turned into a knob, a dropdown menu, etc. This concept is further developed in the section on UI metadata . Continuous UI elements (i.e., hslider , vslider , and nentry ) must all declare a range for the parameter they're controlling. In some cases, this range is used during compilation to allocate memory and will impact the generated code. For example, in the case of: process = @(hslider( N ,1,1,10,1)); Try it Yourself >> a buffer of 10 samples will be allocated for the delay implemented with the @ primitive while 20 samples will be allocated in the following example: process = @(hslider( N ,1,1,20,1)); Try it Yourself >>","title":"User Interface Primitives and Configuration"},{"location":"refs/syntax/#button-primitive","text":"The button primitive implements a button. Usage button( label ) : _ Where: label : the label (expressed as a string) of the element in the interface Example: Trigger import( stdfaust.lib ); process = no.noise*button( gate ); Try it Yourself >>","title":"button Primitive"},{"location":"refs/syntax/#checkbox-primitive","text":"The checkbox primitive implements a checkbox/toggle. Usage checkbox( label ) : _ Where: label : the label (expressed as a string) of the element in the interface Example: Trigger import( stdfaust.lib ); process = no.noise*checkbox( gate ); Try it Yourself >>","title":"checkbox Primitive"},{"location":"refs/syntax/#hslider-primitive","text":"The hslider primitive implements a horizontal slider. Usage hslider( label ,init,min,max,step) : _ Where: label : the label (expressed as a string) of the element in the interface init : the initial value of the slider min : the minimum value of the slider max : the maximum value of the slider step : the precision (step) of the slider (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.) Example: Gain Control gain = hslider( gain ,0,0,1,0.01); process = *(gain); Try it Yourself >>","title":"hslider Primitive"},{"location":"refs/syntax/#vslider-primitive","text":"The vslider primitive implements a vertical slider. Usage vslider( label ,init,min,max,step) : _ Where: label : the label (expressed as a string) of the element in the interface init : the initial value of the slider min : the minimum value of the slider max : the maximum value of the slider step : the precision (step) of the slider (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.) Example gain = vslider( gain ,0,0,1,0.01); process = *(gain); Try it Yourself >>","title":"vslider Primitive"},{"location":"refs/syntax/#nentry-primitive","text":"The nentry primitive implements a \"numerical entry\". Usage nentry( label ,init,min,max,step) : _ Where: label : the label (expressed as a string) of the element in the interface init : the initial value of the numerical entry min : the minimum value of the numerical entry max : the maximum value of the numerical entry step : the precision (step) of the numerical entry (1 to count 1 by 1, 0.1 to count 0.1 by 0.1, etc.) Example gain = nentry( gain ,0,0,1,0.01); process = *(gain); Try it Yourself >>","title":"nentry Primitive"},{"location":"refs/syntax/#hgroup-primitive","text":"The hgroup primitive implements a horizontal group. A group contains other UI elements that can also be groups. hgroup is not a signal processor per se and is just a way to label/delimitate part of a Faust code. Usage hgroup( label ,x) Where: label : the label (expressed as a string) of the element in the interface x : the encapsulated/labeled Faust code Example In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group. import( stdfaust.lib ); freq = vslider( freq ,440,50,1000,0.1); gain = vslider( gain ,0,0,1,0.01); process = hgroup( Oscillator ,os.sawtooth(freq)*gain); Try it Yourself >> Note that the Oscillator group can be placed in a function in case we'd like to add elements to it multiple times. import( stdfaust.lib ); oscGroup(x) = hgroup( Oscillator ,x); freq = oscGroup(vslider( freq ,440,50,1000,0.1)); gain = oscGroup(vslider( gain ,0,0,1,0.01)); process = os.sawtooth(freq)*gain; Try it Yourself >>","title":"hgroup Primitive"},{"location":"refs/syntax/#vgroup-primitive","text":"The vgroup primitive implements a vertical group. A group contains other UI elements that can also be groups. vgroup is not a signal processor per se and is just a way to label/delimitate part of a Faust code. Usage vgroup( label ,x) Where: label : the label (expressed as a string) of the element in the interface x : the encapsulated/labeled Faust code Example In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group. import( stdfaust.lib ); freq = hslider( freq ,440,50,1000,0.1); gain = hslider( gain ,0,0,1,0.01); process = vgroup( Oscillator ,os.sawtooth(freq)*gain); Try it Yourself >> Note that the Oscillator group can be placed in a function in case we'd like to add elements to it multiple times. import( stdfaust.lib ); oscGroup(x) = vgroup( Oscillator ,x); freq = oscGroup(hslider( freq ,440,50,1000,0.1)); gain = oscGroup(hslider( gain ,0,0,1,0.01)); process = os.sawtooth(freq)*gain; Try it Yourself >>","title":"vgroup Primitive"},{"location":"refs/syntax/#tgroup-primitive","text":"The tgroup primitive implements a \"tab group.\" Tab groups can be used to group UI elements in tabs in the interface. A group contains other UI elements that can also be groups. tgroup is not a signal processor per se and is just a way to label/delimitate part of a Faust code. Usage tgroup( label ,x) Where: label : the label (expressed as a string) of the element in the interface x : the encapsulated/labeled Faust code Example In the following example, the 2 UI elements controlling an oscillator are encapsulated in a group. import( stdfaust.lib ); freq = hslider( freq ,440,50,1000,0.1); gain = hslider( gain ,0,0,1,0.01); process = tgroup( Oscillator ,os.sawtooth(freq)*gain); Try it Yourself >> Note that the Oscillator group can be placed in a function in case we'd like to add elements to it multiple times. import( stdfaust.lib ); oscGroup(x) = tgroup( Oscillator ,x); freq = oscGroup(hslider( freq ,440,50,1000,0.1)); gain = oscGroup(hslider( gain ,0,0,1,0.01)); process = os.sawtooth(freq)*gain; Try it Yourself >>","title":"tgroup Primitive"},{"location":"refs/syntax/#vbargraph-primitive","text":"The vbargraph primitive implements a vertical bar-graph (typically a meter displaying the level of a signal). Usage vbargraph takes an input signal and outputs it while making it available to the UI. _ : vbargraph( label ,min,max) : _ Where: min : the minimum value of the signal in the interface max : the maximum value of the signal in the interface Example: Simple VU Meter A simple VU meter can be implemented using the vbargraph primitive: import( stdfaust.lib ); process = _ : attach(_,abs : ba.linear2db : vbargraph( Level ,-60,0)); Try it Yourself >> Note the use of the attach primitive here that forces the compilation of the vbargraph without using its output signal (see section on the attach primitive ).","title":"vbargraph Primitive"},{"location":"refs/syntax/#hbargraph-primitive","text":"The hbargraph primitive implements a horizontal bar-graph (typically a meter displaying the level of a signal). Usage hbargraph takes an input signal and outputs it while making it available to the UI. _ : hbargraph( label ,min,max) : _ Where: min : the minimum value of the signal in the interface max : the maximum value of the signal in the interface Example: Simple VU Meter A simple VU meter can be implemented using the hbargraph primitive: import( stdfaust.lib ); process = _ : attach(_,abs : ba.linear2db : hbargraph( Level ,-60,0)); Try it Yourself >> Note the use of the attach primitive here that forces the compilation of the hbargraph without using its output signal (see section on the attach primitive ).","title":"hbargraph Primitive"},{"location":"refs/syntax/#attach-primitive","text":"The attach primitive takes two input signals and produces one output signal which is a copy of the first input. The role of attach is to force its second input signal to be compiled with the first one. From a mathematical standpoint attach(x,y) is equivalent to 1*x+0*y , which is in turn equivalent to x , but it tells the compiler not to optimize-out y . To illustrate this role, let's say that we want to develop a mixer application with a vumeter for each input signals. Such vumeters can be easily coded in Faust using an envelope detector connected to a bargraph. The problem is that the signal of the envelope generators has no role in the output signals. Using attach(x,vumeter(x)) one can tell the compiler that when x is compiled vumeter(x) should also be compiled. The examples in the hbargraph Primitive and the vbargraph Primitive illustrate well the use of attach .","title":"attach Primitive"},{"location":"refs/syntax/#variable-parts-of-a-label","text":"Labels can contain variable parts. These are indicated with the sign % followed by the name of a variable. During compilation each label is processed in order to replace the variable parts by the value of the variable. For example: process = par(i,8,hslider( Voice %i , 0.9, 0, 1, 0.01)); Try it Yourself >> creates 8 sliders in parallel with different names while par(i,8,hslider(\"Voice\", 0.9, 0, 1, 0.01)) would have created only one slider and duplicated its output 8 times. The variable part can have an optional format digit. For example \"Voice %2i\" would indicate to use two digit when inserting the value of i in the string. An escape mechanism is provided. If the sign % is followed by itself, it will be included in the resulting string. For example \"feedback (%%)\" will result in \"feedback (%)\" .","title":"Variable Parts of a Label"},{"location":"refs/syntax/#labels-as-pathnames","text":"Thanks to horizontal , vertical , and tabs groups, user interfaces have a hierarchical structure analog to a hierarchical file system. Each widget has an associated path name obtained by concatenating the labels of all its surrounding groups with its own label. In the following example : hgroup( Foo , ... vgroup( Faa , ... hslider( volume ,...) ... ) ... ) the volume slider has pathname /h:Foo/v:Faa/volume . In order to give more flexibility to the design of user interfaces, it is possible to explicitly specify the absolute or relative pathname of a widget directly in its label. Elements of a path are separated using / . Group types are defined with the following identifiers: Group Type Group Identifier hgroup h: vgroup v: tgroup t: Hence, the example presented in the section on the hgroup primitive can be rewritten as: import( stdfaust.lib ); freq = vslider( h:Oscillator/freq ,440,50,1000,0.1); gain = vslider( h:Oscillator/gain ,0,0,1,0.01); process = os.sawtooth(freq)*gain; Try it Yourself >> which will be reflected in C++ as: virtual void buildUserInterface(UI* ui_interface) { ui_interface- openHorizontalBox( Oscillator ); ui_interface- addVerticalSlider( freq , fVslider1, 440.0f, 50.0f, 1000.0f, 0.100000001f); ui_interface- addVerticalSlider( gain , fVslider0, 0.0f, 0.0f, 1.0f, 0.00999999978f); ui_interface- closeBox(); } Note that path names are inherent to the use of tools gravitating around Faust such as OSC control or faust2api . In the case of faust2api , since no user interface is actually generated, UI elements just become a way to declare parameters of a Faust object. Therefore, there's no distinction between nentry , hslider , vslider , etc.","title":"Labels as Pathnames"},{"location":"refs/syntax/#smoothing","text":"Despite the fact that the signal generated by user interface elements can be used in Faust with any other signals, UI elements run at a slower rate than the audio rate. This might be a source of clicking if the value of the corresponding parameter is modified while the program is running. This behavior is also amplified by the low resolution of signals generated by UI elements (as opposed to actual audio signals). For example, changing the value of the freq or gain parameters of the following code will likely create clicks (in the case of gain ) or abrupt jumps (in the case of freq ) in the signal: import( stdfaust.lib ); freq = hslider( freq ,440,50,1000,0.1); gain = hslider( gain ,0,0,1,0.01); process = os.osc(freq)*gain; Try it Yourself >> This problem can be easily solved in Faust by using the si.smoo function which implements an exponential smoothing by a unit-dc-gain one-pole lowpass with a pole at 0.999 ( si.smoo is just sugar for si.smooth(0.999) ). Therefore, the previous example can be rewritten as: import( stdfaust.lib ); freq = hslider( freq ,440,50,1000,0.1) : si.smoo; gain = hslider( gain ,0,0,1,0.01) : si.smoo; process = os.osc(freq)*gain; Try it Yourself >> Beware that each si.smoo that you place in your code will add some extra computation so they should be used precociously.","title":"Smoothing"},{"location":"refs/syntax/#links-to-generated-code","text":"UI elements provide a convenient entry point to the DSP process in the code generated by the Faust compiler (e.g., C++, etc.). For example, the Faust program: import( stdfaust.lib ); freq = hslider( freq ,440,50,1000,0.1); process = os.osc(freq); will have the corresponding buildUserInterface method in C++: virtual void buildUserInterface(UI* ui_interface) { ui_interface- openVerticalBox( osc ); ui_interface- addHorizontalSlider( freq , fHslider0, 440.0f, 50.0f, 1000.0f, 0.100000001f); ui_interface- closeBox(); } The second argument of the addHorizontalSlider method is a pointer to the variable containing the current value of the freq parameter. The value of this pointer can be updated at any point to change the frequency of the corresponding oscillator.","title":"Links to Generated Code"},{"location":"refs/syntax/#ui-label-metadata","text":"Widget labels can contain metadata enclosed in square brackets. These metadata associate a key with a value and are used to provide additional information to the architecture file. They are typically used to improve the look and feel of the user interface, configure OSC and accelerometer control/mapping, etc. Since the format of the value associated to a key is relatively open, metadata constitute a flexible way for programmers to add features to the language. The Faust code: process = *(hslider( foo[key1: val 1][key2: val 2] ,0,0,1,0.1)); will produce the corresponding C++ code: class mydsp : public dsp { ... virtual void buildUserInterface(UI* ui_interface) { ui_interface- openVerticalBox( tst ); ui_interface- declare( fHslider0, key1 , val 1 ); ui_interface- declare( fHslider0, key2 , val 2 ); ui_interface- addHorizontalSlider( foo , fHslider0, 0.0f, 0.0f, 1.0f, 0.100000001f); ui_interface- closeBox(); } ... }; All metadata are removed from the label by the compiler and transformed in calls to the UI::declare() method. All these UI::declare() calls will always take place before the UI::AddSomething() call that creates the User Interface element. This allows the UI::AddSomething() method to make full use of the available metadata. Metadata are architecture-specific: it is up to the architecture file to decide what to do with it. While some metadata will work with most architectures (e.g., accelerometer and OSC configuration, etc.), others might be more specific. Some of them are presented in the following sections.","title":"UI Label Metadata"},{"location":"refs/syntax/#ordering-ui-elements","text":"The order of UI declarations in a Faust code doesn't necessarily reflect the actual order of the UI elements in the corresponding interface. Therefore, UI elements can be ordered by placing a metadata before the declaration of the name of the UI element in the label. For example, in the following declaration: gain = vslider( h:Oscillator/[1]gain ,0,0,1,0.01); freq = vslider( h:Oscillator/[0]freq ,440,50,1000,0.1); the freq parameter will be placed before gain despite the fact that gain is declared first. This system can be used to order groups as well. Ordering will be carried out on elements at the same level. For example: import( stdfaust.lib ); freqS = vslider( h:Oscillators/h:[0]Sawtooth/[0]freq ,440,50,1000,0.1); gainS = vslider( h:Oscillators/h:[0]Sawtooth/[1]gain ,0,0,1,0.01); freqT = vslider( h:Oscillators/h:[1]Triangle/[0]freq ,440,50,1000,0.1); gainT = vslider( h:Oscillators/h:[1]Triangle/[1]gain ,0,0,1,0.01); process = os.sawtooth(freqS)*gainS + os.triangle(freqT)*gainT; Try it Yourself >> Note that this could also be written as: import( stdfaust.lib ); freqS = vslider( [0]freq ,440,50,1000,0.1); gainS = vslider( [1]gain ,0,0,1,0.01); freqT = vslider( [0]freq ,440,50,1000,0.1); gainT = vslider( [1]gain ,0,0,1,0.01); process = hgroup( Oscillators , hgroup( [0]Sawtooth ,os.sawtooth(freqS)*gainS) + hgroup( [1]Triangle ,os.triangle(freqT)*gainT) ); Try it Yourself >>","title":"Ordering UI Elements"},{"location":"refs/syntax/#global-ui-metadata","text":"Note that global user interfaces completely replacing the one defined using the standard Faust UI primitives may be declared using global metadata . This is the case of the SmartKeyboard interface for example. In the following subsections, the standard Faust UI metadata are documented. Other types of metadata (e.g., accelerometers, OSC, etc.) are documented in the sections related to these topics.","title":"Global UI Metadata"},{"location":"refs/syntax/#styleknob-metadata","text":"The [style:knob] metadata turns any continuous UI element (i.e., hslider , vslider , nentry ) into a knob. Example import( stdfaust.lib ); freq = vslider( freq[style:knob] ,440,50,1000,0.1); process = os.sawtooth(freq); Try it Yourself >>","title":"[style:knob] Metadata"},{"location":"refs/syntax/#stylemenu-metadata","text":"The [style:menu] metadata turns any continuous UI element (i.e., hslider , vslider , nentry ) into a drop-down menu. Usage [style:menu{'Name0':value0;'Name1':value1}] Where: NameN : the name associated to valueN valueN : the value associated to NameN Example: Selector import( stdfaust.lib ); s = vslider( Signal[style:menu{'Noise':0;'Sawtooth':1}] ,0,0,1,1); process = select2(s,no.noise,os.sawtooth(440)); Try it Yourself >>","title":"[style:menu] Metadata"},{"location":"refs/syntax/#styleradio-metadata","text":"The [style:radio] metadata turns a hslider or a vslider into a radio-button-menu. The orientation of the menu is determined by the type of UI element (i.e., hslider for horizontal and vslider for vertical). Usage [style:radio{'Name0':value0;'Name1':value1}] Where: NameN : the name associated to valueN valueN : the value associated to NameN Example: Selector import( stdfaust.lib ); s = vslider( Signal[style:radio{'Noise':0;'Sawtooth':1}] ,0,0,1,1); process = select2(s,no.noise,os.sawtooth(440)); Try it Yourself >>","title":"[style:radio] Metadata"},{"location":"refs/syntax/#styleled-metadata","text":"The [style:led] metadata turns a vbargraph or a hbargraph into a blinking LED (with varying intensity). Example: Level Display import( stdfaust.lib ); process = _ : attach(_,abs : ba.linear2db : vbargraph( Level[style:led] ,-60,0)); Try it Yourself >>","title":"[style:led] Metadata"},{"location":"refs/syntax/#stylenumerical-metadata","text":"The [style:numerical] metadata turns a vbargraph or a hbargraph into a numerical zone (thus the bargraph itself is no more displayed). Example: Level Display import( stdfaust.lib ); process = _ : attach(_,abs : ba.linear2db : vbargraph( Level[style:numerical] ,-60,0)); Try it Yourself >>","title":"[style:numerical] Metadata"},{"location":"refs/syntax/#unitdb-metadata","text":"The [style:dB] metadata changes the unit of a vbargraph or a hbargraph to dB. This impacts its overall appearance by applying a rainbow color scheme, etc. Example: Level Display import( stdfaust.lib ); process = _ : attach(_,abs : ba.linear2db : vbargraph( Level[style:dB] ,-60,0)); Try it Yourself >>","title":"[unit:dB] Metadata"},{"location":"refs/syntax/#unitxx-metadata","text":"The [unit:xx] metadata allows us to specify the unit of a UI element. The unit will be displayed right next to the current value of the parameter in the interface. Usage [unit:xx] Where: xx : the unit of the current parameter Example import( stdfaust.lib ); freq = vslider( freq[unit:Hz] ,440,50,1000,0.1); process = os.sawtooth(freq); Try it Yourself >>","title":"[unit:xx] Metadata"},{"location":"refs/syntax/#scalexx-metadata","text":"The [scale:xx] metadata allows for the specification of a scale (different than the default linear one) to the parameter in the UI. [scale:log] can be used to change to scale to logarithmic and [scale:exp] to exponential.","title":"[scale:xx] Metadata"},{"location":"refs/syntax/#tooltipxx-metadata","text":"The [tooltip:xx] metadata allows for the specification of a \"tooltip\" when the mouse hover a parameter in the interface. This is very convenient when implementing complex interfaces. Usage [tooltip:xx] Where: xx : a string to be used as a tooltip in the interface Example import( stdfaust.lib ); freq = vslider( freq[tooltip:The frequency of the oscillator] ,440,50,1000,0.1); process = os.sawtooth(freq); Try it Yourself >>","title":"[tooltip:xx] Metadata"},{"location":"refs/syntax/#hiddenxx-metadata","text":"The [hidden:xx] metadata can be used to hide a parameter in the interface. This is convenient when controlling a parameter with a motion sensor or OSC messages and we don't want it to be visible in the interface. This feature is commonly used when making apps for Android and iOS using faust2android or faust2ios . Compatibility iOS Android","title":"[hidden:xx] Metadata"},{"location":"refs/syntax/#sensors-control-metadatas","text":"Sensors control metadata can be used to map the built-in sensors of mobile devices to some of the parameters of a Faust program. Compatibility These metadatas are compatible with the following Faust targets and no additional step is required for them to be taken into account when the corresponding app is generated: faust2android faust2ios faust2smartkeyb Sensors control metadatas have five parameters and follow the following syntax: [acc: a b c d e] // for accelerometer [gyr: a b c d e] // for gyroscope They can be used in a Faust UI parameter declaration: parameter = nentry( UIparamName[acc: a b c d e] ,def,min,max,step); with: a : the accelerometer axis ( 0 : x, 1 : y, 2 : z) b : the accelerometer curve (see figure below) c : the minimum acceleration (m/s^2) d : the center acceleration (m/s^2) e : the maximum acceleration (m/s^2) def : the default/init value of the parameter min : the minimum value of the parameter max : the maximum value of the parameter step : the step of the parameter (precision) This allows for the implementation of complex linear and non-linear mappings that are summarized in this figure: For example, controlling the gain of a synthesizer using the X axis of the accelerometer can be easily done simply by writing something like: g = nentry( gain[acc: 0 0 -10 0 10] ,0.5,0,1,0.01); With this configuration, g = 0 when the device is standing vertically on its right side, g = 0.5 when the device is standing horizontally with screen facing up, and g = 1 when the device is standing vertically on its left side. Finally, in this slightly more complex mapping, g = 0 when the device is tilted on its right side and the value of g increases towards 1 when the device is tilted on its left side: g = nentry( gain[acc: 0 0 0 0 10] ,0,0,1,0.01); Complex nonlinear mappings can be implemented using this system.","title":"Sensors Control Metadatas"},{"location":"refs/tools/","text":"Using the Faust Tools While in its most primitive form, Faust is distributed as a command-line compiler, a wide range of tools have been developed around it in the course of the past few years. Their variety and their function might be hard to grab at first. This sort chapter provides an overview of their role and will hopefully help you decide which one is better suited for your personal use. The Faust tools is a set of scripts that take a dsp file as input to generate various output for a lot of architectures and platforms. All the tools names are in the form faust2xxx where xxx is the target architecture. faust2alqt faust2alsa faust2alsaconsole faust2android faust2androidunity faust2api faust2au faust2bela faust2caqt faust2caqtios faust2csound faust2csvplot faust2dssi faust2faustvst faust2gen faust2ios faust2jack faust2jackconsole faust2jackrust faust2jackserver faust2jaqt faust2jaqtchain faust2juce faust2ladspa faust2linuxunity faust2lv2 faust2mathdoc faust2max6 faust2msp faust2netjackconsole faust2netjackqt faust2nodejs faust2osxiosunity faust2paqt faust2plot faust2portaudiorust faust2raqt faust2rpialsaconsole faust2rpinetjackconsole faust2sam faust2smartkeyb faust2sndfile faust2soul faust2unity faust2wasm faust2webaudiowasm faust2webaudiowast","title":"Using Tools"},{"location":"refs/tools/#using-the-faust-tools","text":"While in its most primitive form, Faust is distributed as a command-line compiler, a wide range of tools have been developed around it in the course of the past few years. Their variety and their function might be hard to grab at first. This sort chapter provides an overview of their role and will hopefully help you decide which one is better suited for your personal use. The Faust tools is a set of scripts that take a dsp file as input to generate various output for a lot of architectures and platforms. All the tools names are in the form faust2xxx where xxx is the target architecture.","title":"Using the Faust Tools"},{"location":"refs/tools/#faust2alqt","text":"","title":"faust2alqt"},{"location":"refs/tools/#faust2alsa","text":"","title":"faust2alsa"},{"location":"refs/tools/#faust2alsaconsole","text":"","title":"faust2alsaconsole"},{"location":"refs/tools/#faust2android","text":"","title":"faust2android"},{"location":"refs/tools/#faust2androidunity","text":"","title":"faust2androidunity"},{"location":"refs/tools/#faust2api","text":"","title":"faust2api"},{"location":"refs/tools/#faust2au","text":"","title":"faust2au"},{"location":"refs/tools/#faust2bela","text":"","title":"faust2bela"},{"location":"refs/tools/#faust2caqt","text":"","title":"faust2caqt"},{"location":"refs/tools/#faust2caqtios","text":"","title":"faust2caqtios"},{"location":"refs/tools/#faust2csound","text":"","title":"faust2csound"},{"location":"refs/tools/#faust2csvplot","text":"","title":"faust2csvplot"},{"location":"refs/tools/#faust2dssi","text":"","title":"faust2dssi"},{"location":"refs/tools/#faust2faustvst","text":"","title":"faust2faustvst"},{"location":"refs/tools/#faust2gen","text":"","title":"faust2gen"},{"location":"refs/tools/#faust2ios","text":"","title":"faust2ios"},{"location":"refs/tools/#faust2jack","text":"","title":"faust2jack"},{"location":"refs/tools/#faust2jackconsole","text":"","title":"faust2jackconsole"},{"location":"refs/tools/#faust2jackrust","text":"","title":"faust2jackrust"},{"location":"refs/tools/#faust2jackserver","text":"","title":"faust2jackserver"},{"location":"refs/tools/#faust2jaqt","text":"","title":"faust2jaqt"},{"location":"refs/tools/#faust2jaqtchain","text":"","title":"faust2jaqtchain"},{"location":"refs/tools/#faust2juce","text":"","title":"faust2juce"},{"location":"refs/tools/#faust2ladspa","text":"","title":"faust2ladspa"},{"location":"refs/tools/#faust2linuxunity","text":"","title":"faust2linuxunity"},{"location":"refs/tools/#faust2lv2","text":"","title":"faust2lv2"},{"location":"refs/tools/#faust2mathdoc","text":"","title":"faust2mathdoc"},{"location":"refs/tools/#faust2max6","text":"","title":"faust2max6"},{"location":"refs/tools/#faust2msp","text":"","title":"faust2msp"},{"location":"refs/tools/#faust2netjackconsole","text":"","title":"faust2netjackconsole"},{"location":"refs/tools/#faust2netjackqt","text":"","title":"faust2netjackqt"},{"location":"refs/tools/#faust2nodejs","text":"","title":"faust2nodejs"},{"location":"refs/tools/#faust2osxiosunity","text":"","title":"faust2osxiosunity"},{"location":"refs/tools/#faust2paqt","text":"","title":"faust2paqt"},{"location":"refs/tools/#faust2plot","text":"","title":"faust2plot"},{"location":"refs/tools/#faust2portaudiorust","text":"","title":"faust2portaudiorust"},{"location":"refs/tools/#faust2raqt","text":"","title":"faust2raqt"},{"location":"refs/tools/#faust2rpialsaconsole","text":"","title":"faust2rpialsaconsole"},{"location":"refs/tools/#faust2rpinetjackconsole","text":"","title":"faust2rpinetjackconsole"},{"location":"refs/tools/#faust2sam","text":"","title":"faust2sam"},{"location":"refs/tools/#faust2smartkeyb","text":"","title":"faust2smartkeyb"},{"location":"refs/tools/#faust2sndfile","text":"","title":"faust2sndfile"},{"location":"refs/tools/#faust2soul","text":"","title":"faust2soul"},{"location":"refs/tools/#faust2unity","text":"","title":"faust2unity"},{"location":"refs/tools/#faust2wasm","text":"","title":"faust2wasm"},{"location":"refs/tools/#faust2webaudiowasm","text":"","title":"faust2webaudiowasm"},{"location":"refs/tools/#faust2webaudiowast","text":"","title":"faust2webaudiowast"},{"location":"workshops/2018-12-01-paw/","text":"Building a Simple MIDI Synthesizer We are going to build a MIDI synthesizer from scratch (without using the Faust libraries). Phase Generator The first step is to build a phase generator that produces a periodic sawtooth signal between 0 and 1. Here is the signal we want to generate: Ramp In order to produce the above signal we need first to produce a ramp signal using the following Faust program: process = 0.125 : + ~ _; Try it Yourself >> You can think of a Faust program as a description of an audio circuit where 0.125 , + and _ are primitives of the language (predefined elementary audio components), and the other two signs: : and ~ are used to connect together these audio components. Semantics To understand the above diagram let's annotate it with its mathematical semantics. As we can see in the diagram, the formula of the output signal is: $y(t) = y(t-1) + 0.125$ We can compute the first values of $y(t)$: $y(t 0)=0$ $y(0) = y(-1) + 0.125 = 0.125$ $y(1) = y(0) + 0.125 = 2*0.125 = 0.250$ $y(2) = y(1) + 0.125 = 3*0.125 = 0.375$ ... $y(6) = y(5) + 0.125 = 7*0.125 = 0.875$ $y(7) = y(6) + 0.125 = 8*0.125 = 1.000$ $y(8) = y(7) + 0.125 = 9*0.125 = 1.125$ ... Phase Signal How can we transform the above ramp into sawtooth signal ? By removing the integer part of the samples in order to keep only the decimal (fractional) part ( 3.14159 - 0.14159 ). Let's define a function to do that: decimalpart(x) = x - int(x); We can now use that function to transform our ramp into a sawtooth It is then tempting to write: process = 0.125 : + ~ _ : decimalpart; From a mathematical point of view that would be perfectly correct, but we will accumulate rounding errors. To keep full precision it is better to place the decimal part operation inside the loop: process = 0.125 : (+ : decimalpart) ~ _ ; We can now listen the produced signal. Just copy and past decimalpart and process definitions into the Faust editor Controlling the Frequency of the Phase Signal Let's first rearrange our code decimalpart(x) = x-int(x); phase = 0.125 : (+ : decimalpart) ~ _ ; process = phase; Try it Yourself >> In our phase definition the step value, here 0.125 controls the frequency of the generated signal. We would like to compute this step value according to the desired frequency. In order to do the conversion we need to know the sampling rate. It is available from the standard library as ma.SR . Let say we would like our phase signal to have a frequency of 1 Hz, then the step should be very small 1/ma.SR so that is will take ma.SR samples (i.e. 1 second) for the phase signal to reach 1. If we want a frequency of 440 Hz, we need a step 440 times bigger for the phase signal to reach 1 440 times faster. phase = 440/ma.SR : (+ : decimalpart) ~ _ ; We can generalize this definition by replacing 440 by a parameter f : phase(f) = f/ma.SR : (+ : decimalpart) ~ _ ; and by indicating the desired frequency when we use phase : process = phase(440); Creating a Sine Wave Oscillator The next step is to transform above phase generator into a sine wave generator. We will use the sin primitive that computes the sine of x (measured in radians). Therefore we start for the phase signal, we multiply it by $2\\pi$ to obtain radiants, and compute the sine. The full program is the following: import( stdfaust.lib ); decimalpart(x) = x-int(x); phase(f) = f/ma.SR : (+ : decimalpart) ~ _ ; osc(f) = phase(f) * 2 * ma.PI : sin; process = osc(440); Try it Yourself >> Controlling the Frequency and Gain of the Oscillator The next step is to add some controls on the frequency and gain of the oscillator. We can replace the fixed frequency 440 by a user interface slider: process = osc(hslider( freq , 440, 20, 10000, 1)); and add a gain to control the output level of the oscillator: process = osc(hslider( freq , 440, 20, 10000, 1)) * hslider( gain , 0.5, 0, 1, 0.01); Adding a Gate Button In order to prepare our MIDI synthesizer we need to add a gate button so that the sound is only when we press it: process = osc(hslider( freq , 440, 20, 10000, 1)) * hslider( gain , 0.5, 0, 1, 0.01) * button( gate ); Adding an Envelope Generator It is a good idea to also add an envelop generator. Here we will use a predefined adsr in the Standard Faust library. import( stdfaust.lib ); decimalpart(x) = x-int(x); phase(f) = f/ma.SR : (+ : decimalpart) ~ _ ; osc(f) = phase(f) * 2 * ma.PI : sin; process = osc(hslider( freq , 440, 20, 10000, 1)) * hslider( gain , 0.5, 0, 1, 0.01) * (button( gate ) : en.adsr(0.1,0.1,0.98,0.1)); Try it Yourself >> Improving the Timbre Instead of playing pure sine waves tones, let's improve the timbre with simple additive synthesis: timbre(f) = osc(f)*0.5 + osc(f*2)*0.25 + osc(f*3)*0.125; process = timbre(hslider( freq , 440, 20, 10000, 1)) * hslider( gain , 0.5, 0, 1, 0.01) * (button( gate ) : en.adsr(0.1,0.1,0.98,0.1)); Running as a Polyphonic MIDI Synth To control the synthesizer using MIDI you need to use Chrome. The polyphonic MIDI mode is activated using the drop down menu Poly Voices on the left side of the editor. Choose Computer Keyboard as MIDI input to play notes with the computer keyboard, or plug a MIDI keyboard. Adding a Global Effect A global effect can be added by providing a definition for effect . // Common effect effect = dm.zita_light; import( stdfaust.lib ); decimalpart(x) = x-int(x); phase(f) = f/ma.SR : (+ : decimalpart) ~ _ ; timbre(f) = phase(f)*0.5 + phase(f*2)*0.25 + phase(f*3)*0.125; process = timbre(hslider( freq , 440, 20, 10000, 1)) * hslider( gain , 0.5, 0, 1, 0.01) * (button( gate ) : en.adsr(0.1,0.1,0.98,0.1)); effect = dm.zita_light; Try it Yourself >>","title":" 2018-12-01 PAW "},{"location":"workshops/2018-12-01-paw/#building-a-simple-midi-synthesizer","text":"We are going to build a MIDI synthesizer from scratch (without using the Faust libraries).","title":"Building a Simple MIDI Synthesizer"},{"location":"workshops/2018-12-01-paw/#phase-generator","text":"The first step is to build a phase generator that produces a periodic sawtooth signal between 0 and 1. Here is the signal we want to generate:","title":"Phase Generator"},{"location":"workshops/2018-12-01-paw/#ramp","text":"In order to produce the above signal we need first to produce a ramp signal using the following Faust program: process = 0.125 : + ~ _; Try it Yourself >> You can think of a Faust program as a description of an audio circuit where 0.125 , + and _ are primitives of the language (predefined elementary audio components), and the other two signs: : and ~ are used to connect together these audio components.","title":"Ramp"},{"location":"workshops/2018-12-01-paw/#semantics","text":"To understand the above diagram let's annotate it with its mathematical semantics. As we can see in the diagram, the formula of the output signal is: $y(t) = y(t-1) + 0.125$ We can compute the first values of $y(t)$: $y(t 0)=0$ $y(0) = y(-1) + 0.125 = 0.125$ $y(1) = y(0) + 0.125 = 2*0.125 = 0.250$ $y(2) = y(1) + 0.125 = 3*0.125 = 0.375$ ... $y(6) = y(5) + 0.125 = 7*0.125 = 0.875$ $y(7) = y(6) + 0.125 = 8*0.125 = 1.000$ $y(8) = y(7) + 0.125 = 9*0.125 = 1.125$ ...","title":"Semantics"},{"location":"workshops/2018-12-01-paw/#phase-signal","text":"How can we transform the above ramp into sawtooth signal ? By removing the integer part of the samples in order to keep only the decimal (fractional) part ( 3.14159 - 0.14159 ). Let's define a function to do that: decimalpart(x) = x - int(x); We can now use that function to transform our ramp into a sawtooth It is then tempting to write: process = 0.125 : + ~ _ : decimalpart; From a mathematical point of view that would be perfectly correct, but we will accumulate rounding errors. To keep full precision it is better to place the decimal part operation inside the loop: process = 0.125 : (+ : decimalpart) ~ _ ; We can now listen the produced signal. Just copy and past decimalpart and process definitions into the Faust editor","title":"Phase Signal"},{"location":"workshops/2018-12-01-paw/#controlling-the-frequency-of-the-phase-signal","text":"Let's first rearrange our code decimalpart(x) = x-int(x); phase = 0.125 : (+ : decimalpart) ~ _ ; process = phase; Try it Yourself >> In our phase definition the step value, here 0.125 controls the frequency of the generated signal. We would like to compute this step value according to the desired frequency. In order to do the conversion we need to know the sampling rate. It is available from the standard library as ma.SR . Let say we would like our phase signal to have a frequency of 1 Hz, then the step should be very small 1/ma.SR so that is will take ma.SR samples (i.e. 1 second) for the phase signal to reach 1. If we want a frequency of 440 Hz, we need a step 440 times bigger for the phase signal to reach 1 440 times faster. phase = 440/ma.SR : (+ : decimalpart) ~ _ ; We can generalize this definition by replacing 440 by a parameter f : phase(f) = f/ma.SR : (+ : decimalpart) ~ _ ; and by indicating the desired frequency when we use phase : process = phase(440);","title":"Controlling the Frequency of the Phase Signal"},{"location":"workshops/2018-12-01-paw/#creating-a-sine-wave-oscillator","text":"The next step is to transform above phase generator into a sine wave generator. We will use the sin primitive that computes the sine of x (measured in radians). Therefore we start for the phase signal, we multiply it by $2\\pi$ to obtain radiants, and compute the sine. The full program is the following: import( stdfaust.lib ); decimalpart(x) = x-int(x); phase(f) = f/ma.SR : (+ : decimalpart) ~ _ ; osc(f) = phase(f) * 2 * ma.PI : sin; process = osc(440); Try it Yourself >>","title":"Creating a Sine Wave Oscillator"},{"location":"workshops/2018-12-01-paw/#controlling-the-frequency-and-gain-of-the-oscillator","text":"The next step is to add some controls on the frequency and gain of the oscillator. We can replace the fixed frequency 440 by a user interface slider: process = osc(hslider( freq , 440, 20, 10000, 1)); and add a gain to control the output level of the oscillator: process = osc(hslider( freq , 440, 20, 10000, 1)) * hslider( gain , 0.5, 0, 1, 0.01);","title":"Controlling the Frequency and Gain of the Oscillator"},{"location":"workshops/2018-12-01-paw/#adding-a-gate-button","text":"In order to prepare our MIDI synthesizer we need to add a gate button so that the sound is only when we press it: process = osc(hslider( freq , 440, 20, 10000, 1)) * hslider( gain , 0.5, 0, 1, 0.01) * button( gate );","title":"Adding a Gate Button"},{"location":"workshops/2018-12-01-paw/#adding-an-envelope-generator","text":"It is a good idea to also add an envelop generator. Here we will use a predefined adsr in the Standard Faust library. import( stdfaust.lib ); decimalpart(x) = x-int(x); phase(f) = f/ma.SR : (+ : decimalpart) ~ _ ; osc(f) = phase(f) * 2 * ma.PI : sin; process = osc(hslider( freq , 440, 20, 10000, 1)) * hslider( gain , 0.5, 0, 1, 0.01) * (button( gate ) : en.adsr(0.1,0.1,0.98,0.1)); Try it Yourself >>","title":"Adding an Envelope Generator"},{"location":"workshops/2018-12-01-paw/#improving-the-timbre","text":"Instead of playing pure sine waves tones, let's improve the timbre with simple additive synthesis: timbre(f) = osc(f)*0.5 + osc(f*2)*0.25 + osc(f*3)*0.125; process = timbre(hslider( freq , 440, 20, 10000, 1)) * hslider( gain , 0.5, 0, 1, 0.01) * (button( gate ) : en.adsr(0.1,0.1,0.98,0.1));","title":"Improving the Timbre"},{"location":"workshops/2018-12-01-paw/#running-as-a-polyphonic-midi-synth","text":"To control the synthesizer using MIDI you need to use Chrome. The polyphonic MIDI mode is activated using the drop down menu Poly Voices on the left side of the editor. Choose Computer Keyboard as MIDI input to play notes with the computer keyboard, or plug a MIDI keyboard.","title":"Running as a Polyphonic MIDI Synth"},{"location":"workshops/2018-12-01-paw/#adding-a-global-effect","text":"A global effect can be added by providing a definition for effect . // Common effect effect = dm.zita_light; import( stdfaust.lib ); decimalpart(x) = x-int(x); phase(f) = f/ma.SR : (+ : decimalpart) ~ _ ; timbre(f) = phase(f)*0.5 + phase(f*2)*0.25 + phase(f*3)*0.125; process = timbre(hslider( freq , 440, 20, 10000, 1)) * hslider( gain , 0.5, 0, 1, 0.01) * (button( gate ) : en.adsr(0.1,0.1,0.98,0.1)); effect = dm.zita_light; Try it Yourself >>","title":"Adding a Global Effect"},{"location":"workshops/2020-03-24-faust-citi/","text":"Faust workshop at CITI L'objectif de ce workshop est de se familiariser avec le langage Faust \u00e0 travers des exemples simples de synth\u00e8se sonore. Pour cela on va utiliser Faust pour d\u00e9crire des circuits audio qui produisent des sons suivant diff\u00e9rentes m\u00e9thodes. Tous les exemples seront execut\u00e9 dans l'IDE Faust en ligne https://faustide.grame.fr Synth\u00e8se additive Exemple 1 : une onde sinusoidale Commen\u00e7ons par une simple onde sinusoidale. Attention \u00e0 mettre le volume bas ! import( stdfaust.lib ); process = os.osc(440); Try it Yourself >> Exemple 2 : une onde sinusoidale avec controle de volume Dans ce deuxi\u00e8me exemple on a utilis\u00e9 un slider horizontal hslider(...) pour r\u00e9gler le niveau sonore. import( stdfaust.lib ); process = os.osc(440) * hslider( gain , 0.1, 0, 1, 0.01); Try it Yourself >> Le premier param\u00e8tre est une chaine de caract\u00e8re qui indique le nom du slider. Il est suivi de quatre param\u00e8tres num\u00e9riques. Le deuxi\u00e8me param\u00e8tre 0.1 indique la valeur par d\u00e9faut du slider, c'est \u00e0 dire la valeur que va d\u00e9livrer le slider quand on lance le programme. Ensuite nous avons la valeur minimale 0 , la valeur maximale 1 et le pas de variation 0.01 . Exemple 3 : Exercice, ajouter un contr\u00f4le de fr\u00e9quence A titre d'exercice, remplacer, dans l'exemple pr\u00e9c\u00e9dent, la fr\u00e9quence 440 par un slider horizontal dont le nom sera \"freq\" , la valeur par d\u00e9faut 110 , la valeur minimale 40 , la valeur maximale 8000 et le pas 1 . import( stdfaust.lib ); process = os.osc(440 /*a remplacer*/) * hslider( gain , 0.1, 0, 1, 0.01); Try it Yourself Exemple 4 : Synthese additive Un exemple de synth\u00e8se additive ou le niveau de chaque partiel peut \u00eatre r\u00e9gl\u00e9 individuellement. import( stdfaust.lib ); //---------------------------------------------------------------------- // partial(f,n); // f = fr\u00e9quence en Hz // n = numero du partiel en partant de 1 partial(n,f) = os.osc(f*n) * hslider( partial %n , 0.25, 0, 1, 0.01); process = sum(i, 4, partial(i+1,hslider( freq , 440, 20, 8000, 0.001))); Try it Yourself A noter l'utilisation de la construction sum(i, n, foo(i)) qui est equivalente \u00e0 foo(0)+foo(1)+...+foo(n-1) . Exemple 5 : Approximation d'un signal carr\u00e9 par synth\u00e8se additive wikipedia Blabla import( stdfaust.lib ); // Approximation of a square wave using additive synthesis squarewave(f) = 4/ma.PI*sum(k, 8, os.osc((2*k+1)*f)/(2*k+1)); process = squarewave(55); Try it Yourself Blabla Exemple 6 : Approximation d'un signal en dent de scie par synth\u00e8se additive Blabla import( stdfaust.lib ); // Approximation of a sawtooth wave using additive synthesis sawtooth(f) = 2/ma.PI*sum(k, 8, (-1)^k * os.osc((k+1)*f)/(k+1)); process = sawtooth(55); Try it Yourself Blabla Exemple 7 : Ph\u00e9nom\u00e8ne de repliement de fr\u00e9quence si l'on va au-del\u00e0 de SR/2 Blabla import( stdfaust.lib ); // Ph\u00e9nom\u00e8ne de repliement de fr\u00e9quence si l'on va au-del\u00e0 de SR/2 process = os.osc(hslider( freq , 440, 20, 20000, 1)); Try it Yourself Blabla Exemple 8 : Mathematical square wave doesn't sound great because of aliasing Blabla import( stdfaust.lib ); // Mathematical square wave doesn't sound great because of aliasing phasor(f) = f/ma.SR : (+,1:fmod)~_; exactsquarewave(f) = (os.phasor(1,f) 0.5)*2.0-1.0; process = exactsquarewave(hslider( freq , 440, 20, 8000, 1))*hslider( gain , 0.5, 0, 1, 0.01); Try it Yourself Blabla Exemple 9 : Virtual Analog square wave with less aliasing Blabla import( stdfaust.lib ); // Virtual Analog square wave with less aliasing process = os.squareN(3,hslider( freq , 220, 20, 8000, 1))*hslider( gain , 0.5, 0, 1, 0.01); Try it Yourself Blabla Synth\u00e8se soustractive Exemple 1 : un bruit blanc Commen\u00e7ons par une simple onde sinusoidale. Attention \u00e0 mettre le volume bas ! import( stdfaust.lib ); process = no.noise * hslider( noise , 0.5, 0, 1, 0.01); Try it Yourself >> Exemple 2 : lowpass Commen\u00e7ons par une simple onde sinusoidale. Attention \u00e0 mettre le volume bas ! import( stdfaust.lib ); process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : fi.lowpass(3, hslider( hifreq , 2000, 20, 20000, 1)); Try it Yourself >> Exemple 3 : high pass Commen\u00e7ons par une simple onde sinusoidale. Attention \u00e0 mettre le volume bas ! import( stdfaust.lib ); process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : fi.highpass(3, hslider( lowfreq , 400, 20, 20000, 1)); Try it Yourself >> Exemple 4 : bandpass Commen\u00e7ons par une simple onde sinusoidale. Attention \u00e0 mettre le volume bas ! import( stdfaust.lib ); process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : fi.highpass(3, hslider( lowfreq , 400, 20, 20000, 1)) : fi.lowpass(3, hslider( hifreq , 2000, 20, 20000, 1)); Try it Yourself >> Exemple 5 : resonnant Commen\u00e7ons par une simple onde sinusoidale. Attention \u00e0 mettre le volume bas ! import( stdfaust.lib ); process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : fi.resonlp( hslider( hifreq , 400, 20, 20000, 1), hslider( Q , 1, 1, 100, 0.01), hslider( gain , 1, 0, 2, 0.01)); Try it Yourself >> Exemple 6 : fir bla bla import( stdfaust.lib ); // FIR process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : _ , transformation : _; transformation = @(1) : *(hslider( gain , 0, -1, 1, 0.1)); Try it Yourself Exemple 7 : iir bla bla import( stdfaust.lib ); // IIR process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : + ~ transformation; transformation = @(0) : *(hslider( gain , 0, -0.95, 0.95, 0.01)); Try it Yourself Exemple 8 : filtre en peigne bla bla import( stdfaust.lib ); // IIR, Filtre en peigne process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : + ~ transformation; transformation = @(hslider( delay , 0, 0, 20, 1)) : *(hslider( gain , 0, -0.98, 0.98, 0.01)); Try it Yourself Exemple 9 : Karplus Strong (1/2) bla bla import( stdfaust.lib ); // Karplus Strong (1/2) process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : + ~ transformation; transformation = @(hslider( delay , 0, 0, 200, 1)) : moyenne : *(hslider( gain , 0, -0.98, 0.98, 0.01)); moyenne(x) = (x+x')/2; Try it Yourself Exemple 10 : Karplus Strong (2/2) bla bla import( stdfaust.lib ); // Karplus Strong (2/2) process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : *(envelop) : + ~ transformation; transformation = @(hslider( delay , 0, 0, 200, 1)) : moyenne : *(hslider( gain , 0, -0.999, 0.999, 0.001)); moyenne(x) = (x+x')/2; envelop = button( gate ) : upfront : en.ar(0.002, 0.01); upfront(x) = x x'; Try it Yourself Exemple 11 : Kisana bla bla declare name myKisana ; declare author Yann Orlarey ; //Modifications GRAME July 2015 /* ========= DESCRITPION ============= - Kisana : 3-loops string instrument (based on Karplus-Strong) - Head = Silence - Tilt = High frequencies - Front = High + Medium frequencies - Bottom = High + Medium + Low frequencies - Left = Minimum brightness - Right = Maximum birghtness - Front = Long notes - Back = Short notes */ import( stdfaust.lib ); KEY = 60; // basic midi key NCY = 15; // note cycle length CCY = 15; // control cycle length BPS = 360; // general tempo (ba.beat per sec) process = kisana; //-------------------------------kisana---------------------------------- // USAGE: kisana : _,_; // 3-loops string instrument //----------------------------------------------------------------------- kisana = vgroup( MyKisana , harpe(C,11,48), harpe(C,11,60), (harpe(C,11,72) : *(1.5), *(1.5)) : *(l), *(l)) with { l = -20 : ba.db2linear;//hslider( [1]Volume ,-20, -60, 0, 0.01) : ba.db2linear; C = hslider( [2]Brightness[acc:0 1 -10 0 10] , 0.2, 0, 1, 0.01) : ba.automat(BPS, CCY, 0.0); }; //----------------------------------Harpe-------------------------------- // USAGE: harpe(C,10,60) : _,_; // C is the filter coefficient 0..1 // Build a N (10) strings harpe using a pentatonic scale // based on midi key b (60) // Each string is triggered by a specific // position of the hand //----------------------------------------------------------------------- harpe(C,N,b) = hand(b) : par(i, N, position(i+1) : string(C,Penta(b).degree2Hz(i), att, lvl) : pan((i+0.5)/N) ) : _,_ with { att = hslider( [3]Resonance[acc:2 1 -10 0 12] , 4, 0.1, 10, 0.01); hand(48) = vslider( h:[1]Instrument Hands/1 (Note %b)[unit:pk] , 0, 0, N, 1) : int : ba.automat(120, CCY, 0.0); hand(60) = vslider( h:[1]Instrument Hands/2 (Note %b)[unit:pk] , 2, 0, N, 1) : int : ba.automat(240, CCY, 0.0); hand(72) = vslider( h:[1]Instrument Hands/3 (Note %b)[unit:pk] , 4, 0, N, 1) : int : ba.automat(480, CCY, 0.0); //lvl = vslider( h:loop/level , 0, 0, 6, 1) : int : ba.automat(BPS, CCY, 0.0) : -(6) : ba.db2linear; lvl = 1; pan(p) = _ : *(sqrt(1-p)), *(sqrt(p)); position(a,x) = abs(x - a) 0.5; }; //----------------------------------Penta------------------------------- // Pentatonic scale with degree to midi and degree to Hz conversion // USAGE: Penta(60).degree2midi(3) == 67 midikey // Penta(60).degree2Hz(4) == 440 Hz //----------------------------------------------------------------------- Penta(key) = environment { A4Hz = 440; degree2midi(0) = key+0; degree2midi(1) = key+2; degree2midi(2) = key+4; degree2midi(3) = key+7; degree2midi(4) = key+9; degree2midi(d) = degree2midi(d-5)+12; degree2Hz(d) = A4Hz*semiton(degree2midi(d)-69) with { semiton(n) = 2.0^(n/12.0); }; }; //----------------------------------String------------------------------- // A karplus-strong string. // // USAGE: string(440Hz, 4s, 1.0, button( play )) // or button( play ) : string(440Hz, 4s, 1.0) //----------------------------------------------------------------------- string(coef, freq, t60, level, trig) = no.noise*level : *(trig : trigger(freq2samples(freq))) : resonator(freq2samples(freq), att) with { resonator(d,a) = (+ : @(d-1)) ~ (average : *(a)); average(x) = (x*(1+coef)+x'*(1-coef))/2; trigger(n) = upfront : + ~ decay(n) : (0.0); upfront(x) = (x-x') 0.0; decay(n,x) = x - (x 0.0)/n; freq2samples(f) = 44100.0/f; att = pow(0.001,1.0/(freq*t60)); // attenuation coefficient random = +(12345)~*(1103515245); noise = random/2147483647.0; }; Try it Yourself Synth\u00e8se par modulation de fr\u00e9quence Exemple 1 : fm1 Bla bla import( stdfaust.lib ); // FM: Frequency moulation FM(fc,fm,amp) = fm : os.osc : *(amp) : +(1) : *(fc) : os.osc; process = FM( hslider( freq carrier , 880, 40, 8000, 1), hslider( freq modulation , 200, 10, 1000, 1), hslider( amp modulation , 0, 0, 1, 0.01) ) : _,_; Try it Yourself >> Exemple 2 : fm2 Bla bla import( stdfaust.lib ); // FM: Frequency moulation 2 FM(fc,fm,amp) = fm : os.osc : *(amp) : +(1) : *(fc) : os.osc; process = FM( hslider( freq carrier , 880, 40, 8000, 1), hslider( freq modulation , 200, 10, 1000, 1)*(2+envelop2)/3, hslider( amp modulation , 0, 0, 1, 0.01)*(0.5+envelop2)/1.5 ) : *(envelop1) : dm.freeverb_demo; envelop1 = button( gate ) : upfront : en.ar(0.001, 1); envelop2 = button( gate ) : upfront : en.ar(0.5, 0.5); upfront(x) = x x'; Try it Yourself >>","title":" 2020-03-24 CITI "},{"location":"workshops/2020-03-24-faust-citi/#faust-workshop-at-citi","text":"L'objectif de ce workshop est de se familiariser avec le langage Faust \u00e0 travers des exemples simples de synth\u00e8se sonore. Pour cela on va utiliser Faust pour d\u00e9crire des circuits audio qui produisent des sons suivant diff\u00e9rentes m\u00e9thodes. Tous les exemples seront execut\u00e9 dans l'IDE Faust en ligne https://faustide.grame.fr","title":"Faust workshop at CITI"},{"location":"workshops/2020-03-24-faust-citi/#synthese-additive","text":"","title":"Synth\u00e8se additive"},{"location":"workshops/2020-03-24-faust-citi/#exemple-1-une-onde-sinusoidale","text":"Commen\u00e7ons par une simple onde sinusoidale. Attention \u00e0 mettre le volume bas ! import( stdfaust.lib ); process = os.osc(440); Try it Yourself >>","title":"Exemple 1 : une onde sinusoidale"},{"location":"workshops/2020-03-24-faust-citi/#exemple-2-une-onde-sinusoidale-avec-controle-de-volume","text":"Dans ce deuxi\u00e8me exemple on a utilis\u00e9 un slider horizontal hslider(...) pour r\u00e9gler le niveau sonore. import( stdfaust.lib ); process = os.osc(440) * hslider( gain , 0.1, 0, 1, 0.01); Try it Yourself >> Le premier param\u00e8tre est une chaine de caract\u00e8re qui indique le nom du slider. Il est suivi de quatre param\u00e8tres num\u00e9riques. Le deuxi\u00e8me param\u00e8tre 0.1 indique la valeur par d\u00e9faut du slider, c'est \u00e0 dire la valeur que va d\u00e9livrer le slider quand on lance le programme. Ensuite nous avons la valeur minimale 0 , la valeur maximale 1 et le pas de variation 0.01 .","title":"Exemple 2 : une onde sinusoidale avec controle de volume"},{"location":"workshops/2020-03-24-faust-citi/#exemple-3-exercice-ajouter-un-controle-de-frequence","text":"A titre d'exercice, remplacer, dans l'exemple pr\u00e9c\u00e9dent, la fr\u00e9quence 440 par un slider horizontal dont le nom sera \"freq\" , la valeur par d\u00e9faut 110 , la valeur minimale 40 , la valeur maximale 8000 et le pas 1 . import( stdfaust.lib ); process = os.osc(440 /*a remplacer*/) * hslider( gain , 0.1, 0, 1, 0.01); Try it Yourself","title":"Exemple 3 : Exercice, ajouter un contr\u00f4le de fr\u00e9quence"},{"location":"workshops/2020-03-24-faust-citi/#exemple-4-synthese-additive","text":"Un exemple de synth\u00e8se additive ou le niveau de chaque partiel peut \u00eatre r\u00e9gl\u00e9 individuellement. import( stdfaust.lib ); //---------------------------------------------------------------------- // partial(f,n); // f = fr\u00e9quence en Hz // n = numero du partiel en partant de 1 partial(n,f) = os.osc(f*n) * hslider( partial %n , 0.25, 0, 1, 0.01); process = sum(i, 4, partial(i+1,hslider( freq , 440, 20, 8000, 0.001))); Try it Yourself A noter l'utilisation de la construction sum(i, n, foo(i)) qui est equivalente \u00e0 foo(0)+foo(1)+...+foo(n-1) .","title":"Exemple 4 : Synthese additive"},{"location":"workshops/2020-03-24-faust-citi/#exemple-5-approximation-dun-signal-carre-par-synthese-additive","text":"wikipedia Blabla import( stdfaust.lib ); // Approximation of a square wave using additive synthesis squarewave(f) = 4/ma.PI*sum(k, 8, os.osc((2*k+1)*f)/(2*k+1)); process = squarewave(55); Try it Yourself Blabla","title":"Exemple 5 : Approximation d'un signal carr\u00e9 par synth\u00e8se additive"},{"location":"workshops/2020-03-24-faust-citi/#exemple-6-approximation-dun-signal-en-dent-de-scie-par-synthese-additive","text":"Blabla import( stdfaust.lib ); // Approximation of a sawtooth wave using additive synthesis sawtooth(f) = 2/ma.PI*sum(k, 8, (-1)^k * os.osc((k+1)*f)/(k+1)); process = sawtooth(55); Try it Yourself Blabla","title":"Exemple 6 : Approximation d'un signal en dent de scie par synth\u00e8se additive"},{"location":"workshops/2020-03-24-faust-citi/#exemple-7-phenomene-de-repliement-de-frequence-si-lon-va-au-dela-de-sr2","text":"Blabla import( stdfaust.lib ); // Ph\u00e9nom\u00e8ne de repliement de fr\u00e9quence si l'on va au-del\u00e0 de SR/2 process = os.osc(hslider( freq , 440, 20, 20000, 1)); Try it Yourself Blabla","title":"Exemple 7 : Ph\u00e9nom\u00e8ne de repliement de fr\u00e9quence si l'on va au-del\u00e0 de SR/2"},{"location":"workshops/2020-03-24-faust-citi/#exemple-8-mathematical-square-wave-doesnt-sound-great-because-of-aliasing","text":"Blabla import( stdfaust.lib ); // Mathematical square wave doesn't sound great because of aliasing phasor(f) = f/ma.SR : (+,1:fmod)~_; exactsquarewave(f) = (os.phasor(1,f) 0.5)*2.0-1.0; process = exactsquarewave(hslider( freq , 440, 20, 8000, 1))*hslider( gain , 0.5, 0, 1, 0.01); Try it Yourself Blabla","title":"Exemple 8 : Mathematical square wave doesn't sound great because of aliasing"},{"location":"workshops/2020-03-24-faust-citi/#exemple-9-virtual-analog-square-wave-with-less-aliasing","text":"Blabla import( stdfaust.lib ); // Virtual Analog square wave with less aliasing process = os.squareN(3,hslider( freq , 220, 20, 8000, 1))*hslider( gain , 0.5, 0, 1, 0.01); Try it Yourself Blabla","title":"Exemple 9 : Virtual Analog square wave with less aliasing"},{"location":"workshops/2020-03-24-faust-citi/#synthese-soustractive","text":"","title":"Synth\u00e8se soustractive"},{"location":"workshops/2020-03-24-faust-citi/#exemple-1-un-bruit-blanc","text":"Commen\u00e7ons par une simple onde sinusoidale. Attention \u00e0 mettre le volume bas ! import( stdfaust.lib ); process = no.noise * hslider( noise , 0.5, 0, 1, 0.01); Try it Yourself >>","title":"Exemple 1 : un bruit blanc"},{"location":"workshops/2020-03-24-faust-citi/#exemple-2-lowpass","text":"Commen\u00e7ons par une simple onde sinusoidale. Attention \u00e0 mettre le volume bas ! import( stdfaust.lib ); process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : fi.lowpass(3, hslider( hifreq , 2000, 20, 20000, 1)); Try it Yourself >>","title":"Exemple 2 : lowpass"},{"location":"workshops/2020-03-24-faust-citi/#exemple-3-high-pass","text":"Commen\u00e7ons par une simple onde sinusoidale. Attention \u00e0 mettre le volume bas ! import( stdfaust.lib ); process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : fi.highpass(3, hslider( lowfreq , 400, 20, 20000, 1)); Try it Yourself >>","title":"Exemple 3 : high pass"},{"location":"workshops/2020-03-24-faust-citi/#exemple-4-bandpass","text":"Commen\u00e7ons par une simple onde sinusoidale. Attention \u00e0 mettre le volume bas ! import( stdfaust.lib ); process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : fi.highpass(3, hslider( lowfreq , 400, 20, 20000, 1)) : fi.lowpass(3, hslider( hifreq , 2000, 20, 20000, 1)); Try it Yourself >>","title":"Exemple 4 : bandpass"},{"location":"workshops/2020-03-24-faust-citi/#exemple-5-resonnant","text":"Commen\u00e7ons par une simple onde sinusoidale. Attention \u00e0 mettre le volume bas ! import( stdfaust.lib ); process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : fi.resonlp( hslider( hifreq , 400, 20, 20000, 1), hslider( Q , 1, 1, 100, 0.01), hslider( gain , 1, 0, 2, 0.01)); Try it Yourself >>","title":"Exemple 5 : resonnant"},{"location":"workshops/2020-03-24-faust-citi/#exemple-6-fir","text":"bla bla import( stdfaust.lib ); // FIR process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : _ , transformation : _; transformation = @(1) : *(hslider( gain , 0, -1, 1, 0.1)); Try it Yourself","title":"Exemple 6 : fir"},{"location":"workshops/2020-03-24-faust-citi/#exemple-7-iir","text":"bla bla import( stdfaust.lib ); // IIR process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : + ~ transformation; transformation = @(0) : *(hslider( gain , 0, -0.95, 0.95, 0.01)); Try it Yourself","title":"Exemple 7 : iir"},{"location":"workshops/2020-03-24-faust-citi/#exemple-8-filtre-en-peigne","text":"bla bla import( stdfaust.lib ); // IIR, Filtre en peigne process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : + ~ transformation; transformation = @(hslider( delay , 0, 0, 20, 1)) : *(hslider( gain , 0, -0.98, 0.98, 0.01)); Try it Yourself","title":"Exemple 8 : filtre en peigne"},{"location":"workshops/2020-03-24-faust-citi/#exemple-9-karplus-strong-12","text":"bla bla import( stdfaust.lib ); // Karplus Strong (1/2) process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : + ~ transformation; transformation = @(hslider( delay , 0, 0, 200, 1)) : moyenne : *(hslider( gain , 0, -0.98, 0.98, 0.01)); moyenne(x) = (x+x')/2; Try it Yourself","title":"Exemple 9 : Karplus Strong (1/2)"},{"location":"workshops/2020-03-24-faust-citi/#exemple-10-karplus-strong-22","text":"bla bla import( stdfaust.lib ); // Karplus Strong (2/2) process = no.noise * hslider( noise , 0.5, 0, 1, 0.01) : *(envelop) : + ~ transformation; transformation = @(hslider( delay , 0, 0, 200, 1)) : moyenne : *(hslider( gain , 0, -0.999, 0.999, 0.001)); moyenne(x) = (x+x')/2; envelop = button( gate ) : upfront : en.ar(0.002, 0.01); upfront(x) = x x'; Try it Yourself","title":"Exemple 10 : Karplus Strong (2/2)"},{"location":"workshops/2020-03-24-faust-citi/#exemple-11-kisana","text":"bla bla declare name myKisana ; declare author Yann Orlarey ; //Modifications GRAME July 2015 /* ========= DESCRITPION ============= - Kisana : 3-loops string instrument (based on Karplus-Strong) - Head = Silence - Tilt = High frequencies - Front = High + Medium frequencies - Bottom = High + Medium + Low frequencies - Left = Minimum brightness - Right = Maximum birghtness - Front = Long notes - Back = Short notes */ import( stdfaust.lib ); KEY = 60; // basic midi key NCY = 15; // note cycle length CCY = 15; // control cycle length BPS = 360; // general tempo (ba.beat per sec) process = kisana; //-------------------------------kisana---------------------------------- // USAGE: kisana : _,_; // 3-loops string instrument //----------------------------------------------------------------------- kisana = vgroup( MyKisana , harpe(C,11,48), harpe(C,11,60), (harpe(C,11,72) : *(1.5), *(1.5)) : *(l), *(l)) with { l = -20 : ba.db2linear;//hslider( [1]Volume ,-20, -60, 0, 0.01) : ba.db2linear; C = hslider( [2]Brightness[acc:0 1 -10 0 10] , 0.2, 0, 1, 0.01) : ba.automat(BPS, CCY, 0.0); }; //----------------------------------Harpe-------------------------------- // USAGE: harpe(C,10,60) : _,_; // C is the filter coefficient 0..1 // Build a N (10) strings harpe using a pentatonic scale // based on midi key b (60) // Each string is triggered by a specific // position of the hand //----------------------------------------------------------------------- harpe(C,N,b) = hand(b) : par(i, N, position(i+1) : string(C,Penta(b).degree2Hz(i), att, lvl) : pan((i+0.5)/N) ) : _,_ with { att = hslider( [3]Resonance[acc:2 1 -10 0 12] , 4, 0.1, 10, 0.01); hand(48) = vslider( h:[1]Instrument Hands/1 (Note %b)[unit:pk] , 0, 0, N, 1) : int : ba.automat(120, CCY, 0.0); hand(60) = vslider( h:[1]Instrument Hands/2 (Note %b)[unit:pk] , 2, 0, N, 1) : int : ba.automat(240, CCY, 0.0); hand(72) = vslider( h:[1]Instrument Hands/3 (Note %b)[unit:pk] , 4, 0, N, 1) : int : ba.automat(480, CCY, 0.0); //lvl = vslider( h:loop/level , 0, 0, 6, 1) : int : ba.automat(BPS, CCY, 0.0) : -(6) : ba.db2linear; lvl = 1; pan(p) = _ : *(sqrt(1-p)), *(sqrt(p)); position(a,x) = abs(x - a) 0.5; }; //----------------------------------Penta------------------------------- // Pentatonic scale with degree to midi and degree to Hz conversion // USAGE: Penta(60).degree2midi(3) == 67 midikey // Penta(60).degree2Hz(4) == 440 Hz //----------------------------------------------------------------------- Penta(key) = environment { A4Hz = 440; degree2midi(0) = key+0; degree2midi(1) = key+2; degree2midi(2) = key+4; degree2midi(3) = key+7; degree2midi(4) = key+9; degree2midi(d) = degree2midi(d-5)+12; degree2Hz(d) = A4Hz*semiton(degree2midi(d)-69) with { semiton(n) = 2.0^(n/12.0); }; }; //----------------------------------String------------------------------- // A karplus-strong string. // // USAGE: string(440Hz, 4s, 1.0, button( play )) // or button( play ) : string(440Hz, 4s, 1.0) //----------------------------------------------------------------------- string(coef, freq, t60, level, trig) = no.noise*level : *(trig : trigger(freq2samples(freq))) : resonator(freq2samples(freq), att) with { resonator(d,a) = (+ : @(d-1)) ~ (average : *(a)); average(x) = (x*(1+coef)+x'*(1-coef))/2; trigger(n) = upfront : + ~ decay(n) : (0.0); upfront(x) = (x-x') 0.0; decay(n,x) = x - (x 0.0)/n; freq2samples(f) = 44100.0/f; att = pow(0.001,1.0/(freq*t60)); // attenuation coefficient random = +(12345)~*(1103515245); noise = random/2147483647.0; }; Try it Yourself","title":"Exemple 11 : Kisana"},{"location":"workshops/2020-03-24-faust-citi/#synthese-par-modulation-de-frequence","text":"","title":"Synth\u00e8se par modulation de fr\u00e9quence"},{"location":"workshops/2020-03-24-faust-citi/#exemple-1-fm1","text":"Bla bla import( stdfaust.lib ); // FM: Frequency moulation FM(fc,fm,amp) = fm : os.osc : *(amp) : +(1) : *(fc) : os.osc; process = FM( hslider( freq carrier , 880, 40, 8000, 1), hslider( freq modulation , 200, 10, 1000, 1), hslider( amp modulation , 0, 0, 1, 0.01) ) : _,_; Try it Yourself >>","title":"Exemple 1 : fm1"},{"location":"workshops/2020-03-24-faust-citi/#exemple-2-fm2","text":"Bla bla import( stdfaust.lib ); // FM: Frequency moulation 2 FM(fc,fm,amp) = fm : os.osc : *(amp) : +(1) : *(fc) : os.osc; process = FM( hslider( freq carrier , 880, 40, 8000, 1), hslider( freq modulation , 200, 10, 1000, 1)*(2+envelop2)/3, hslider( amp modulation , 0, 0, 1, 0.01)*(0.5+envelop2)/1.5 ) : *(envelop1) : dm.freeverb_demo; envelop1 = button( gate ) : upfront : en.ar(0.001, 1); envelop2 = button( gate ) : upfront : en.ar(0.5, 0.5); upfront(x) = x x'; Try it Yourself >>","title":"Exemple 2 : fm2"}]}