<!-- doc-begin -->

# 简介 

## 什么是 Faust ？

Faust (Functional Audio Stream) 是一种为声音合成和音频处理设计的函数式编程语言，主要用于设计合成器、乐器、音频效果器等。使用 Faust，可以为各平台与标准编写高性能信号处理应用和音频插件，可用于音乐舞台、艺术创作、教育和研究，并可集成于开源项目以及商业应用之中。

Faust 的核心是它的编译器。它能让我们将任何 Faust 数字信号处理（DSP）规范“翻译”成多种非特定领域语言，如 C++、C、JAVA、LLVM IR、WebAssembly 等。从这方面来说，Faust 可以看作是 C++ 的一种替代，但学习起来更加简单直观。

得益于不同“架构”的封装系统，Faust 生成的代码可以很容易地被编译至各种各样的对象，从音频插件到独立应用或智能手机和 Web 应用等。

本手册将通过各种交互式的例子，概述 Faust 编程语言及其功能。

## 用 Faust 做什么比较合适？

Faust 的语法能将任何 DSP 算法表达为一个框图。例如，`+` 是一个有效的函数（块），它接收两个参数（信号）并返回一个值：

<!-- faust-run -->
```
process = +;
```
<!-- /faust-run -->

块与块之间能简单地使用“连接”组合符 `:` 连接起来：

<!-- faust-run -->
```
process = + : *(0.5);
```
<!-- /faust-run -->

这时，我们已将两个信号相加，并将结果进行缩放。

因此，**Faust 非常适合实现一些可以很容易地用框图来表示的时域算法**，如滤波器、波导物理模型、虚拟模拟元件等。

**Faust 语言非常简洁**，例如，以下代码实现的是一个单极滤波器/积分器，相当于 \(y(n) = x(n) + a_{1}y(n-1)\) （其中 \(a_{1}\) 是极点）:

<!-- faust-run -->
```
a1 = 0.9;
process = +~*(a1);
```
<!-- /faust-run -->

**Faust生成的代码是高度优化的**，通常（至少对于 C 和 C++）比手写代码性能更好。Faust 编译器会试图优化算法中的各个元素。例如，您无须担心应使用除法还是乘法，因为如果可能，它们都会被编译器自动替换为乘法。

**Faust 的泛用性很高**，用它写出的代码可以在几十个不同平台上运行。

<!-- If we stick to this, we should also talk about the web capabilities: in
other words be a bit more specific here. -->

## 用 Faust 做什么可能并不合适？

尽管如此，Faust 也有一些局限性。例如，它无法高效地实现需要多重速率的算法，如 FFT、卷积等。虽然有一些技巧可以规避，但我们也充分意识到这是一个相当重要的问题，我们正在尝试尽可能将其解决。

Faust 语言简洁的特性有时也会成为问题，特别是对于一些含有许多递归信号的复杂算法。通常，使用 Faust 实现算法时需要在脑海中有“大局观”，有时候是很难的。

虽然 Faust 编译器相对来说 bug 很少，但它还是有局限性，可能会在一些极端的情况下卡死。您可能并不会遇到这些极端情况，不过如果遇到了，您可以给我们 [写封邮件](https://sourceforge.net/p/faudiostream/mailman/)！

现在您可以跳到本文档的 [快速开始教程](../quick-start) 部分.

## 设计原则

自 2002 年开始开发以来，Faust 一直遵循各种设计原则。

* Faust 是一种*规范语言*。其目标是提供一种恰当的表达方式，能从数理的角度描述*信号处理器*。Faust 尽可能让算法作者不需实现太多细节。
* Faust 程序会被编译（而不是被解释）。编译器将 Faust 程序翻译成其他语言（如 JAVA、LLVM IR、WebAssembly 等）的等效程序，并负责生成最为有效的代码。其结果一般可以媲美（有时甚至可以超越）经验丰富的程序员编写的 C++ 代码。
* 所生成的代码会在单采样级别运行。因此，它适合于实现递归滤波器等低级 DSP 功能。此外，这些代码可以很容易地嵌入其他程序。代码上它是独立的，不依赖于任何 DSP 库或运行环境。它具有相当确定的行为和恒定的内存占用。
* Faust 的语义简单且有明确的定义。这并不是为了便于教学，而是为了让 Faust 编译器由*语义驱动*。它并不按文字意义编译程序，而是编译为它所表达的数学函数。这个功能对于一些功能非常有用。例如可以在促进组件重用的同时保持最佳性能。 
* Faust 是一种文本语言，但也是面向框图的。实际上它结合了两种思维：*函数式编程*和*代数框图*。其关键思想是将框图的构建过程看作函数的组合。为此，Faust 语言的设计依靠了*框图代数*的五种组合运算 `: , ~ <: :>`（详见[框图组合运算](.../syntax/#diagram-composition-operations)一节）。
* 得益于*架构*的概念，无需对 Faust 代码进行任何修改，就可以很方便地部署在各种音频平台和插件格式上。

## 信号处理器语义

一个 Faust 程序会描述一个*信号处理器*，而*信号处理器*的作用是变换一组（可能是零个）*输入信号*，以产生一组（可能是零个）*输出信号*。大多数音频设备都可以被建模为*信号处理器*。它们有音频输入、音频输出以及一些接口的控制信号，如滑块、旋钮、量表等。

更准确地说:

* 一个*信号* \(s\) 是一个时间的离散函数 \(s:\mathbb{Z}\rightarrow\mathbb{R}\)。一个信号的值 \(s\) 在时间 \(t\) 上表示为 \(s(t)\)。信号的值通常需要从时间 \(0\) 开始计算。但是为了考虑到*延迟运算*，负时间也是可以计算的，并且总是取值为 0。因此，对于任意 Faust 信号 \(s\)，有 \(\forall t<0, s(t)=0\)。在操作上，相当于设所有延迟线都是初始化为 \(0\) 的信号。
* Faust 计算的信号有两类：*整型信号* \(s:\mathbb{Z}\rightarrow\mathbb{Z}\) 和*浮点信号* \(s:\mathbb{Z}\rightarrow\mathbb{Q}\)。与外界的信号交换按照惯例使用浮点信号。用于表示信号采样的值介于 \(-1.0\) 和 \(+1.0\) 之间。
* 所有可能的信号的集合为 \(\mathbb{S}=\mathbb{Z}\rightarrow\mathbb{R}\).
* 一组 \(n\) 个信号（一个*n*元信号）可表示为 \((s_{1},\ldots,s_{n})\in \mathbb{S}^{n}\)。*空元组*，\(\mathbb{S}^{0}\) 的单元素可记作 \(()\).
* 一个*信号处理器* \(p\)，是一个从*n*元信号到*m*元信号的函数 \(p:\mathbb{S}^{n}\rightarrow\mathbb{S}^{m}\)。集合 \(\mathbb{P}=\bigcup_{n,m}\mathbb{S}^{n}\rightarrow\mathbb{S}^{m}\) 是所有可能的信号处理器的集合。

例如，试表达 Faust 基本运算符 `+` 的含义。与任意 Faust 表达式一样，它也是一个信号处理器。其标识为 \(\mathbb{S}^{2}\rightarrow\mathbb{S}\)。它接收两个输入信号 \(X_0\) 和 \(X_1\) 产生一个输出信号 \(Y\) 并使 \(Y(t) = X_0(t)+X_1(t)\). 

常数本身也是信号处理器。如常数 \(3\) 标识为 \(\mathbb{S}^{0}\rightarrow\mathbb{S}\)。它不接收输入信号，产生一个输出信号 \(Y\) 并使 \(Y(t) = 3\)。
